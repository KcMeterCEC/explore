* [What]linux --> program 
** Daemon Process(守护进程)
*** 基本概念
**** 什么是守护进程
守护进程开系统启动后就会一直运行, 直到系统关闭.并且这些进程不会占用终端.
**** 进程组,会话
在一个终端下运行的程序(进程)会共享同一个控制终端, 会话(session) 指的就是一个或多个进程组的集合.

一个进程都有它属于的进程组, 而进程组的ID号(GID), 也就是组长进程的ID号(PID).

*在控制终端退出后, 基于此终端的进程也会退出*.

从上面可以得出: 一个进程要摆脱一个控制终端, 需要脱离会话和进程组.对应的函数就是 =setsid()=

setsid()具有如下特性:
1. 当进程不是进程组组长时, 会新建一个会话, 否则返回错误.
2. 此进程组会成为会话的首进程, 同时此进程是进程组的组长.
3. 此进程将脱离控制终端
*** 编写
**** 编写步骤
基于上面的概念, 以及参考APUE, 可以得出编写守护进程的步骤为:
1. 调用 *umask* 设置新建文件的权限为0. 
2. 使用 *fork* 新建进程, 并且使父进程退出
3. 使用 *setsid* 脱离当前会话, 并建立与终端无关的会话
4. 将工作目录切换到根目录下
5. 关闭文件描述符
6. 再次使用 *fork* 创建一个子进程, 并退出父进程, 让当前进程不为组长.
7. 设置当前进程的输入,输出,以及错误输出到 =/dev/null= , 用于清除显示.
#+BEGIN_SRC c
#include "apue.h"
#include <stdio.h>
#include <syslog.h>
#include <fcntl.h>
#include <sys/resource.h>

void daemonize(const char *cmd)
{
        int    i, fd0, fd1, fd2;
        pid_t  pid;
        struct rlimit rl;
        struct sigaction sa;

        /**
         ,* @note clear file creation mask
         ,*/
        umask(0);
        /**
         ,* get maximum number of file descriptors
         ,*/
        if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
        {
                printf("%s, can't get file limit", cmd);
        }
        /**
         ,* @note become a session leader to lose controlling TTY.
         ,*/
        if((pid == fork()) < 0)
        {
                printf("%s, can't fork", cmd);
        }
        else if(pid != 0) /// parent
        {
                exit(0);
        }
        setsid();
        /**
         ,* @note ensure future opens won't allocate controlling TTYs.
         ,*/
        sa.sa_handler = SIG_IGN;
        sigemtyset(&sa.sa_mask);
        sa.sa_flags = 0;
        if(sigaction(SIGHUP, &sa, NULL) < 0)
        {
                printf("%s, can't ignore SIGHUP", cmd);
        }
        if((pid = fork() < 0))
        {
                printf("%s, can't fork", cmd);
        }
        if(pid != 0)/// parent
        {
                exit(0);
        }
        /**
         ,* @note change the current working directory to the root so
         ,* we won't prevent file systems from being unmounted
         ,*/
        if(chdir("/") < 0)
        {
                printf("%s, can't change directory to /", cmd);
        }
        /**
         ,* @note close all open file descriptors
         ,*/
        if(rl.rlim_max == RLIM_INFINITY)
        {
                rl.rlim_max = 1024;
        }
        for(i = 0; i < ri.rlim_max; i++)
        {
                close(i);
        }
        /**
         ,* @note attach file descriptors 0, 1, and 2 to /dev/null
         ,*/
        fd0 = open("/dev/null", O_RDWR);
        fd1 = dup(0);
        fd2 = dup(0);
        /**
         ,* @note initialize the log file
         ,*/
        openlog(cmd, LOG_CONS, LOG_DAEMON);
        if(fd0 != 0 || fd1 != 1 || fd2 != 2)
        {
                printf("unexpected file descriptors %d %d %d", fd0, fd1, fd2);
                exit(1);
        }
}
#+END_SRC
