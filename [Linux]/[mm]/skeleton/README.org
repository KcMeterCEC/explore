#+TITLE: [What]Linux 内存的申请与释放
#+DATE:  <2018-06-14 四> 
#+TAGS: memory
#+LAYOUT: post 
#+CATEGORIES: linux, memory, overview
#+NAME: <linux_memory_overview_allocAndFree.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

整理Linux中的内存申请与释放的原理。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* buddy 算法
** 算法缺陷
buddy算法虽然是动态的分离和合并，但合并的前置条件是这段物理内存空间需要是连续的。但在申请内存的时候，确实分散的。
随着时间的推移，最终必然会造成很多空闲内存分散的情况。

这就会造成一个问题： *当DMA需要申请一个连续的物理内存空间时，虽然空闲页面远远大于此内存，但由于它们都是分散的，导致申请失败!*
- 对于用户而言，虚拟地址空间连续即可，物理空间是否分散都不影响其使用，而DMA是直接对应物理内存操作的，需要其物理内存真的连续。
** 解决方案
*** reserved 内存
为了保证DMA在任何时候都可以申请到连续的物理内存，所以在一开始就指定一片内存区域为保留区，仅仅用于DMA申请连续物理内存。

但这会导致当平时DMA不使用时，这片内存也无法用作其他用途，造成空间浪费。
*** CMA(连续内存分配器)
为了弥补 reserved 方式的不足，三星提出了CMA方式，其基本思想为：
1. 在物理内存分配了一片CMA区域(设备树中指定)，这片区域是物理内存连续的。
2. 当DMA没有使用时，这片CMA区域交付给用户空间使用
3. 当DMA要使用时，将用户空间的虚拟与物理内存对应表进行修改，也就是将这片物理内存区域移动到其他物理内存区域，空闲出CMA区。
  - 在这个过程中，由于应用程序的虚拟地址没有改变，所有其感知不到这个变化
  - 在移动应用程序对应的物理内存时，新申请的内存是否连续对应用程序并不影响
  - 由于在移动过程中需要重新修改页表，这段时间应用程序无法操作物理内存，会有短暂的卡顿。
4. 将CMA区交付给DMA使用。


