* [What]Linux --> 内存与IO访问
** CPU 与内存,I/O
*** 内存空间与I/O空间
I/O空间的概念是存在于X86架构中的, 它通过特定的指令in,out来访问.
在大多数嵌入式微控制器中没有I/O空间,仅有内存空间.内存空间可以直接通过地址,指针来访问,程序以及其他数据都是存在于内存空间中的.
*** 内存管理单元MMU
MMU提供虚拟地址和物理地址的映射,内存访问权限保护和Cache缓存控制等硬件支持.
**** 基本概念
1. TLB(Translation Lookaside Buffer)
转换旁路缓存,TLB是MMU的核心部件,它缓存少量的虚拟地址与物理地址的转换关系,是转换表的Cache,因此也经常被称为"快表".
2. TTW(Translation Table wale)
转换表漫游,当TLB中没有缓冲对应的地址转换对应关系时,需要通过对内存中转换表的访问来获得虚拟地址和物理地址的对应关系.TTW成功后,结果应写入TLB中.
*** Linux内存管理
在Linux系统中,进程的 *虚拟4GB内存空间* 被分为两个部分---用户空间和内核空间.
用户空间的地址一般分布为0~3GB(即PAGE_OFFSET),剩下的3~4GB为内核空间. *用户进程只有通过系统调用(代表用户进程在内核态执行)等方式才可以访问到内核空间*.
每个进程的用户空间都是完全独立,互不相干的, *用户进程各自由不同的页表*.而内核空间是由内核负责映射,它并不会跟着进程改变,是固定的.
*内核空间的虚拟地址到物理地址的映射是被所有进程共享的,内核虚拟空间独立于其他程序*.

Linux 中1GB的内核地址空间又被划分为物理内存映射区,虚拟内存分配区,高端页面映射区,专用页面映射区和系统保留映射区这几个区域.
| 内存位置                        | 名称                    |
|---------------------------------+-------------------------|
| 0xfff0000~0xffff0fff            | 向量表                  |
| VMALLOC_START ~ VMALLOC_END - 1 | vmalloc 和 ioremap 区域 |
| PAGE_OFFSET ~ high_memory -1    | DMA和常规区域内存映射   |
| MODULES_VADDR ~ MODULES_END -1  | 内核模块区域            |
| PKMAP_BASE ~ PAGE_OFFSET -1     | 高端内存映射区                 |

*对于内核物理内存映射区的虚拟内存(即从DMA和常规区域映射过来的),使用 =virt_to_phys()= 实现内核虚拟地址转化为物理地址.与之相对的函数为 =phys_to_virt()=*
*** 内存存取
**** 用户空间内存动态申请
- 申请 malloc()
- 释放 free()

*Linux内核总是采用按需调页(Demand Paging),因此当 malloc()返回的时候,虽然是成功返回,但是内核并没有真正给这个进程内存.这个时候如果去读申请的内存,内容全部是0,这个页面的映射是只读的.只有当写到某个页面的时候,内核才在页错误后,真正把这个页面给这个进程.*

**** 内核空间内存动态申请
kmalloc() 和 __get_free_pages() 及其类似函数,申请的内存位于"DMA和常规区域的映射区",而且 *在物理上也是连续的*,
它们与真实的物理地址只有一个固定的偏移,因此存在较简单的转换关系.而vmalloc()在虚拟内存空间给出一块连续的内存区,实际上,
*这片连续的虚拟内存在物理内存中并不一定连续*,而vmalloc()申请的虚拟内存和物理内存之间页没有简单的换算关系.
1. void *kmalloc(size_t size, int flags)  <->  kfree()
size 代表分配块的大小
flags : 
        GFP_KERNEL -> 在内核空间的进程中申请内存. *若不能满足,则进程会睡眠等待*, *不能在中断上下文和持有自旋锁的时候使用*!
        GFP_ATOMIC -> 若不存在空闲页则不等待,直接返回.
        GFP_USER   -> 为用户空间页分配内存
        GFP_DMA    -> 从DMA区域分配内存
2. __get_free_pages() / __get_zeroed_page() <-> free_pages()
本质上是Linux内核最底层用于获取空闲内存的方法.
3. vmalloc() <-> vfree()
一般只为存在于软件中(没有对应的硬件意义)的较大的顺序缓冲区分配内存, *vmalloc()远大于__get_free_pages()的开销*
因此,*使用此函数来分配少量内存是不妥的.
4. slab 与内存池

        
        
