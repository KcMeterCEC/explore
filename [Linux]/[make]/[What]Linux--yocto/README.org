* [What]yocto --> base
参考链接:[[www.yoctoproject.org/docs/2.3.1/mega-manual/mega-manual.html][yocto参考手册]]

** 快速准备与体验操作
*** Yocto 开发环境介绍

yocto 的编译部分是基于 OpenEmbedded(OE)项目, OE项目使用 BitBake 来构建完整的镜像文件.
在 yocto 中, *OE 和 BitBake两个组件结合在一起, 形成了一个新的组件, 叫做 Poky(也是yocto 项目的名称)*.


yocto 提供了可以开发以及仿真ARM,MIPS,PowerPC,X86平台的开发环境, 并且可以完成Linux的
全栈仿真应用.

[[./oe_workflow.bmp][OE流程]]

yocto具有如下特征:
- 提供最新的linux kernel 代码, 以及相应的嵌入式开发所需要的库环境
- 提供UI组件,包括X11,GTK+,Qt,Clutter,SDL.
- 提供稳定的开源嵌入式开发环境
- 提供QEMU来仿真全栈
- 基于分层式设计, 可以很好的开发和扩展

最终yocto可以生成镜像文件以在实际硬件平台上设置.
*** 准备工作
为了能够保证yocto正常运行, 需要准备如下的运行环境:
**** linux主机
目前支持的主机有 Ubuntu,Fedora,openSUSE,CentOS,Debian.

需要安装的依赖包有:
- git1.8.3.1 或更高等级
- tar1.2.4 或更高
- Python3.4.0 或更高 
**** 主机依赖包安装
***** Ubuntu 和 Debian 
- 安装QEMU所需要的基本依赖
#+begin_example
sudo apt install gawk wget git-core diffstat unzip texinfo gcc-multilib \
build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \
xz-utils debianutils iputils-ping libsdl1.2-dev xterm
#+end_example
**** yocto 获取
#+begin_example
git clone git://git.yoctoproject.org/poky
git checkout pyro
#+end_example
*** 编译镜像文件
**** 编译仿真环境
**** 基本配置
#+begin_example
cd poky
#切换到最新的release
git checkout -b pyro origin/pyro
#初始化编译环境,设置环境变量
#使用此脚本后, 会新建一个 build 文件夹, 并进入这个文件夹, 以后编译的结果都在这个文件夹下.
source oe-init-build-env
#+end_example

注意: =source oe-init-build-env= 命令需要在重启后都执行一次, 否则会提示 =bitbake= 命令找不到!

执行以上步骤后,会在 =build/conf= 文件夹下生成 =local.conf, bblayers.conf= 文件, 可以通过配置这些文件来更改设置.

- 为了能够节约硬盘空间, 可以在 =local.conf= 文件中加入一行:
#+begin_example
INHERIT += "rm_work"
#+end_example
- 默认配置是用于QEMU仿真的32位X86平台, 可以通过修改 =local.conf= 中的 =MACHINE= 变量来修改.
- 默认生成的镜像文件是 RPM 格式, 可以通过修改 =local.conf= 中的 =PACKAGE_CLASSES= 变量改变包格式

**** 开始编译
首次编译需要一定的时间, 因为需要首次下载文件.

*注意:* 首次编译及下载会消耗很多CPU和内存, 所以最好将UI界面退出, 进入命令行界面.否则容易导致 *ubuntu自动重启*.

编译完成后, 下载的文件位于 =build/download= 文件夹下, 可以将其存储于网盘中.
#+begin_example
bitbake core-image-sato
#+end_example

**** 开始仿真
使用 =Ctrl -C= 退出仿真环境.
#+begin_example
runqemu qemux86
#+end_example
**** 为硬件环境生成镜像文件
此示例演示如何编译支持 =MinnowBoard MAX-64bit= 硬件.
**** 拷贝代码
#+begin_example
cd poky
git clone git://git.yoctoproject.org/meta-intel
git checkout pyro
#+end_example
**** 配置
配置编译结果, 需要配置文件 =bblayers.conf, local.conf= , 这两个文件都位于 =build/conf= 文件夹中.
#+begin_example
cd build
#增加层
bitbake-layers "add-layer ../meta-intel"
#指定BSP
echo 'MACHINE = "intel-corei7-64"' >> conf/local.conf
#+end_example
**** 编译
#+begin_example
#编译生成基础命令行版的 linux
bitbake core-image-base
#+end_example
当编译完成后, 生成的文件位于 =tmp/deploy/images/intel-corei7-64/core-image-base-intel-corei7-64.wic=.
**** 载入镜像文件
使用以下命令就可以生成一个可以启动的文件了:
#+begin_example
#TARGET_DEVICE 代表在硬件板上启动文件存放的位置, 比如 /dec/mmcblk0
sudo dd if=tmp/deploy/images/intel-corei7-64/core-image-base-intel-corei7-64.wic of=TARGET_DEVICE
#+end_example
*** 注意事项
**** 从别处拷贝整个工程
由于工程内部很多变量依然保存的是之前工程的配置, 所以需要先 *删除build/tmp/目录下的内容, 重新编译才能正常运行!*
**** 在编译的过程中 ubuntu 自动重启
原因不明.
** 详细说明
*** 准备工作
**** 克隆代码库
在完成了快速准备后, yocto 已经下载了 yocto-source 的 git 库在 =downloads= 文件夹中, 我们需要把它 clone 出来.
#+begin_example
#clone linux代码
git clone ./build/downloads/git2/git.yoctoproject.org.linux-yocto-4.10.git linux-kernel
#clone metadata extras
git clone git://git.yoctoproject.org/meta-yocto-kernel-extras meta-yocto-kernel-extras 
#clone bsp, bsp 命名规则: meta-bsp_name 
git clone git://git.yoctoproject.org/meta-intel.git
#+end_example
**** bmap-tools
=bmap-tools= 工具用于将镜像文件烧写到引导介质(比如 sdcard).

使用之前使用以下命令编译此工具:
#+begin_example
bitbake bmap-tools-native 
#或者也可以简单粗暴
sudo apt install bmap-tools
#+end_example
***** 示例:将 WIC 文件烧写至 flash
- 增加配置信息到文件 =local.conf=
#+begin_example
IMAGE_FSTYPES += "wic wic.bmap"
#+end_example
- 编译对应的镜像文件
#+begin_example
bitbake image
#+end_example
- 烧写
#+begin_example
#如果对介质具有写权限, 则使用以下命令
oe-run-native bmaptool copy ./tmp/deploy/images/qemux86-64/core-image-minimal-machine.wic /dev/sdx
#如果没有写权限则使用如下命令
sudo bash 
PATH=tmp/sysroots/x86_64-linux/usr/bin bmaptool copy ./tmp/deploy/images/qemux86-64/core-image-minimal-machine.wic /dev/sdx
#+end_example
- 寻求帮助
#+begin_example
bmaptool --help
oe-run-native bmaptool --help
#+end_example
*** 概念
yocto 项目通过 =gitolite= 托管, 整体项目基于分层设计, 项目的具体地址: [[http://git.yoctoproject.org/cgit/cgit.cgi][yocto repositories]].

*注意:* 在使用中, 要确保各个库的分支是一一对应的, 比如 poky 的分支为 pyro, 那么 meta-intel 的分支也要切换为 pyro.

在 linux的开发过程中, 分为应用开发和内核开发:
**** 应用开发
- 使用已经编译好的工具链, 使用普通的编辑器和Makefile来构建工程
- 使用 eclipse 并安装 yocto 插件, 使用此IDE来开发APP
**** 内核开发
在内核开发中, 开发者应该不直接修改内核代码, 而是修改顶层文件, 这样便于以后升级内核.
有以下几个方法便于提高开发速度:
1. 通过使用 =Shared State Cache= 来分享自己的编译结果, 这样开发组可以通过网络文件系统来访问,而不是从头编译.
2. 使用 =autobuilders=.
3. 将一些脱机工具压缩打包, 然后分享给其他的开发者.
4. 将工作站分享给开发者, 便于提高编译及测试速度.
5. 使能 =PR Service=.
**** 版本控制
除了要开发的代码, 还需要将 =Metadata= 加入git中.
**** autobuilders
autobuilders 是开发工程的核心工具链.
**** Append Files(附加文件)
此类文件是构建文件(.bb) =recipe file= 的附加文件, 后缀以 =.bbappend= 作为结尾, 此文件用于增改一些构建代码.

一般来说, 一个构建文件都会对应一个同名且不同后缀的附加文件.

附加文件也可以一个文件匹配多个文件.

**** BitBake
在 OpenEmbedded 构建系统中的一个工具, 用于构建镜像文件.此工具执行和调用一些线程来实现并行编译.
**** Build Directory
通过变量 =TOPDIR= 所指定的编译文件夹的位置.一般情况下都是 =poky/build/=.

创建一个编译文件夹使用:
#+begin_example
#在当前目录下创建一个 build 文件夹,设置对应的环境变量,并切换到文件夹下.
source oe-init-build-env (source oe-init-build-env-memres)
#在 home 目录下新建并指定新建文件夹名称为 test-builds
source oe-init-build-env test-builds


#+end_example

**** classes
将通用的逻辑进行封装和继承, 这样用户可以方便重用, 文件的后缀为 =.bbclass=.
**** Configuration File
=.conf= 为后缀的文件, 表明工程的配置信息, 文件中的变量调试全局的. 
- 在 =Build Directory= 中的 conf/local.conf 文件包含用户定义的变量, 影响编译过程.
- =meta-poky/conf/distro/poky.conf= 文件定义了 distro 配置变量, 对应于不同的编译策略.
- 在 =source directory= 中的配置文件, 定义了对应的目标板的配置.(比如 machine/beaglebone.conf)
**** Cross-Development Toolchain
yocto 支持两种不同的工具链:
- 在 BitBake 中运行的工具链用于编译镜像文件
- 在开发应用程序所使用的工具链
**** image
通过 BitBake 所生成的二进制文件.
**** layer
代表BSP, 内核, 以及应用程序的层次结构, 当前在这几个大类中,又由很多小的层次组成.
**** Metadata
用于 BitBake 在编译的过程中的解析文件, 也就是原始文件, 包括 recipes, classes, configuration files.
**** OE-Core
位于 =meta= 文件夹中, 用于 OE 和 yocto 共享的元数据.
**** OpenEmbedded Build System
特别针对于 yocto project 的构建系统.
**** Package 
由 bitbake 编译所生成的二进制包.
**** package groups
一些配置所组合成的一个包,包含了一系列的配置.
**** poky
一个开源项目的名称, poky 是 yocto 项目的基础项目, 所以 clone 下来的目录名称就叫做 poky.
**** recipe
以 =.bb= 后缀结尾,用于编译 packages 的一些设置命令, 调配各个部分之间的协调, 比如在哪里导入代码, 应用哪些补丁, 这些代码如何配置, 如何编译等等. 

也用于描述于其他 recipe 之间的关联,以及库的依赖关系.

**** source directory
一般来说就是指代 =clone= 而来的文件夹 =poky=.
**** task
bitbake 用于执行时的一个单元
**** upstream
远程代码库
*** 提交一次更改

yocto 维护的主分支就是 =master= , 其他普通开发者通过 clone 此库, 然后将满意的更改提交到特定库 =poky-contrib=.

然后由 yocto 的主要维护人员来判断是否合并入 =master= 分支中.

yocto 使用邮件列表和打补丁的方式来合并和讨论更改.

在开发社区, 有两个特殊的分支专用于测试一些提交申请:
- "ross/mut" : mut(master-under-test) 存在于 =poky-contrib= 库.
- "master-next" : 存在于 =poky= 库.
**** 使用 git 时的一些良好的习惯
1. 每完成一个小的改动,并且测试通过后,便可以提交一次.这样便于以后回溯,也更加清晰明了.
2. 要善于利用分支. =master= 分支代表的就是目前产品最新且最为稳定的阶段, 此分支通过很多 =tags= 来表明各个阶段.
*要增加一个新功能或者修复一个bug时,需要新建一个分支.在此分支测试通过后再合并到主分支中去,然后删除此分支.*
3. 在不同功能分支的情况下,如果几个分支都需要更改相同的部分, *那么应该修改它们的共同分支*.
**** 向 poky 提交(How to submit a Change)
poky库是 yocto 项目的参考库, 包含有很多的组件及工具.主要具有以下几大组件用于提交:
- *core metadata* : 当有 =meta= 或 =scripts= 中的内容改变时,需要提交这个分支的[[lists.openembedded.org/mailman/listinfo/openembedded-core][邮件列表]]
- *BitBake* : 当 =bitbake= 下的文件有更新时, 发送到此[[lists.openembedded.org/mailman/listinfo/bitbake-devel][邮件列表]]
- *meta-yocto-bsp" and "meta-poky" tress* : 当 =meta-yocto= 下的文件更新时, 提交补丁到此[[lists.yoctoproject.org/listinfo/poky][邮件列表]]
**** 其他地方的文件修改提交
其他文件,工具,文档的修改都提交到此[[https//lists.yoctoprojects.org/listinfo/yocto][邮件列表]], *当你修改文档的时候,有些文档内部会要求自己的邮件列表, 那么应该使用它所指定的列表*.
**** 提交具体操作
在提交更改之前,需要找到自己做了哪些改动以及修改历史, 使用以下方法来找出这些改动:
- *Maintenance File*: 查看 =meta-poky/conf/distro/include= 文件下的 =maintainers.inc= 文件, 此文件列出了提交者.
- *Search by File*:使用 git 命令来查看更改历史, 比如 =git status / git diff / git shortlog --filename=

在提交的说明中,需要包含 =Signed-off-by:= 一行, 以及 =Developer's Certificate of Origin 1.1= 内容.也就是说, *一定要符合标准格式*.

提交具体格式参考手册对应章节.
**** 使用脚本来提交更改以及请求更新(首选)
- 在保证自己的更改在 git 库的控制范围内
- 加入更改 : git add .
- 提交到本地: git commit , *提交信息要写好*.
- 提交到远端库 : git push 
- 通知维护者,发出合并申请: 在 =scripts= 文件夹下使用脚本 =create-pull-request 和 send-pull-request= , 具体使用方法使用 =-h= 选项查看.
**** 使用 email 提交补丁
- 保证自己的工作在 git 库的控制范围
- 加入更改: git add .
- 提交到本地: *git commit --signoff*
- 转换提交细节到 email 消息中: git format-patch , 这样会生成 .patch 文件.
- 发送邮件: git send-email 

*** 通用开发模型(Common Development Models)
yocto 具有以下几种开发模型:
- *System Development* : 此模型包含 BSP以及内核的修改及配置开发.
- *User Application Development* : 此模型包含 APP 开发
- *Temporary Source Code Modification*: 此模型用于快速测试一些代码. 在测试代码完成后再更新到主分支中.
- *Image Development using Toaster*: 用于定制最终的镜像文件
- *Using a Development Shell*: 使用 shell 来调试组件
**** 系统开发的工作流程(System Development Workflow)
***** 开发BSP
[[./bsp_create_workflow.bmp][bsp开发流程]]
- 确保能够运行 yocto 的主机
- 拷贝 yocto 工程代码
- 拷贝 =meta-intel= 工程代码
- 使用 =yocto-bsp= 脚本来完成BSP层创建
- 配置 BSP 
- 配置 recipe 
- 为编译做准备
- 编译镜像文件
***** 修改内核
****** 内核概览
通过查看 yocto 的代码仓库可以发现有好几个版本的内核:
- *linux-yocto-3.14*: 基于 linux3.14 和 yocto 1.6,1.7 而生成的稳定版工程
- *linux-yocto-3.17*: 基于 linux3.17 和 yocto 1.7 而生成的工程, *目前已经没有维护*.
- *linux-yocto-3.19*: 基于 linux3.19 和 yocto 1.8 而生成的稳定版工程
- *linux-yocto-4.1*: 基于 linux4.1 和 yocto 2.0 而生成的稳定版工程
- *linux-yocto-4.4*: 基于 linux4.4 和 yocto 2.1 而生成的稳定版工程
- *linux-yocto-dev*: 最新的正在开发中的版本

其中, 长期支持的版本有:
- 基于 yocto 1.7,1.8,2.0 的 =linux-yocto-3.14
- 基于 yocto 2.1 的 =linux-yocto-4.1=

[[./kernel_branch.bmp][内核分支维护]]
内核的维护是基于分支的概念, 图中 =Kernel.org Branch Point= 就是原版的linux, 其他的维护分支都是基于此分支的.

=Branch Point= 右边的分支, 都代表对于不同硬件的开发, 每一个端点都是针对性的.但是它们又可以同步相互所公用的代码.

在编译内核的时候, 会将内核代码拷贝到一个临时的工作区来修改, 如下图所示:
[[./temporary.bmp][临时工作区]]
****** 修改内核的流程
[[./kernel_modi_workflow.bmp][内核修改流程]]
- 首次编译来建立临时文件夹, 然后使用 =oe-init-build-env / oe-init-build-env-memres= 来获取环境变量
- 根据需要修改内核代码
- 根据需要更改内核配置
- 再次重新编译内核


**** 使用 SDK 开发 APP 的流程
**** 修改应用代码
在 OpenEmbedded 中还有的工具:
- *devtool* : 
- *Quilt*: 
***** 使用 *devtool*
****** 使用 *devtool add* 来增加一个应用框架
[[./devtool_add.bmp][devtool_add]]
- 生成新的 recipe: 从上图可以看出有3中生成的方式.
  + =devtool add recipe fetchuri= 用于重头新建一个应用框架
  + =devtool add recipe srctree fetchuri= 也是重头新建一个应用框架,但是应用代码不存在默认位置, *srctree* 来指定位置.
  + =devtool add recipe srctree= 用于从外部导入一个应用代码
- 编辑 recipe: =devtool edit-recipe recipe=
- 编译 recipe 并且生成镜像文件: =devtool build recipe= 用于编译 recipe, =devtool build-image image= 用于生成镜像文件,文件中已经包含了 =recipe=.
- 部署编译输出: =devtool deploy-target recipe target= 输出文件到目标硬件(运行 SSH server)
- 完成开发 : =devtool finish recipe layer= 生成相比上次的补丁,并且复位 recipe 以用于别的开发.
****** 使用 *devtool modify* 来编辑代码
[[./devtool_modify.bmp][devtool modify]]
- 准备修改代码: 修改代码也有三种方式
  + =devtool modify recipe= : 与上一节的方式对应, 编辑本文件夹内的源码.
  + =devtool modify recipe srctree= : 指明编辑的文件路径
  + =devtool modify -n recipe srctree= : 指明使用外部代码和外部的 recipe 
- 编辑代码: 经过上面步骤后, 就可以使用任意的编辑器进行修改了.
- 编译: 正常编译即可.
- 部署编译输出: =devtool deploy-target recipe target= (目标板需要运行SSH server)
- 完成开发 : =devtool finish recipe layer= 生成相比上次的补丁,并且复位 recipe 以用于别的开发.

****** 使用 *devtool upgrade* 使用新版本
一般用于第三方软件有更新时, 使用此命令来获得更新的软件.
[[./devtool_upgrade.bmp][devtool upgrade]]
- 准备升级: =devtool upgrade -V version recipe= 默认将新代码提取到 workspace 中, 如果要指定提取路径,使用 =devtool upgrade -V version recipe srctree=.
- 解决冲突: 
- 编译
- 部署输出
- 完成

***** 使用 *Quilt*
quilt 用于捕捉代码的更改.
- 找到并切换到源代码的位置: 位于临时文件夹中
- 创建一个新的补丁: =quilt new my_changes.patch=
- 通知 quilt 将要改变哪些文件: =quilt add file1.c file2.c ...=
- 编辑代码
- 测试本次修改的代码: =bitbake -c compile -f package=,
- 代码测试合格后,需要更新补丁文件: =quilt refresh= ,补丁文件位于当前目录下的 =patches= 文件夹下.
- 拷贝补丁文件: 将补丁放在 =files= 文件夹下, 然后增加文件路径到 =SRC_URI= 变量中: SRC_URI += "file://my_changes.patch"
**** 找到临时源代码
使用临时源码目录, 可以用来测试代码, 在代码测试完毕后再保存此次更改.

临时代码目录对于编译目录是可用的, 路径被存在 =S= 变量中:
#+begin_example
# BP = "${BPN} -${PV}"
S = "${WORKDIR}/${BP}"

#工作目录定位到 recipe
# TMPDIR: 编译输出目录
# MULTIMACH_TARGET_SYS: 目标系统目录
# PN: recipe 的名字
# EXTENDPE: The epoch 
# PV: recipe 版本
# PR: recipe 修订版本
${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}{$PV}-{PR}
#比如
poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0
#+end_example
**** 使用 Toaster 配置镜像文件
**** 使用 development shell
使用 shell 可以很好的调试和配置.
#+begin_example
#使用 devshell 开发和配置 matchbox-desktop 目标
bitbake matchbox-desktop -c devshell
#+end_example
**** 使用 development python shell
#+begin_example
bitbake matchbox-desktop -c devpyshell
#+end_example