#+TITLE: [What]Yocto Project --> BitBake 构建引擎
#+DATE: <2018-09-16 日> 
#+TAGS: yocto
#+LAYOUT: post 
#+CATEGORIES: linux, make, yocto
#+NAME: <linux_bitbake_build_engine.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

参考书籍:Embedded Linux System with the Yocto Project
- 书籍比实际的yocto版本要低，所以yocto的详细命令需要参考其[[https://www.yoctoproject.org/docs/][对应版本手册]]

运行环境:
- ubuntu18.04 amd64
- yocto 2.5.1

BitBake是由纯Python开发的构建工具，其灵活性、可扩展性和可移植性远远强于同类的 make 这类工具。

其metadata构建规则文件就类似于make中的Makefile。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 获取和安装BitBake工具
BitBake的代码位于[[http://git.openembedded.org/bitbake][OpenEmbedded bitbake库]]，并且这是个独立的组件，可以将此工具用于其他工程构建之中。

yocto项目本身就已经包含了BitBake的下载和安装了，所以无需再来下载。

下载及安装的方式也是很简单的:
#+BEGIN_EXAMPLE
  #获取源码
  git clone git://git.openembedded.org/bitbake
  #编译
  ./setup.py build
  #安装于 /usr/lib/python<version>/site-packages
  #也可以不安装，就在当前目录使用
  ./setup.py install
#+END_EXAMPLE
* 运行BitBake
BitBake的启动命名为:
#+BEGIN_EXAMPLE
  #### 在构建环境的目录下执行命名 ###
  #recipe_name 就是 recipe_name.bb 文件
  bitbake <recipe_name / target_name>


  #### 在构建环境的目录外执行命名 ###
  #BBPATH需要是绝对路径!!!
  BBPATH="/absolute/path/to/build_env" bitbake <recipe_name / target_name>
#+END_EXAMPLE
** 配置文件的搜寻
*这个过程我感觉和Kconfig的解析流程好像*

BitBake启动后会在当前目录下搜寻文件 =conf/bblayers.conf= 以获得一个基础构建环境。
- 其中变量 =BBLAYERS= 指明了此次构建所包含的层的路径
- 而在每个层的 =conf/layer.conf= 文件给出了当前层的配置文件路径
  - =BBPATH= 指定了包含 =classes= 和 =conf= 文件夹的路径，多个路径通过冒号分隔
  - =BBFILES= 给出了当前层的具体构建配置文件(recipes files and append files)的路径。
- BitBake会用变量 =LAYERDIR= 来保存层的顶级路径，BitBake便顺藤摸瓜找到各个层的配置文件。
- BitBake在遍历过程中，会根据 =BBFILE_COLLECTIONS=, =BBFILE_PATTERN_<name>= , =BBFILE_PRIORITY_<name>= 来整理配置
  - =BBFILE_COLLECTIONS= 指定一个搜集器，将相同的文件聚集到一起
  - =BBFILE_PATTERN_<name>= 以正则表达式的方式指定BitBake的起始搜寻路径
  - =BBFILE_PRIORITY_<name>= 指定此层配置文件的优先级(1~10,数值越高优先级越高)
    + 当有同名的recipe文件，BitBake使用优先级高的
    + 当有多个append文件，BitBake先应用优先级高的append文件，再应用优先级低的
- BitBake在解析完 =bblayers.conf= 文件后，还会去解析 =conf/bitbake.conf= 文件，以获取编译环境的设置。
** BitBake命令行
BitBake的命令参数很多，下面对它们进行分类整理。
*** 以包含依赖的方式处理构建
BitBake默认的构建任务是由变量 =BB_DEFAULT_TASK= 所指定的 =build= 任务。

=build= 任何在正式启动编译之前会评估好各个软件包之间的依赖和编译顺序。

一般情况下使用的 =bitbake <recipe_name / target_name>= 命令就是启动的 =build= 任务。
- 当出现了错误时，bitbake将停止执行任务，可以使用 =-k= 选项让其继续执行。

当编译软件包时，默认会编译其最新版本或者是由变量 =PREFERRED_VERSION= 指定的版本。
可以在目标名称后加上版本名以指定编译特定版本:
#+BEGIN_EXAMPLE
  bitbake editor-1.0
  bitbake editor-2.0-r3
#+END_EXAMPLE
*** 以不包含依赖的方式处理构建
可以指定只编译某个recipe文件的规则，而不进行依赖编译。
- 当编译出错时则退出
#+BEGIN_EXAMPLE
  bitbake -b <recipe_name>.bb
  bitbake --buildfile=<recipe_name>.bb
#+END_EXAMPLE
*** 执行指定的任务
有以下两种方式:
- 包含依赖的方式执行
#+BEGIN_EXAMPLE
  bitbake <packet> -c <task_name>
  bitbake <packet> --cmd=<task_name>
#+END_EXAMPLE
- 不包含依赖的方式执行
#+BEGIN_EXAMPLE
  bitbake -b <recipe_name>.bb -c <task>
  bitbake -b <recipe_name>.bb --cmd=<task>
#+END_EXAMPLE
*** 强制执行
BitBake会为每个完成的任务打上时间戳，以完成增量编译，用户可以取消此时间戳的判断以强制编译该任务
#+BEGIN_EXAMPLE
  bitbake <packet> -C <task>
  bitbake <packet> --clear-stamp=<task>
  bitbake <packet> -c <task> -f
  bitbake <packet> -c <task> --force
#+END_EXAMPLE
BitBake将任务的输出放在 "shared state cache"中(也就是 =sstate-cache= 文件夹)，当任务输入并没有被改变时，
BitBake直接从 =sstate-cache= 中取出结果，而不需要重新编译。
- 这也是为什么建议将 =sstate-cache= 放在 =build= 之外的目的，多个 =build= 可以共享编译输出，减小编译时间
  
用户可以关闭 =sstate-cache= 的使用:
#+BEGIN_EXAMPLE
  bitbake <packet> -c <task> --no-setscene
#+END_EXAMPLE
*** 显示metadata
当用于调试构建过程时，需要输出BitBake所分析到的元数据文件、变量、功能等等:
#+BEGIN_EXAMPLE
  #显示所有信息
  bitbake -e
  bitbake --environment
  #仅显示关于此 <package>的信息
  bitbake -e <package>
  bitbake --environment <package>
  #显示recipes的版本
  bitbake -s
  bitbake --show-versions
#+END_EXAMPLE
*** 创建依赖图
BitBake基于[[http://kcmetercec.top/categories/editer/graphviz/][graphviz]]表示包之间的依赖图:
#+BEGIN_EXAMPLE
  #生成描述依赖的dot文件
  bitbake -g <package>
  bitbake --graphviz <package>

  #生成描述依赖的dot文件，并忽略某个包
  bitbake -g <package> -I <ignore_package>
#+END_EXAMPLE
最终会在构建目录下生成下面3种DOT语言描述文件:
- task-depends.dot : 描述任务级之间的依赖
- recipe-depends.dot : 包与包之间的依赖

然后使用 =graphviz= 生成图片即可，例如:
#+BEGIN_EXAMPLE
  dot -Tpng -o pn-depends.png pn-depends.dot
#+END_EXAMPLE

**注意：这张图很大，建议使用 tred去掉中间依赖**
#+BEGIN_EXAMPLE
  tred recipe-depends.dot > recipe-depends-notrans.dot
#+END_EXAMPLE

也可以使用BitBake所自带的依赖描述工具:
#+BEGIN_EXAMPLE
  bitbake -g -u taskexp <package>
#+END_EXAMPLE

*** 配置的设置和覆盖
用户可以在BitBake解析其他文件前后加入附加的配置文件:
- 在解析其他文件前加入配置文件，一般用于设置环境变量
#+BEGIN_EXAMPLE
  bitbake -r <prefile>.conf <target>
  bitbake --read <prefile>.conf <target>
#+END_EXAMPLE
- 在解析其他文件后加入配置文件，一般用于覆盖前面配置文件的设置
#+BEGIN_EXAMPLE
  bitbake -R <postfile>.conf <target>
  bitbake --postread <postfile>.conf <target>
#+END_EXAMPLE
*** 服务器
BitBake是一个典型的CS架构下的应用程序，每次启动BitBake时它都会启动一个服务端程序(叫做 =cooker= )，
和一个客户端程序。

服务器会启动多个线程分析元文件，并进行编译。服务器和客户端使用pipe来交互信息。

当然，这种架构完全可以用于远程编译：小组里几个人共用一个强大的服务器，将自己客户端的代码放在服务器编译后取得结果。

- 在服务器上启动BitBake服务端程序:
#+BEGIN_EXAMPLE
  bitbake --server-only --bind=<ip>:<port>
#+END_EXAMPLE
- 客户端连接 BitBake服务器构建:
#+BEGIN_EXAMPLE
  bitbake --remote-server=<ip>:<port> <target>
#+END_EXAMPLE
* BitBake元数据
BitBake通过分析元数据来控制构建过程，元数据来描述软件包该如何构建以及它的依赖关系。

BitBake将分析后的元文件放在一个缓存文件夹中，避免下次重复分析而浪费不需要的时间。

BitBake分析以下两类元数据:
- 变量(Variables)： 包括控制整体的全局变量，以及控制一小部分的局部变量
- 可执行元数据(Executable Metadata)：在recipes和classes中嵌入的功能和命令

元数据文件由以下5种文件组成：
- 配置文件(.conf):配置文件中的变量都是全局变量，所以它们会影响全局。
  - 如果多个配置文件中有多个相同的变量，那么使用优先级最高的那个。
    + =bitbake.conf= 优先级最低，而构建目录下的 =local.conf= 优先级最高
- recipe文件(.bb):recipe文件用于描述软件包以及该如何构建此软件包
  - 对包的操作命令通常有:下载、解压缩、打补丁、编译、打包、安装
- class文件(.bbclass):类文件主要包含很多recipe文件所共有的设置，以便它们继承。
  - BitBake会搜寻当前层下的 =classes= 子文件以获取类文件
  - recipe中使用 =inherit= 指令来继承类文件
    + 类文件是全局的，所以recipe可以在任何位置继承
- append 文件(.bbappend) : 附加文件是对recipe文件的扩展，附加文件的前缀名称必须与recipe文件一致
  - append文件中包含的层路径也要与recipe文件一致
  - 当不同层中有一样的append文件时，由层的优先级来决定使用哪一个
- include 文件(.inc): 每中元数据文件都可以使用 =include=, =require= 指令包含其他文件,include文件表示其他元文件所共同包含的元文件
  - 包含执行指令的元文件只能被 recipes,append,classes文件包含
* 元数据的语法
元数据的语法类似 Makefile和shell 脚本。
** 注释
使用 =#= 作为注释开头， **但注释分为普通注释和功能函数注释**
- 普通注释(在函数之外)的 =#= 必须在 **行的第一列** 才符合语法规则
- 元文件中可以包含 shell 和 python 功能函数，在函数内部的注释就比较随意了。
** 变量
元数据中的变量对于BitBake来说都是字符串。
*** 变量名
变量名中可以包含:大小写字母、数字、下划线(_)、横线(-)、点(.)、加号(+)、波浪线(~)

为了与Makefile和shell保持一致的习惯，一般还是使用大写字母和下划线的形式来组成变量名。
*** 变量的作用域
