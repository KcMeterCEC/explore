#+TITLE: [What]pthread_create failed -> Try again
#+DATE:  <2018-03-20 Tue> 
#+TAGS: debug
#+LAYOUT: post 
#+CATEGORIES: linux, debug, issues
#+NAME: <linux_debug_issue_pthread_create.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

在嵌入式Linux下编写应用程序，使用 =pthread_create()= 来反复创建线程失败，返回错误11(Try again).
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 问题描述
为了处理一个耗时稍微长一点的任务，但同时不能阻塞主线程，所以我为这个任务新建一个线程来处理事物。
[[./issue_pthread_create_try_again.jpg]]

当主接线新建的任务次数过多的时候，就会创建失败，此时 =pthread_create()= 返回错误11(Try again).
* 分析
为了能够明确的查看线程为何创建失败，需要查看文件 =/proc/<process_id>/status= 来看看是不是线程创建的过多而导致无法再次新建。

执行流程为：当主线程每新建一个任务后便输出 =status= 文件状态。

实际观察发现 =Threads:= 条目并没有因为调用次数的增加而增加，反而是 =VmPeak,VmSize, VmData= 每次增加得特别多。

看来是有必要再来明确一下这几个概念了:
- VmPeak: 虚拟内存使用峰值
- VmSize: 当前内存使用量
- VmData: 数据段的大小

由上可以知道，导致 =pthread_create()= 失败的原因并不是因为这个函数本身造成的，
而是在这个处理的过程中所导致内存使用量不断增大而导致的内存泄漏。

所以我应该来梳理整个流程，逐个排出是那个部分造成的内存泄漏。

