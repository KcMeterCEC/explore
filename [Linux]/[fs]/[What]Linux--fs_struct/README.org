#+TITLE: [What]Linux文件系统基本脉络
#+DATE:  <2018-04-29 Sun> 
#+TAGS: filesystem
#+LAYOUT: post 
#+CATEGORIES: linux, fs, struct
#+NAME: <linux_fs_struct_base.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

记录从上层用户操作到底层文件系统之间的调用流程以及数据流。
[[./vfs_fileoperations.jpg]]
#+BEGIN_HTML
<!--more-->
#+END_HTML
* simplefs 实战
[[https://github.com/psankar/simplefs][simplefs]] 用最少的代码实现了文件系统的基本操作。
** 基本体验
*** 创建一个硬盘
目前使用 =dd= 命令创建一个块大小为 4096字节，共100个块的硬盘文件。
#+begin_example
dd bs=4096 count=100 if=/dev/zero of=image
#+end_example
*** 格式化并挂载
#+begin_example
make 
./mkfs-simplefs image
mkdir mount
sudo insmod simplefs.ko ; mount -o loop -t simplefs image ./mount
#+end_example
*** 查看内容
接下来就是以root的身份进入到 =mount= 文件夹，便可以查看其文件及文件内容。
** 格式化代码分析(mkfs-simplefs.c)
其格式化的步骤为：
1. 写入superblock 的内容
2. 写根目录inode
3. 写文件inode
4. 写根目录block
5. 写文件block
*** 写 superblock
此函数将一个block来保存superblock的信息。
#+BEGIN_SRC c
#define SIMPLEFS_MAGIC 0x10032013
#define SIMPLEFS_DEFAULT_BLOCK_SIZE 4096
struct simplefs_super_block {
        uint64_t version; //版本号
        uint64_t magic; //魔数
        uint64_t block_size;//super block 信息所占用的块大小

        /* FIXME: This should be moved to the inode store and not part of the sb */
        uint64_t inodes_count;//目前已经使用了多少个inode

        uint64_t free_blocks;//目前还剩下多少个block

        //此部分是为了填充结构体，使整个结构体大小为4096字节
        char padding[SIMPLEFS_DEFAULT_BLOCK_SIZE - (5 * sizeof(uint64_t))];
};
static int write_superblock(int fd)
{
        struct simplefs_super_block sb = {
                .version = 1,
                .magic = SIMPLEFS_MAGIC,
                .block_size = SIMPLEFS_DEFAULT_BLOCK_SIZE,
                /* One inode for rootdirectory and another for a welcome file that we are going to create */
                .inodes_count = 2,//使用一个inode对应根目录，一个inode对应一个文件
                /* FIXME: Free blocks management is not implemented yet */
                .free_blocks = (~0) & ~(1 << WELCOMEFILE_DATABLOCK_NUMBER),
        };
        ssize_t ret;

        ret = write(fd, &sb, sizeof(sb));
        if (ret != SIMPLEFS_DEFAULT_BLOCK_SIZE) {
                printf
                        ("bytes written [%d] are not equal to the default block size\n",
                         (int)ret);
                return -1;
        }

        printf("Super block written succesfully\n");
        return 0;
}
#+END_SRC
*** 写根文件inode
根文件的inode紧接着superblock 往后填充，也就是在第2个block中存储inode.
#+BEGIN_SRC c
struct simplefs_inode {
        mode_t mode; //此inode表示的档案类型
        uint64_t inode_no;//inode的索引号
        uint64_t data_block_number;//与inode对应的block的索引号

        union {//文件大小或是目录对应的内容对
                uint64_t file_size;
                uint64_t dir_children_count;
        };
};
const int SIMPLEFS_ROOTDIR_INODE_NUMBER = 1;
const int SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER = 2;
const int SIMPLEFS_INODESTORE_BLOCK_NUMBER = 1;
static int write_inode_store(int fd)
{
        ssize_t ret;

        struct simplefs_inode root_inode;

        root_inode.mode = S_IFDIR;
        root_inode.inode_no = SIMPLEFS_ROOTDIR_INODE_NUMBER;
        root_inode.data_block_number = SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER;
        root_inode.dir_children_count = 1;

        ret = write(fd, &root_inode, sizeof(root_inode));

        if (ret != sizeof(root_inode)) {
                printf
                        ("The inode store was not written properly. Retry your mkfs\n");
                return -1;
        }

        printf("root directory inode written succesfully\n");
        return 0;
}
#+END_SRC
*** 写文件inode
通过此函数可以看出：所有的inode都存储在一个block中，而一个inode大小为 =28= 字节。
也就是说，此文件系统最多支持文件和文件夹的总数为 4096 / 28 = 146 
#+BEGIN_SRC c
#define SIMPLEFS_DEFAULT_BLOCK_SIZE 4096
const uint64_t WELCOMEFILE_INODE_NUMBER = 2;//文件inode为2号
const uint64_t WELCOMEFILE_DATABLOCK_NUMBER = 3;//文件内容block
char welcomefile_body[] = "Love is God. God is Love. Anbe Murugan.\n";
struct simplefs_inode welcome = {
        .mode = S_IFREG,
        .inode_no = WELCOMEFILE_INODE_NUMBER,
        .data_block_number = WELCOMEFILE_DATABLOCK_NUMBER,
        .file_size = sizeof(welcomefile_body),
};
static int write_inode(int fd, const struct simplefs_inode *i)
{
        off_t nbytes;
        ssize_t ret;

        ret = write(fd, i, sizeof(*i));
        if (ret != sizeof(*i)) {
                printf
                        ("The welcomefile inode was not written properly. Retry your mkfs\n");
                return -1;
        }
        printf("welcomefile inode written succesfully\n");

        //算出需要移动到block尾需要多少字节(依次减去root inode 和 welcome inode)
        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - sizeof(*i) - sizeof(*i);
        ret = lseek(fd, nbytes, SEEK_CUR);
        if (ret == (off_t)-1) {
                printf
                        ("The padding bytes are not written properly. Retry your mkfs\n");
                return -1;
        }

        printf
                ("inode store padding bytes (after the two inodes) written sucessfully\n");
        return 0;
}
#+END_SRC
*** 写根目录block
写根目录block就是写文件名以及其inode的索引,一个名称对的大小为 264 字节，
也就是说一个目录最多可以存储的名称对为 4096 / 264 = 15 个，也就是说一个目录
最多存储15个文件或目录名。
#+BEGIN_SRC c
#define SIMPLEFS_FILENAME_MAXLEN 255 //文件名的最大长度
struct simplefs_dir_record {
        char filename[SIMPLEFS_FILENAME_MAXLEN];
        uint64_t inode_no;//文件名以及其对应的block索引
};
struct simplefs_dir_record record = {
        .filename = "vanakkam",
        .inode_no = WELCOMEFILE_INODE_NUMBER,
};
int write_dirent(int fd, const struct simplefs_dir_record *record)
{
        ssize_t nbytes = sizeof(*record), ret;

        ret = write(fd, record, nbytes);
        if (ret != nbytes) {
                printf
                        ("Writing the rootdirectory datablock (name+inode_no pair for welcomefile) has failed\n");
                return -1;
        }
        printf
                ("root directory datablocks (name+inode_no pair for welcomefile) written succesfully\n");

        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - sizeof(*record);
        ret = lseek(fd, nbytes, SEEK_CUR);//移动到下一个block
        if (ret == (off_t)-1) {
                printf
                        ("Writing the padding for rootdirectory children datablock has failed\n");
                return -1;
        }
        printf
                ("padding after the rootdirectory children written succesfully\n");
        return 0;
}
#+END_SRC
*** 写文件block 
写文件block就是把文件内容写进去即可。
#+BEGIN_SRC c
int write_block(int fd, char *block, size_t len)
{
        ssize_t ret;

        ret = write(fd, block, len);
        if (ret != len) {
                printf("Writing file body has failed\n");
                return -1;
        }
        printf("block has been written succesfully\n");
        return 0;
}
#+END_SRC
** 文件系统的结构
根据上面的格式化代码，可以知道其结构如下图：
[[./simplefs_struct.jpg]]

可以看出此文件系统的确是足够的简单：
1. superblock描述极为简单
2. 并不具备block bitmap 和 inode bitmap
3. 最多支持的文件和文件夹总数为146个(因为仅用了一个block来存储inode)
4. 一个文件夹中可以存储的文件和文件夹总数为15个
5. 一个文件的内容不能超过一个block

*** 文件系统操作逻辑
根据以上简单结构的分析，可以猜测出其基本的文件操作逻辑：
1. 新建文件夹
  + 从inode table 中填充一个文件夹类型的inode并获取其索引
  + 为此索引的inode分配一个block并写入对应的inode
  + 将新建文件夹的名称和inode索引对应存储在当前文件夹的block中
  + 更新 superblock 中的inode计数
2. 新建文件
  + 从inode table 中填充一个文件类型的inode并获取其索引
  + 为此索引的inode分配一个block并写入对应的inode
  + 将文件内容写入其block中
  + 将新建文件的名称和inode索引对应存储在当前文件夹的block中
  + 更新 superblock 中的inode计数
3. 删除文件或文件夹
  + 去除当前文件夹中对应此文件或文件夹的描述字符串
  + 更新 superblock 中的inode计数
4. 建立硬链接
  + 在当前文件夹下拷贝一份目标文件所在的文件夹中对于此文件的描述字符串
5. 建立符号链接
  + 首先新建一个文件
  + 然后新建文件的内容指向目标文件所在的文件夹的inode

基于这些猜测，接下来分析其文件系统操作代码。

** 操作代码分析(simple.c)
*** 挂载
在载入模块时，会首先使用函数 =kmem_cache_create= ，用于为文件系统的inode申请缓存以便达到快速访问的目的。
#+BEGIN_SRC c
sfs_inode_cachep = kmem_cache_create("sfs_inode_cache",
                                     sizeof(struct simplefs_inode),
                                     0,
                                     (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD),
                                     NULL);
#+END_SRC
在挂载文件时，会调用函数 =simplefs_fill_super= 函数，此函数的主要目的就是填充 =super_block= 结构体
#+BEGIN_SRC c
/* This function, as the name implies, Makes the super_block valid and
 ,* fills filesystem specific information in the super block */
int simplefs_fill_super(struct super_block *sb, void *data, int silent)
{
        struct inode *root_inode;
        struct buffer_head *bh;
        struct simplefs_super_block *sb_disk;
        int ret = -EPERM;

        //从存储super block 描述的block(0)中读取数据
        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);
        BUG_ON(!bh);

        //得到 simplefs_super_block 具体内容
        sb_disk = (struct simplefs_super_block *)bh->b_data;

        printk(KERN_INFO "The magic number obtained in disk is: [%llu]\n",
               sb_disk->magic);

        if (unlikely(sb_disk->magic != SIMPLEFS_MAGIC)) {
                printk(KERN_ERR
                       "The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.");
                goto release;
        }

        if (unlikely(sb_disk->block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) {
                printk(KERN_ERR
                       "simplefs seem to be formatted using a non-standard block size.");
                goto release;
        }

        printk(KERN_INFO
               "simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\n",
               sb_disk->version, sb_disk->block_size);

        /* A magic number that uniquely identifies our filesystem type */
        sb->s_magic = SIMPLEFS_MAGIC;

        /* For all practical purposes, we will be using this s_fs_info as the super block */
        //设为私有地址，以便后面使用
        sb->s_fs_info = sb_disk;

        //最大的文件大小就是为一个block
        sb->s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;
        //super block 操作
        sb->s_op = &simplefs_sops;

        root_inode = new_inode(sb);
        //跟目录的inode位置
        root_inode->i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;
        inode_init_owner(root_inode, NULL, S_IFDIR);
        root_inode->i_sb = sb;
        //inode操作
        root_inode->i_op = &simplefs_inode_ops;
        //文件操作
        root_inode->i_fop = &simplefs_dir_operations;
        root_inode->i_atime = root_inode->i_mtime = root_inode->i_ctime =
                CURRENT_TIME;

        //得到根目录的inode内容(并且会将此inode放入inode cache 中)
        root_inode->i_private =
                simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);

        /* TODO: move such stuff into separate header. */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
        sb->s_root = d_make_root(root_inode);
        #else
        sb->s_root = d_alloc_root(root_inode);
        if (!sb->s_root)
                iput(root_inode);
        #endif

        if (!sb->s_root) {
                ret = -ENOMEM;
                goto release;
        }

        ret = 0;
release:
        brelse(bh);

        return ret;
}
#+END_SRC

其数据填充结果如下图：
[[./struct_super_block.jpg]]

在 =super.h= 中有以下两个操作,对照上图就可以看出其意义：
#+BEGIN_SRC c
//获取 simplefs_super_block 结构体地址
static inline struct simplefs_super_block *SIMPLEFS_SB(struct super_block *sb)
{
        return sb->s_fs_info;
}

//获取根目录 inode的地址
static inline struct simplefs_inode *SIMPLEFS_INODE(struct inode *inode)
{
        return inode->i_private;
}
#+END_SRC
*** 读取文件夹内容
当在 =mount= 文件夹下使用命令 =ls= 时，其执行路径依次为：
- simplefs_iterate 
- simplefs_lookup
- simplefs_get_inode
- simplefs_iterate

* 比较重要的数据结构
#+BEGIN_SRC c
/**
 ,* @brief 文件系统总览
 ,*/
struct file_system_type {
        const char *name;
        int fs_flags;
#define FS_REQUIRES_DEV1
#define FS_BINARY_MOUNTDATA2
#define FS_HAS_SUBTYPE4
#define FS_USERNS_MOUNT8/* Can be mounted by userns root */
#define FS_USERNS_DEV_MOUNT16 /* A userns mount does not imply MNT_NODEV */
#define FS_USERNS_VISIBLE32/* FS must already be visible */
#define FS_RENAME_DOES_D_MOVE32768/* FS will handle d_move() during rename() internally. */
        struct dentry *(*mount) (struct file_system_type *, int,
                                 const char *, void *);
        void (*kill_sb) (struct super_block *);
        struct module *owner;
        struct file_system_type * next;
        struct hlist_head fs_supers;

        struct lock_class_key s_lock_key;
        struct lock_class_key s_umount_key;
        struct lock_class_key s_vfs_rename_key;
        struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];

        struct lock_class_key i_lock_key;
        struct lock_class_key i_mutex_key;
        struct lock_class_key i_mutex_dir_key;
};
/**
 ,* @brief super block 信息及操作结构体
 ,*/
struct super_block {
        struct list_heads_list;/* Keep this first */
        dev_ts_dev;/* search index; _not_ kdev_t */
        unsigned chars_blocksize_bits;
        unsigned longs_blocksize;
        loff_ts_maxbytes;/* Max file size */
        struct file_system_type*s_type;
        const struct super_operations*s_op;
        const struct dquot_operations*dq_op;
        const struct quotactl_ops*s_qcop;
        const struct export_operations *s_export_op;
        unsigned longs_flags;
        unsigned longs_iflags;/* internal SB_I_* flags */
        unsigned longs_magic;
        struct dentry*s_root;
        struct rw_semaphores_umount;
        ints_count;
        atomic_ts_active;
        #ifdef CONFIG_SECURITY
        void                    *s_security;
        #endif
        const struct xattr_handler **s_xattr;

        struct hlist_bl_heads_anon;/* anonymous dentries for (nfs) exporting */
        struct list_heads_mounts;/* list of mounts; _not_ for fs use */
        struct block_device*s_bdev;
        struct backing_dev_info *s_bdi;
        struct mtd_info*s_mtd;
        struct hlist_nodes_instances;
        unsigned ints_quota_types;/* Bitmask of supported quota types */
        struct quota_infos_dquot;/* Diskquota specific options */

        struct sb_writerss_writers;

        char s_id[32];/* Informational name */
        u8 s_uuid[16];/* UUID */

        void *s_fs_info;/* Filesystem private info */
        unsigned ints_max_links;
        fmode_ts_mode;

        /* Granularity of c/m/atime in ns.
           Cannot be worse than a second */
        u32   s_time_gran;

        /*
         ,* The next field is for VFS *only*. No filesystems have any business
         ,* even looking at it. You had been warned.
         ,*/
        struct mutex s_vfs_rename_mutex;/* Kludge */

        /*
         ,* Filesystem subtype.  If non-empty the filesystem type field
         ,* in /proc/mounts will be "type.subtype"
         ,*/
        char *s_subtype;

        /*
         ,* Saved mount options for lazy filesystems using
         ,* generic_show_options()
         ,*/
        char __rcu *s_options;
        const struct dentry_operations *s_d_op; /* default d_op for dentries */

        /*
         ,* Saved pool identifier for cleancache (-1 means none)
         ,*/
        int cleancache_poolid;

        struct shrinker s_shrink;/* per-sb shrinker handle */

        /* Number of inodes with nlink == 0 but still referenced */
        atomic_long_t s_remove_count;

        /* Being remounted read-only */
        int s_readonly_remount;

        /* AIO completions deferred from interrupt context */
        struct workqueue_struct *s_dio_done_wq;
        struct hlist_head s_pins;

        /*
         ,* Keep the lru lists last in the structure so they always sit on their
         ,* own individual cachelines.
         ,*/
        struct list_lrus_dentry_lru ____cacheline_aligned_in_smp;
        struct list_lrus_inode_lru ____cacheline_aligned_in_smp;
        struct rcu_headrcu;
        struct work_structdestroy_work;

        struct mutexs_sync_lock;/* sync serialisation lock */

        /*
         ,* Indicates how deep in a filesystem stack this SB is
         ,*/
        int s_stack_depth;

        /* s_inode_list_lock protects s_inodes */
        spinlock_ts_inode_list_lock ____cacheline_aligned_in_smp;
        struct list_heads_inodes;/* all inodes */
};

/*
 ,* Keep mostly read-only and often accessed (especially for
 ,* the RCU path lookup and 'stat' data) fields at the beginning
 ,* of the 'struct inode'
 ,*/
struct inode {
        umode_t                i_mode;
        unsigned               shorti_opflags;
        kuid_t                 i_uid;
        kgid_t                 i_gid;
        unsigned int           i_flags;

        #ifdef CONFIG_FS_POSIX_ACL
        struct posix_acl       *i_acl;
        struct posix_acl       *i_default_acl;
        #endif

        const struct inode_operations  *i_op;
        struct super_block             *i_sb;
        struct address_space           *i_mapping;

        #ifdef CONFIG_SECURITY
        void                           *i_security;
        #endif

        /* Stat data, not accessed from path walking */
        unsigned long                  i_ino;
        /*
         ,* Filesystems may only read i_nlink directly.  They shall use the
         ,* following functions for modification:
         ,*
         ,*    (set|clear|inc|drop)_nlink
         ,*    inode_(inc|dec)_link_count
         ,*/
        union {
                const unsigned int i_nlink;
                unsigned int __i_nlink;
        };
        dev_t                  i_rdev;
        loff_t                 i_size;
        struct timespec        i_atime;
        struct timespec        i_mtime;
        struct timespec        i_ctime;
        spinlock_ti_lock;/* i_blocks, i_bytes, maybe i_size */
        unsigned short         i_bytes;
        unsigned int           i_blkbits;
        blkcnt_t               i_blocks;

        #ifdef __NEED_I_SIZE_ORDERED
        seqcount_t             i_size_seqcount;
        #endif

        /* Misc */
        unsigned long          i_state;
        struct mutex           i_mutex;

        unsigned long          dirtied_when;/* jiffies of first dirtying */
        unsigned long          dirtied_time_when;

        struct hlist_node      i_hash;
        struct list_head       i_io_list;/* backing dev IO list */
        #ifdef CONFIG_CGROUP_WRITEBACK
        struct bdi_writeback   *i_wb;/* the associated cgroup wb */

        /* foreign inode detection, see wbc_detach_inode() */
        int                     i_wb_frn_winner;
        u16                     i_wb_frn_avg_time;
        u16                     i_wb_frn_history;
        #endif
        struct list_head        i_lru;/* inode LRU list */
        struct list_head        i_sb_list;
        union {
                struct hlist_head  i_dentry;
                struct rcu_head    i_rcu;
        };
        u64                        i_version;
        atomic_t                   i_count;
        atomic_t                   i_dio_count;
        atomic_t                   i_writecount;
        #ifdef CONFIG_IMA
        atomic_t                   i_readcount; /* struct files open RO */
        #endif
        const struct file_operations   *i_fop;/* former ->i_op->default_file_ops */
        struct file_lock_context       *i_flctx;
        struct address_space           i_data;
        struct list_head               i_devices;
        union {
                struct pipe_inode_info *i_pipe;
                struct block_device    *i_bdev;
                struct cdev            *i_cdev;
                char                   *i_link;
        };

        __u32                          i_generation;

        #ifdef CONFIG_FSNOTIFY
        __u32                          i_fsnotify_mask; /* all events this inode cares about */
        struct hlist_head              i_fsnotify_marks;
        #endif

        void                           *i_private; /* fs or device private pointer */
};
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        const char * (*follow_link) (struct dentry *, void **);
        int (*permission) (struct inode *, int);
        struct posix_acl * (*get_acl)(struct inode *, int);

        int (*readlink) (struct dentry *, char __user *,int);
        void (*put_link) (struct inode *, void *);

        int (*create) (struct inode *,struct dentry *, umode_t, bool);
        int (*link) (struct dentry *,struct inode *,struct dentry *);
        int (*unlink) (struct inode *,struct dentry *);
        int (*symlink) (struct inode *,struct dentry *,const char *);
        int (*mkdir) (struct inode *,struct dentry *,umode_t);
        int (*rmdir) (struct inode *,struct dentry *);
        int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
        int (*rename) (struct inode *, struct dentry *,
                       struct inode *, struct dentry *);
        int (*rename2) (struct inode *, struct dentry *,
                        struct inode *, struct dentry *, unsigned int);
        int (*setattr) (struct dentry *, struct iattr *);
        int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
        int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
        ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
        ssize_t (*listxattr) (struct dentry *, char *, size_t);
        int (*removexattr) (struct dentry *, const char *);
        int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
                      u64 len);
        int (*update_time)(struct inode *, struct timespec *, int);
        int (*atomic_open)(struct inode *, struct dentry *,
                           struct file *, unsigned open_flag,
                           umode_t create_mode, int *opened);
        int (*tmpfile) (struct inode *, struct dentry *, umode_t);
        int (*set_acl)(struct inode *, struct posix_acl *, int);
} ____cacheline_aligned;

/**
 ,* @brief 代表的是一个路径
 ,*/
struct dentry {
        /* RCU lookup touched fields */
        unsigned int d_flags;/* protected by d_lock */
        seqcount_t d_seq;/* per dentry seqlock */
        struct hlist_bl_node d_hash;/* lookup hash list */
        struct dentry *d_parent;/* parent directory */
        struct qstr d_name;
        struct inode *d_inode;/* Where the name belongs to - NULL is
                               ,* negative */
        unsigned char d_iname[DNAME_INLINE_LEN];/* small names */

        /* Ref lookup also touches following */
        struct lockref d_lockref;/* per-dentry lock and refcount */
        const struct dentry_operations *d_op;
        struct super_block *d_sb;/* The root of the dentry tree */
        unsigned long d_time;/* used by d_revalidate */
        void *d_fsdata;/* fs-specific data */

        struct list_head d_lru;/* LRU list */
        struct list_head d_child;/* child of parent list */
        struct list_head d_subdirs;/* our children */
        /*
         ,* d_alias and d_rcu can share memory
         ,*/
        union {
                struct hlist_node d_alias;/* inode alias list */
                struct rcu_head d_rcu;
        } d_u;
};
/**
 ,* @brief 代表一个文件的引用（一个文件可以被打开多次就有多个引用，但inode却是仅有一个）
 ,*/
struct file {
        union {
                struct llist_node     fu_llist;
                struct rcu_head       fu_rcuhead;
        } f_u;
        struct path                   f_path;
        struct inode                  *f_inode;/* cached value */
        const struct file_operations  *f_op;

        /*
         ,* Protects f_ep_links, f_flags.
         ,* Must not be taken from IRQ context.
         ,*/
        spinlock_t                    f_lock;
        atomic_long_t                 f_count;
        unsigned int                  f_flags;
        fmode_t                       f_mode;
        struct mutex                  f_pos_lock;
        loff_t                        f_pos;
        struct fown_struct            f_owner;
        const struct cred             *f_cred;
        struct file_ra_state          f_ra;

        u64                           f_version;
        #ifdef CONFIG_SECURITY
        void                          *f_security;
        #endif
        /* needed for tty driver, and maybe others */
        void                          *private_data;

        #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct list_head              f_ep_links;
        struct list_head              f_tfile_llink;
#endif /* #ifdef CONFIG_EPOLL */
        struct address_space          *f_mapping;
} __attribute__((aligned(4)));/* lest something weird decides that 2 is OK */
#+END_SRC

inode Tab 存在于硬盘中，如果每次CPU从硬盘中读取那么效率会比较低下，
所以内核会为inode Table 申请一段内存以作为缓存，称为 *对应文件系统的 inode cache*.
#+BEGIN_SRC c
static int __init init_inodecache(void)
{
        ext4_inode_cachep = kmem_cache_create("ext4_inode_cache",
                                              sizeof(struct ext4_inode_info),
                                              0, (SLAB_RECLAIM_ACCOUNT|
                                                  SLAB_MEM_SPREAD),
                                              init_once);
        if (ext4_inode_cachep == NULL)
                return -ENOMEM;
        return 0;
}
#+END_SRC

同样在VFS层面上，也会对抽象出来的 inode 和 路径进行缓存(dentry), 分别称为 icache 和 dcache.
#+BEGIN_SRC c
static void __init dcache_init(void)
{
        unsigned int loop;

        /*
         ,* A constructor could be added for stable state like the lists,
         ,* but it is probably not worth it because of the cache nature
         ,* of the dcache.
         ,*/
        dentry_cache = KMEM_CACHE(dentry,
                                  SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD);

        /* Hash may have been set up in dcache_init_early */
        if (!hashdist)
                return;

        dentry_hashtable =
                alloc_large_system_hash("Dentry cache",
                                        sizeof(struct hlist_bl_head),
                                        dhash_entries,
                                        13,
                                        0,
                                        &d_hash_shift,
                                        &d_hash_mask,
                                        0,
                                        0);

        for (loop = 0; loop < (1U << d_hash_shift); loop++)
                INIT_HLIST_BL_HEAD(dentry_hashtable + loop);
}
void __init inode_init(void)
{
        unsigned int loop;

        /* inode slab cache */
        inode_cachep = kmem_cache_create("inode_cache",
                                         sizeof(struct inode),
                                         0,
                                         (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|
                                          SLAB_MEM_SPREAD),
                                         init_once);

        /* Hash may have been set up in inode_init_early */
        if (!hashdist)
                return;

        inode_hashtable =
                alloc_large_system_hash("Inode-cache",
                                        sizeof(struct hlist_head),
                                        ihash_entries,
                                        14,
                                        0,
                                        &i_hash_shift,
                                        &i_hash_mask,
                                        0,
                                        0);

        for (loop = 0; loop < (1U << i_hash_shift); loop++)
                INIT_HLIST_HEAD(&inode_hashtable[loop]);
}
#+END_SRC
最终这些申请的缓存都是内核通过LRU算法进行回收的(内核通过 shrink方法来回收slab内存)
- shrink 方法需要驱动编写者来主动实现
