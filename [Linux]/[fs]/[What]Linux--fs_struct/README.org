#+TITLE: [What]Linuxæ–‡ä»¶ç³»ç»ŸåŸºæœ¬è„‰ç»œ
#+DATE:  <2018-04-29 Sun> 
#+TAGS: filesystem
#+LAYOUT: post 
#+CATEGORIES: linux, fs, struct
#+NAME: <linux_fs_struct_base.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

è®°å½•ä»ä¸Šå±‚ç”¨æˆ·æ“ä½œåˆ°åº•å±‚æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„è°ƒç”¨æµç¨‹ä»¥åŠæ•°æ®æµã€‚
[[./vfs_fileoperations.jpg]]
#+BEGIN_HTML
<!--more-->
#+END_HTML
* simplefs å®æˆ˜
[[https://github.com/psankar/simplefs][simplefs]] ç”¨æœ€å°‘çš„ä»£ç å®ç°äº†æ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬æ“ä½œã€‚
** åŸºæœ¬ä½“éªŒ
*** åˆ›å»ºä¸€ä¸ªç¡¬ç›˜
ç›®å‰ä½¿ç”¨ =dd= å‘½ä»¤åˆ›å»ºä¸€ä¸ªå—å¤§å°ä¸º 4096å­—èŠ‚ï¼Œå…±100ä¸ªå—çš„ç¡¬ç›˜æ–‡ä»¶ã€‚
#+begin_example
dd bs=4096 count=100 if=/dev/zero of=image
#+end_example
*** æ ¼å¼åŒ–å¹¶æŒ‚è½½
#+begin_example
make 
./mkfs-simplefs image
mkdir mount
sudo insmod simplefs.ko ; mount -o loop -t simplefs image ./mount
#+end_example
*** æŸ¥çœ‹å†…å®¹
æ¥ä¸‹æ¥å°±æ˜¯ä»¥rootçš„èº«ä»½è¿›å…¥åˆ° =mount= æ–‡ä»¶å¤¹ï¼Œä¾¿å¯ä»¥æŸ¥çœ‹å…¶æ–‡ä»¶åŠæ–‡ä»¶å†…å®¹ã€‚
** æ ¼å¼åŒ–ä»£ç åˆ†æ(mkfs-simplefs.c)
å…¶æ ¼å¼åŒ–çš„æ­¥éª¤ä¸ºï¼š
1. å†™å…¥superblock çš„å†…å®¹
2. å†™æ ¹ç›®å½•inode
3. å†™æ–‡ä»¶inode
4. å†™æ ¹ç›®å½•block
5. å†™æ–‡ä»¶block
*** å†™ superblock
æ­¤å‡½æ•°å°†ä¸€ä¸ªblockæ¥ä¿å­˜superblockçš„ä¿¡æ¯ã€‚
#+BEGIN_SRC c
#define SIMPLEFS_MAGIC 0x10032013
#define SIMPLEFS_DEFAULT_BLOCK_SIZE 4096
struct simplefs_super_block {
        uint64_t version; //ç‰ˆæœ¬å·
        uint64_t magic; //é­”æ•°
        uint64_t block_size;//super block ä¿¡æ¯æ‰€å ç”¨çš„å—å¤§å°

        /* FIXME: This should be moved to the inode store and not part of the sb */
        uint64_t inodes_count;//ç›®å‰å·²ç»ä½¿ç”¨äº†å¤šå°‘ä¸ªinode

        uint64_t free_blocks;//ç›®å‰è¿˜å‰©ä¸‹å¤šå°‘ä¸ªblock

        //æ­¤éƒ¨åˆ†æ˜¯ä¸ºäº†å¡«å……ç»“æ„ä½“ï¼Œä½¿æ•´ä¸ªç»“æ„ä½“å¤§å°ä¸º4096å­—èŠ‚
        char padding[SIMPLEFS_DEFAULT_BLOCK_SIZE - (5 * sizeof(uint64_t))];
};
static int write_superblock(int fd)
{
        struct simplefs_super_block sb = {
                .version = 1,
                .magic = SIMPLEFS_MAGIC,
                .block_size = SIMPLEFS_DEFAULT_BLOCK_SIZE,
                /* One inode for rootdirectory and another for a welcome file that we are going to create */
                .inodes_count = 2,//ä½¿ç”¨ä¸€ä¸ªinodeå¯¹åº”æ ¹ç›®å½•ï¼Œä¸€ä¸ªinodeå¯¹åº”ä¸€ä¸ªæ–‡ä»¶
                /* FIXME: Free blocks management is not implemented yet */
                .free_blocks = (~0) & ~(1 << WELCOMEFILE_DATABLOCK_NUMBER),
        };
        ssize_t ret;

        ret = write(fd, &sb, sizeof(sb));
        if (ret != SIMPLEFS_DEFAULT_BLOCK_SIZE) {
                printf
                        ("bytes written [%d] are not equal to the default block size\n",
                         (int)ret);
                return -1;
        }

        printf("Super block written succesfully\n");
        return 0;
}
#+END_SRC
*** å†™æ ¹æ–‡ä»¶inode
æ ¹æ–‡ä»¶çš„inodeç´§æ¥ç€superblock å¾€åå¡«å……ï¼Œä¹Ÿå°±æ˜¯åœ¨ç¬¬2ä¸ªblockä¸­å­˜å‚¨inode.
#+BEGIN_SRC c
struct simplefs_inode {
        mode_t mode; //æ­¤inodeè¡¨ç¤ºçš„æ¡£æ¡ˆç±»å‹
        uint64_t inode_no;//inodeçš„ç´¢å¼•å·
        uint64_t data_block_number;//ä¸inodeå¯¹åº”çš„blockçš„ç´¢å¼•å·

        union {//æ–‡ä»¶å¤§å°æˆ–æ˜¯ç›®å½•å¯¹åº”çš„å†…å®¹å¯¹
                uint64_t file_size;
                uint64_t dir_children_count;
        };
};
const int SIMPLEFS_ROOTDIR_INODE_NUMBER = 1;
const int SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER = 2;
const int SIMPLEFS_INODESTORE_BLOCK_NUMBER = 1;
static int write_inode_store(int fd)
{
        ssize_t ret;

        struct simplefs_inode root_inode;

        root_inode.mode = S_IFDIR;
        root_inode.inode_no = SIMPLEFS_ROOTDIR_INODE_NUMBER;
        root_inode.data_block_number = SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER;
        root_inode.dir_children_count = 1;

        ret = write(fd, &root_inode, sizeof(root_inode));

        if (ret != sizeof(root_inode)) {
                printf
                        ("The inode store was not written properly. Retry your mkfs\n");
                return -1;
        }

        printf("root directory inode written succesfully\n");
        return 0;
}
#+END_SRC
*** å†™æ–‡ä»¶inode
é€šè¿‡æ­¤å‡½æ•°å¯ä»¥çœ‹å‡ºï¼šæ‰€æœ‰çš„inodeéƒ½å­˜å‚¨åœ¨ä¸€ä¸ªblockä¸­ï¼Œè€Œä¸€ä¸ªinodeå¤§å°ä¸º =28= å­—èŠ‚ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œæ­¤æ–‡ä»¶ç³»ç»Ÿæœ€å¤šæ”¯æŒæ–‡ä»¶å’Œæ–‡ä»¶å¤¹çš„æ€»æ•°ä¸º 4096 / 28 = 146 
#+BEGIN_SRC c
#define SIMPLEFS_DEFAULT_BLOCK_SIZE 4096
const uint64_t WELCOMEFILE_INODE_NUMBER = 2;//æ–‡ä»¶inodeä¸º2å·
const uint64_t WELCOMEFILE_DATABLOCK_NUMBER = 3;//æ–‡ä»¶å†…å®¹block
char welcomefile_body[] = "Love is God. God is Love. Anbe Murugan.\n";
struct simplefs_inode welcome = {
        .mode = S_IFREG,
        .inode_no = WELCOMEFILE_INODE_NUMBER,
        .data_block_number = WELCOMEFILE_DATABLOCK_NUMBER,
        .file_size = sizeof(welcomefile_body),
};
static int write_inode(int fd, const struct simplefs_inode *i)
{
        off_t nbytes;
        ssize_t ret;

        ret = write(fd, i, sizeof(*i));
        if (ret != sizeof(*i)) {
                printf
                        ("The welcomefile inode was not written properly. Retry your mkfs\n");
                return -1;
        }
        printf("welcomefile inode written succesfully\n");

        //ç®—å‡ºéœ€è¦ç§»åŠ¨åˆ°blockå°¾éœ€è¦å¤šå°‘å­—èŠ‚(ä¾æ¬¡å‡å»root inode å’Œ welcome inode)
        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - sizeof(*i) - sizeof(*i);
        ret = lseek(fd, nbytes, SEEK_CUR);
        if (ret == (off_t)-1) {
                printf
                        ("The padding bytes are not written properly. Retry your mkfs\n");
                return -1;
        }

        printf
                ("inode store padding bytes (after the two inodes) written sucessfully\n");
        return 0;
}
#+END_SRC
*** å†™æ ¹ç›®å½•block
å†™æ ¹ç›®å½•blockå°±æ˜¯å†™æ–‡ä»¶åä»¥åŠå…¶inodeçš„ç´¢å¼•,ä¸€ä¸ªåç§°å¯¹çš„å¤§å°ä¸º 264 å­—èŠ‚ï¼Œ
ä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªç›®å½•æœ€å¤šå¯ä»¥å­˜å‚¨çš„åç§°å¯¹ä¸º 4096 / 264 = 15 ä¸ªï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªç›®å½•
æœ€å¤šå­˜å‚¨15ä¸ªæ–‡ä»¶æˆ–ç›®å½•åã€‚
#+BEGIN_SRC c
#define SIMPLEFS_FILENAME_MAXLEN 255 //æ–‡ä»¶åçš„æœ€å¤§é•¿åº¦
struct simplefs_dir_record {
        char filename[SIMPLEFS_FILENAME_MAXLEN];
        uint64_t inode_no;//æ–‡ä»¶åä»¥åŠå…¶å¯¹åº”çš„blockç´¢å¼•
};
struct simplefs_dir_record record = {
        .filename = "vanakkam",
        .inode_no = WELCOMEFILE_INODE_NUMBER,
};
int write_dirent(int fd, const struct simplefs_dir_record *record)
{
        ssize_t nbytes = sizeof(*record), ret;

        ret = write(fd, record, nbytes);
        if (ret != nbytes) {
                printf
                        ("Writing the rootdirectory datablock (name+inode_no pair for welcomefile) has failed\n");
                return -1;
        }
        printf
                ("root directory datablocks (name+inode_no pair for welcomefile) written succesfully\n");

        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - sizeof(*record);
        ret = lseek(fd, nbytes, SEEK_CUR);//ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªblock
        if (ret == (off_t)-1) {
                printf
                        ("Writing the padding for rootdirectory children datablock has failed\n");
                return -1;
        }
        printf
                ("padding after the rootdirectory children written succesfully\n");
        return 0;
}
#+END_SRC
*** å†™æ–‡ä»¶block 
å†™æ–‡ä»¶blockå°±æ˜¯æŠŠæ–‡ä»¶å†…å®¹å†™è¿›å»å³å¯ã€‚
#+BEGIN_SRC c
int write_block(int fd, char *block, size_t len)
{
        ssize_t ret;

        ret = write(fd, block, len);
        if (ret != len) {
                printf("Writing file body has failed\n");
                return -1;
        }
        printf("block has been written succesfully\n");
        return 0;
}
#+END_SRC
** æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„
æ ¹æ®ä¸Šé¢çš„æ ¼å¼åŒ–ä»£ç ï¼Œå¯ä»¥çŸ¥é“å…¶ç»“æ„å¦‚ä¸‹å›¾ï¼š
[[./simplefs_struct.jpg]]

å¯ä»¥çœ‹å‡ºæ­¤æ–‡ä»¶ç³»ç»Ÿçš„ç¡®æ˜¯è¶³å¤Ÿçš„ç®€å•ï¼š
1. superblockæè¿°æä¸ºç®€å•
2. å¹¶ä¸å…·å¤‡block bitmap å’Œ inode bitmap
3. æœ€å¤šæ”¯æŒçš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹æ€»æ•°ä¸º146ä¸ª(å› ä¸ºä»…ç”¨äº†ä¸€ä¸ªblockæ¥å­˜å‚¨inode)
4. ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸­å¯ä»¥å­˜å‚¨çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹æ€»æ•°ä¸º15ä¸ª
5. ä¸€ä¸ªæ–‡ä»¶çš„å†…å®¹ä¸èƒ½è¶…è¿‡ä¸€ä¸ªblock

*** æ–‡ä»¶ç³»ç»Ÿæ“ä½œé€»è¾‘
æ ¹æ®ä»¥ä¸Šç®€å•ç»“æ„çš„åˆ†æï¼Œå¯ä»¥çŒœæµ‹å‡ºå…¶åŸºæœ¬çš„æ–‡ä»¶æ“ä½œé€»è¾‘ï¼š
1. æ–°å»ºæ–‡ä»¶å¤¹
  + ä»inode table ä¸­å¡«å……ä¸€ä¸ªæ–‡ä»¶å¤¹ç±»å‹çš„inodeå¹¶è·å–å…¶ç´¢å¼•
  + ä¸ºæ­¤ç´¢å¼•çš„inodeåˆ†é…ä¸€ä¸ªblockå¹¶å†™å…¥å¯¹åº”çš„inode
  + å°†æ–°å»ºæ–‡ä»¶å¤¹çš„åç§°å’Œinodeç´¢å¼•å¯¹åº”å­˜å‚¨åœ¨å½“å‰æ–‡ä»¶å¤¹çš„blockä¸­
  + æ›´æ–° superblock ä¸­çš„inodeè®¡æ•°
2. æ–°å»ºæ–‡ä»¶
  + ä»inode table ä¸­å¡«å……ä¸€ä¸ªæ–‡ä»¶ç±»å‹çš„inodeå¹¶è·å–å…¶ç´¢å¼•
  + ä¸ºæ­¤ç´¢å¼•çš„inodeåˆ†é…ä¸€ä¸ªblockå¹¶å†™å…¥å¯¹åº”çš„inode
  + å°†æ–‡ä»¶å†…å®¹å†™å…¥å…¶blockä¸­
  + å°†æ–°å»ºæ–‡ä»¶çš„åç§°å’Œinodeç´¢å¼•å¯¹åº”å­˜å‚¨åœ¨å½“å‰æ–‡ä»¶å¤¹çš„blockä¸­
  + æ›´æ–° superblock ä¸­çš„inodeè®¡æ•°
3. åˆ é™¤æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
  + å»é™¤å½“å‰æ–‡ä»¶å¤¹ä¸­å¯¹åº”æ­¤æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹çš„æè¿°å­—ç¬¦ä¸²
  + æ›´æ–° superblock ä¸­çš„inodeè®¡æ•°
4. å»ºç«‹ç¡¬é“¾æ¥
  + åœ¨å½“å‰æ–‡ä»¶å¤¹ä¸‹æ‹·è´ä¸€ä»½ç›®æ ‡æ–‡ä»¶æ‰€åœ¨çš„æ–‡ä»¶å¤¹ä¸­å¯¹äºæ­¤æ–‡ä»¶çš„æè¿°å­—ç¬¦ä¸²
5. å»ºç«‹ç¬¦å·é“¾æ¥
  + é¦–å…ˆæ–°å»ºä¸€ä¸ªæ–‡ä»¶
  + ç„¶åæ–°å»ºæ–‡ä»¶çš„å†…å®¹æŒ‡å‘ç›®æ ‡æ–‡ä»¶æ‰€åœ¨çš„æ–‡ä»¶å¤¹çš„inode

åŸºäºè¿™äº›çŒœæµ‹ï¼Œæ¥ä¸‹æ¥åˆ†æå…¶æ–‡ä»¶ç³»ç»Ÿæ“ä½œä»£ç ã€‚

** æ“ä½œä»£ç åˆ†æ(simple.c)
*** æŒ‚è½½
åœ¨è½½å…¥æ¨¡å—æ—¶ï¼Œä¼šé¦–å…ˆä½¿ç”¨å‡½æ•° =kmem_cache_create= ï¼Œç”¨äºä¸ºæ–‡ä»¶ç³»ç»Ÿçš„inodeç”³è¯·ç¼“å­˜ä»¥ä¾¿è¾¾åˆ°å¿«é€Ÿè®¿é—®çš„ç›®çš„ã€‚
#+BEGIN_SRC c
sfs_inode_cachep = kmem_cache_create("sfs_inode_cache",
                                     sizeof(struct simplefs_inode),
                                     0,
                                     (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD),
                                     NULL);
#+END_SRC
åœ¨æŒ‚è½½æ–‡ä»¶æ—¶ï¼Œä¼šè°ƒç”¨å‡½æ•° =simplefs_fill_super= å‡½æ•°ï¼Œæ­¤å‡½æ•°çš„ä¸»è¦ç›®çš„å°±æ˜¯å¡«å…… =super_block= ç»“æ„ä½“
#+BEGIN_SRC c
/* This function, as the name implies, Makes the super_block valid and
 ,* fills filesystem specific information in the super block */
int simplefs_fill_super(struct super_block *sb, void *data, int silent)
{
        struct inode *root_inode;
        struct buffer_head *bh;
        struct simplefs_super_block *sb_disk;
        int ret = -EPERM;

        //ä»å­˜å‚¨super block æè¿°çš„block(0)ä¸­è¯»å–æ•°æ®
        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);
        BUG_ON(!bh);

        //å¾—åˆ° simplefs_super_block å…·ä½“å†…å®¹
        sb_disk = (struct simplefs_super_block *)bh->b_data;

        printk(KERN_INFO "The magic number obtained in disk is: [%llu]\n",
               sb_disk->magic);

        if (unlikely(sb_disk->magic != SIMPLEFS_MAGIC)) {
                printk(KERN_ERR
                       "The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.");
                goto release;
        }

        if (unlikely(sb_disk->block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) {
                printk(KERN_ERR
                       "simplefs seem to be formatted using a non-standard block size.");
                goto release;
        }

        printk(KERN_INFO
               "simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\n",
               sb_disk->version, sb_disk->block_size);

        /* A magic number that uniquely identifies our filesystem type */
        sb->s_magic = SIMPLEFS_MAGIC;

        /* For all practical purposes, we will be using this s_fs_info as the super block */
        //è®¾ä¸ºç§æœ‰åœ°å€ï¼Œä»¥ä¾¿åé¢ä½¿ç”¨
        sb->s_fs_info = sb_disk;

        //æœ€å¤§çš„æ–‡ä»¶å¤§å°å°±æ˜¯ä¸ºä¸€ä¸ªblock
        sb->s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;
        //super block æ“ä½œ
        sb->s_op = &simplefs_sops;

        root_inode = new_inode(sb);
        //è·Ÿç›®å½•çš„inodeä½ç½®
        root_inode->i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;
        inode_init_owner(root_inode, NULL, S_IFDIR);
        root_inode->i_sb = sb;
        //æ ¹ç›®å½•inodeæ“ä½œ
        root_inode->i_op = &simplefs_inode_ops;
        //æ ¹ç›®å½•æ“ä½œ
        root_inode->i_fop = &simplefs_dir_operations;
        root_inode->i_atime = root_inode->i_mtime = root_inode->i_ctime =
                CURRENT_TIME;

        //å¾—åˆ°æ ¹ç›®å½•çš„inodeå†…å®¹(å¹¶ä¸”ä¼šå°†æ­¤inodeæ”¾å…¥inode cache ä¸­)
        root_inode->i_private =
                simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);

        /* TODO: move such stuff into separate header. */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
        sb->s_root = d_make_root(root_inode);
        #else
        sb->s_root = d_alloc_root(root_inode);
        if (!sb->s_root)
                iput(root_inode);
        #endif

        if (!sb->s_root) {
                ret = -ENOMEM;
                goto release;
        }

        ret = 0;
release:
        brelse(bh);

        return ret;
}
#+END_SRC

å…¶æ•°æ®å¡«å……ç»“æœå¦‚ä¸‹å›¾ï¼š
[[./struct_super_block.jpg]]

åœ¨ =super.h= ä¸­æœ‰ä»¥ä¸‹ä¸¤ä¸ªæ“ä½œ,å¯¹ç…§ä¸Šå›¾å°±å¯ä»¥çœ‹å‡ºå…¶æ„ä¹‰ï¼š
#+BEGIN_SRC c
//è·å– simplefs_super_block ç»“æ„ä½“åœ°å€
static inline struct simplefs_super_block *SIMPLEFS_SB(struct super_block *sb)
{
        return sb->s_fs_info;
}

//è·å–æ–‡ä»¶æˆ–ç›®å½• inodeçš„åœ°å€
static inline struct simplefs_inode *SIMPLEFS_INODE(struct inode *inode)
{
        return inode->i_private;
}
#+END_SRC
*** è¯»å–æ–‡ä»¶å¤¹å†…å®¹
ä¸ºäº†è·å–æ–‡ä»¶å¤¹çš„å†…å®¹å¾—å…ˆä»ç›®å½•inodeæ‰¾åˆ°å…¶å¯¹åº”çš„blockã€‚

å½“åœ¨ =mount= æ–‡ä»¶å¤¹ä¸‹ä½¿ç”¨å‘½ä»¤ =ls= æ—¶ï¼Œå…¶æ‰§è¡Œè·¯å¾„ä¾æ¬¡ä¸ºï¼š
- simplefs_iterate : ç”¨äºæ‰«æç›®å½•ä¸­çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹åç§°ä»¥åŠå…¶å¯¹åº”çš„inode
#+BEGIN_SRC c
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
static int simplefs_iterate(struct file *filp, struct dir_context *ctx)
#else
static int simplefs_readdir(struct file *filp, void *dirent, filldir_t filldir)
#endif
{
        loff_t pos;
        struct inode *inode;
        struct super_block *sb;
        struct buffer_head *bh;
        struct simplefs_inode *sfs_inode;
        struct simplefs_dir_record *record;
        int i;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
        pos = ctx->pos;
        #else
        pos = filp->f_pos;
        #endif
        inode = filp->f_dentry->d_inode;
        sb = inode->i_sb;

        if (pos) {
                /* FIXME: We use a hack of reading pos to figure if we have filled in all data.
                 ,* We should probably fix this to work in a cursor based model and
                 ,* use the tokens correctly to not fill too many data in each cursor based call */
                return 0;
        }

        //å¾—åˆ°ç›®å½•çš„inode
        sfs_inode = SIMPLEFS_INODE(inode);

        if (unlikely(!S_ISDIR(sfs_inode->mode))) {
                printk(KERN_ERR
                       "inode [%llu][%lu] for fs object [%s] not a directory\n",
                       sfs_inode->inode_no, inode->i_ino,
                       filp->f_dentry->d_name.name);
                return -ENOTDIR;
        }

        //å¾—åˆ°ç›®å½•çš„block
        bh = sb_bread(sb, sfs_inode->data_block_number);
        BUG_ON(!bh);

        //è·å–ç›®å½•blockcå†…å®¹
        record = (struct simplefs_dir_record *)bh->b_data;
        //æ ¹æ®ç›®å½•ä¸­å«æœ‰çš„æ¡ç›®è¿›è¡Œæ‰«æ
        for (i = 0; i < sfs_inode->dir_children_count; i++) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
                //è¿”å›æ–‡ä»¶åä»¥åŠå…¶å¯¹åº”çš„inode
                dir_emit(ctx, record->filename, SIMPLEFS_FILENAME_MAXLEN,
                         record->inode_no, DT_UNKNOWN);
                ctx->pos += sizeof(struct simplefs_dir_record);
                #else
                filldir(dirent, record->filename, SIMPLEFS_FILENAME_MAXLEN, pos,
                        record->inode_no, DT_UNKNOWN);
                filp->f_pos += sizeof(struct simplefs_dir_record);
                #endif
                pos += sizeof(struct simplefs_dir_record);
                record++;
        }
        brelse(bh);

        return 0;
}
#+END_SRC
- simplefs_lookup : å¾—åˆ°æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹çš„inodeå†…å®¹å¹¶åˆå§‹åŒ–ç³»ç»Ÿçš„ inodeç»“æ„ä½“
#+BEGIN_SRC c
struct dentry *simplefs_lookup(struct inode *parent_inode,
                               struct dentry *child_dentry, unsigned int flags)
{
        //è·å–ç›®å½•inode
        struct simplefs_inode *parent = SIMPLEFS_INODE(parent_inode);
        struct super_block *sb = parent_inode->i_sb;
        struct buffer_head *bh;
        struct simplefs_dir_record *record;
        int i;

        //è¯»å–ç›®å½•çš„block
        bh = sb_bread(sb, parent->data_block_number);
        BUG_ON(!bh);

        //è¯»å–ç›®å½•çš„blockÃ¥†…®¹
        record = (struct simplefs_dir_record *)bh->b_data;
        for (i = 0; i < parent->dir_children_count; i++) {
                if (!strcmp(record->filename, child_dentry->d_name.name)) {
                        /* FIXME: There is a corner case where if an allocated inode,
                         ,* is not written to the inode store, but the inodes_count is
                         ,* incremented. Then if the random string on the disk matches
                         ,* with the filename that we are comparing above, then we
                         ,* will use an invalid uninitialized inode */

                        struct inode *inode;
                        struct simplefs_inode *sfs_inode;

                        //æ ¹æ®æ–‡ä»¶inodeå·è·å–å…¶å†…å®¹
                        sfs_inode = simplefs_get_inode(sb, record->inode_no);

                        //åˆå§‹åŒ–inodeç»“æ„ä½“ä»¥åŠå…¶å¯¹åº”çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹æ“ä½œ
                        inode = new_inode(sb);
                        inode->i_ino = record->inode_no;
                        inode_init_owner(inode, parent_inode, sfs_inode->mode);
                        inode->i_sb = sb;
                        inode->i_op = &simplefs_inode_ops;

                        if (S_ISDIR(inode->i_mode))
                                inode->i_fop = &simplefs_dir_operations;
                        else if (S_ISREG(inode->i_mode))
                                inode->i_fop = &simplefs_file_operations;
                        else
                                printk(KERN_ERR
                                       "Unknown inode type. Neither a directory nor a file");

                        /* FIXME: We should store these times to disk and retrieve them */
                        inode->i_atime = inode->i_mtime = inode->i_ctime =
                                CURRENT_TIME;

                        inode->i_private = sfs_inode;

                        d_add(child_dentry, inode);
                        return NULL;
                }
                record++;
        }

        printk(KERN_ERR
               "No inode found for the filename [%s]\n",
               child_dentry->d_name.name);

        return NULL;
}
#+END_SRC
- simplefs_get_inode : å¾—åˆ°è¯·æ±‚çš„inodeå·ç çš„å†…å®¹
#+BEGIN_SRC c
/* This functions returns a simplefs_inode with the given inode_no
 ,* from the inode store, if it exists. */
struct simplefs_inode *simplefs_get_inode(struct super_block *sb,
                                          uint64_t inode_no)
{
        //è·å–super block
        struct simplefs_super_block *sfs_sb = SIMPLEFS_SB(sb);
        struct simplefs_inode *sfs_inode = NULL;
        struct simplefs_inode *inode_buffer = NULL;

        int i;
        struct buffer_head *bh;

        /* The inode store can be read once and kept in memory permanently while mounting.
         ,* But such a model will not be scalable in a filesystem with
         ,* millions or billions of files (inodes) */
        //è¯»å–inode table
        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);
        BUG_ON(!bh);

        sfs_inode = (struct simplefs_inode *)bh->b_data;

        #if 0
        if (mutex_lock_interruptible(&simplefs_inodes_mgmt_lock)) {
                printk(KERN_ERR "Failed to acquire mutex lock %s +%d\n",
                       __FILE__, __LINE__);
                return NULL;
        }
        #endif
        //æ‰«æinode table æ˜¯å¦æœ‰ä¸è¦æ±‚çš„åºå·åŒ¹é…çš„Inode
        for (i = 0; i < sfs_sb->inodes_count; i++) {
                if (sfs_inode->inode_no == inode_no) {
                        //ç”³è¯·cache
                        inode_buffer = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);
                        memcpy(inode_buffer, sfs_inode, sizeof(*inode_buffer));

                        break;
                }
                sfs_inode++;
        }
        //      mutex_unlock(&simplefs_inodes_mgmt_lock);

        brelse(bh);
        return inode_buffer;
}
#+END_SRC
- simplefs_iterate

å¯ä»¥çœ‹å‡ºå…¶åŸºæœ¬æ€è·¯æ˜¯ï¼š
1. é€šè¿‡æ–‡ä»¶å¤¹çš„inodeè·å–å…¶block
2. æ‰«æblockæœ‰å“ªäº›æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹
3. è·å–è¿™äº›æ‰«æåˆ°çš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹çš„inodeå†…å®¹ï¼Œä¸ºå…¶æ“ä½œåšå¥½å‡†å¤‡

*** è¯»å–æ–‡ä»¶å†…å®¹
å¯ä»¥çŒœæµ‹ä¸ºäº†è¯»å–æ–‡ä»¶å†…å®¹ï¼Œé¦–å…ˆè¦è·å–å…¶inodeæ‰èƒ½æ‰¾åˆ°å…¶block.

å½“æ‰§è¡Œ =cat vanakkam= æ—¶ï¼Œæ‰§è¡Œçš„å‡½æ•°ä¾æ¬¡æ˜¯ï¼š
- simplefs_iterate : é‡å¤æ‰§è¡Œäº†8æ¬¡
- simplefs_read
#+BEGIN_SRC c
ssize_t simplefs_read(struct file * filp, char __user * buf, size_t len,
                      loff_t * ppos)
{
        /* After the commit dd37978c5 in the upstream linux kernel,
         ,* we can use just filp->f_inode instead of the
         ,* f->f_path.dentry->d_inode redirection */
        //è·å–inodeå†…å®¹
        struct simplefs_inode *inode =
                SIMPLEFS_INODE(filp->f_path.dentry->d_inode);
        struct buffer_head *bh;

        char *buffer;
        int nbytes;

        if (*ppos >= inode->file_size) {
                /* Read request with offset beyond the filesize */
                return 0;
        }

        //è¯»å–block
        bh = sb_bread(filp->f_path.dentry->d_inode->i_sb,
                      inode->data_block_number);

        if (!bh) {
                printk(KERN_ERR "Reading the block number [%llu] failed.",
                       inode->data_block_number);
                return 0;
        }

        //è·å–blockå†…å®¹
        buffer = (char *)bh->b_data;
        nbytes = min((size_t) inode->file_size, len);

        if (copy_to_user(buf, buffer, nbytes)) {
                brelse(bh);
                printk(KERN_ERR
                       "Error copying file contents to the userspace buffer\n");
                return -EFAULT;
        }

        brelse(bh);

        ,*ppos += nbytes;

        return nbytes;
}
#+END_SRC
- simplefs_read

å¯ä»¥çœ‹å‡ºå…¶æ€è·¯ä¸ºï¼š
1. ä»ç›®å½•inodeè·å–ç›®å½•blockï¼Œè¿›è€Œè·å–åˆ°æ–‡ä»¶çš„inode
  + æ‰€ä»¥å½“ä½ å¯¹ä¸€ä¸ªç›®å½•éƒ½æ²¡æœ‰è¯»æƒé™æ—¶ï¼Œæ˜¯æ— æ³•é€šè¿‡å…¶inodeæ¥è·å–æ–‡ä»¶å†…å®¹çš„
2. ä»æ–‡ä»¶inodeæ‰¾åˆ°å…¶å¯¹åº”blockå†è¯»å–å…¶å†…å®¹
*** å†™æ–‡ä»¶å†…å®¹
å¯ä»¥çŒœæµ‹å…¶ä¸è¯»æ–‡ä»¶å†…å®¹çš„æ€è·¯æ˜¯ä¸€æ ·çš„ï¼š
1. ä»ç›®å½•inodeè·å–ç›®å½•blockï¼Œè¿›è€Œè·å–åˆ°æ–‡ä»¶çš„inode
2. ä»æ–‡ä»¶inodeæ‰¾åˆ°å…¶å¯¹åº”blockå†å†™å…¥å¯¹åº”çš„å†…å®¹
3. æ›´æ–°inodeæè¿°(å› ä¸ºinodeä¸­å…·æœ‰æ–‡ä»¶ä¿¡æ¯)

æ‰§è¡Œ echo "Hello world!" > vanakkam å…¶æ‰§è¡Œè·¯å¾„ä¸ºï¼š
- simplefs_iterate : é‡å¤æ‰§è¡Œäº†12æ¬¡ï¼Œæ²¡çœ‹æ‡‚ä¸ºä»€ä¹ˆ
- simplefs_write : å†™å…¥æ•°æ®å¹¶åŒæ­¥
#+BEGIN_SRC c
ssize_t simplefs_write(struct file * filp, const char __user * buf, size_t len,
                       loff_t * ppos)
{
        /* After the commit dd37978c5 in the upstream linux kernel,
         ,* we can use just filp->f_inode instead of the
         ,* f->f_path.dentry->d_inode redirection */
        struct inode *inode;
        struct simplefs_inode *sfs_inode;
        struct buffer_head *bh;
        struct super_block *sb;

        char *buffer;

        int retval;

        retval = generic_write_checks(filp, ppos, &len, 0);
        if (retval) {
                return retval;
        }

        inode = filp->f_path.dentry->d_inode;
        //è·å–inodeå†…å®¹
        sfs_inode = SIMPLEFS_INODE(inode);
        sb = inode->i_sb;
        //è·å–blockåœ°å€
        bh = sb_bread(filp->f_path.dentry->d_inode->i_sb,
                      sfs_inode->data_block_number);

        if (!bh) {
                printk(KERN_ERR "Reading the block number [%llu] failed.",
                       sfs_inode->data_block_number);
                return 0;
        }
        //è·å–blockå†…å®¹
        buffer = (char *)bh->b_data;

        /* Move the pointer until the required byte offset */
        buffer += *ppos;

        if (copy_from_user(buffer, buf, len)) {
                brelse(bh);
                printk(KERN_ERR
                       "Error copying file contents from the userspace buffer to the kernel space\n");
                return -EFAULT;
        }
        ,*ppos += len;

        //åŒæ­¥æ•°æ®åˆ°ç¡¬ç›˜
        mark_buffer_dirty(bh);
        sync_dirty_buffer(bh);
        brelse(bh);

        /* Set new size
         ,* sfs_inode->file_size = max(sfs_inode->file_size, *ppos);
         ,*
         ,* FIXME: What to do if someone writes only some parts in between ?
         ,* The above code will also fail in case a file is overwritten with
         ,* a shorter buffer */
        if (mutex_lock_interruptible(&simplefs_inodes_mgmt_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                return -EINTR;
        }
        sfs_inode->file_size = *ppos;
        retval = simplefs_inode_save(sb, sfs_inode);
        if (retval) {
                len = retval;
        }
        mutex_unlock(&simplefs_inodes_mgmt_lock);

        return len;
}
#+END_SRC
- simplefs_inode_save : æ›´æ–°inode
#+BEGIN_SRC c
int simplefs_inode_save(struct super_block *sb, struct simplefs_inode *sfs_inode)
{
        struct simplefs_inode *inode_iterator;
        struct buffer_head *bh;

        //è¯»å–inode table
        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);
        BUG_ON(!bh);

        if (mutex_lock_interruptible(&simplefs_sb_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                return -EINTR;
        }

        //ä»inode table èµ·å§‹éå†å‡ºå¯¹åº”inodeçš„å†…å®¹
        inode_iterator = simplefs_inode_search(sb,
                                               (struct simplefs_inode *)bh->b_data,
                                               sfs_inode);

        if (likely(inode_iterator)) {
                //æ›´æ–° inode
                memcpy(inode_iterator, sfs_inode, sizeof(*inode_iterator));
                printk(KERN_INFO "The inode updated\n");

                //ä¸ç¡¬ç›˜åŒæ­¥
                mark_buffer_dirty(bh);
                sync_dirty_buffer(bh);
        } else {
                mutex_unlock(&simplefs_sb_lock);
                printk(KERN_ERR
                       "The new filesize could not be stored to the inode.");
                return -EIO;
        }

        brelse(bh);

        mutex_unlock(&simplefs_sb_lock);

        return 0;
}
#+END_SRC
- simplefs_inode_search : ä»inode table ä¸­æ‰¾åˆ°å¯¹åº”åºåˆ—çš„inode

*** æ–°å»ºæ–‡ä»¶å¤¹
å…ˆæ¥çŒœæµ‹æ–°å»ºæ–‡ä»¶å¤¹çš„æ­¥éª¤ï¼š
1. æ ¹æ®æ–‡ä»¶å¤¹inodeæ‰¾åˆ°å…¶block
2. ä¸ºæ–°å»ºçš„æ–‡ä»¶å¤¹åœ¨inode table ä¸­è·å–ä¸€ä¸ªinode
3. ä¸ºæ–°å»ºçš„æ–‡ä»¶å¤¹åˆ†é…ä¸€ä¸ªblock
4. å°†æ–°ç”³è¯·åˆ°çš„æ–‡ä»¶å¤¹åç§°ä»¥åŠå…¶inodeå·å†™å…¥çˆ¶æ–‡ä»¶å¤¹çš„blockä¸­
5. æ›´æ–°çˆ¶æ–‡ä»¶å¤¹inode
6. ä¸ç¡¬ç›˜åŒæ­¥

æ‰§è¡Œå‘½ä»¤ =mkdir hello= å…¶è°ƒç”¨å‡½æ•°ä¾æ¬¡ä¸ºï¼š
- simplefs_iterate : æµè§ˆç›®å½•è·å–å…¶æ¡£æ¡ˆåŠå¯¹åº”inode
- simplefs_lookup : æŸ¥çœ‹å½“å‰ç›®å½•æ˜¯å¦å·²æœ‰æ­¤æ¡£æ¡ˆå
- simplefs_mkdir : æ–°å»ºæ–‡ä»¶å¤¹
- simplefs_create_fs_object : æ–°å»ºæ¡£æ¡ˆ
#+BEGIN_SRC c
static int simplefs_create_fs_object(struct inode *dir, struct dentry *dentry,
                                     umode_t mode)
{
        struct inode *inode;
        struct simplefs_inode *sfs_inode;
        struct super_block *sb;
        struct simplefs_inode *parent_dir_inode;
        struct buffer_head *bh;
        struct simplefs_dir_record *dir_contents_datablock;
        uint64_t count;
        int ret;

        if (mutex_lock_interruptible(&simplefs_directory_children_update_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                return -EINTR;
        }
        sb = dir->i_sb;

        //è·å– super block ä¸­è®°å½•çš„ inode æ•°ç›®
        ret = simplefs_sb_get_objects_count(sb, &count);
        if (ret < 0) {
                mutex_unlock(&simplefs_directory_children_update_lock);
                return ret;
        }

        if (unlikely(count >= SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) {
                /* The above condition can be just == insted of the >= */
                printk(KERN_ERR
                       "Maximum number of objects supported by simplefs is already reached");
                mutex_unlock(&simplefs_directory_children_update_lock);
                return -ENOSPC;
        }

        if (!S_ISDIR(mode) && !S_ISREG(mode)) {
                printk(KERN_ERR
                       "Creation request but for neither a file nor a directory");
                mutex_unlock(&simplefs_directory_children_update_lock);
                return -EINVAL;
        }

        inode = new_inode(sb);
        if (!inode) {
                mutex_unlock(&simplefs_directory_children_update_lock);
                return -ENOMEM;
        }

        inode->i_sb = sb;
        inode->i_op = &simplefs_inode_ops;
        inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
        inode->i_ino = (count + SIMPLEFS_START_INO - SIMPLEFS_RESERVED_INODES + 1);

        sfs_inode = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);
        sfs_inode->inode_no = inode->i_ino;
        inode->i_private = sfs_inode;
        sfs_inode->mode = mode;

        if (S_ISDIR(mode)) {
                printk(KERN_INFO "New directory creation request\n");
                sfs_inode->dir_children_count = 0;
                inode->i_fop = &simplefs_dir_operations;
        } else if (S_ISREG(mode)) {
                printk(KERN_INFO "New file creation request\n");
                sfs_inode->file_size = 0;
                inode->i_fop = &simplefs_file_operations;
        }

        /* First get a free block and update the free map,
         ,* Then add inode to the inode store and update the sb inodes_count,
         ,* Then update the parent directory's inode with the new child.
         ,*
         ,* The above ordering helps us to maintain fs consistency
         ,* even in most crashes
         ,*/
        //ç”³è¯·ä¸€ä¸ªç©ºé—²çš„block
        ret = simplefs_sb_get_a_freeblock(sb, &sfs_inode->data_block_number);
        if (ret < 0) {
                printk(KERN_ERR "simplefs could not get a freeblock");
                mutex_unlock(&simplefs_directory_children_update_lock);
                return ret;
        }

        //ç”³è¯·ä¸€ä¸ªç©ºé—²çš„inode
        simplefs_inode_add(sb, sfs_inode);

        parent_dir_inode = SIMPLEFS_INODE(dir);
        bh = sb_bread(sb, parent_dir_inode->data_block_number);
        BUG_ON(!bh);

        //å¾—åˆ°çˆ¶ç›®å½•çš„block
        dir_contents_datablock = (struct simplefs_dir_record *)bh->b_data;


        /* Navigate to the last record in the directory contents */
        dir_contents_datablock += parent_dir_inode->dir_children_count;
        //åœ¨çˆ¶ç›®å½•çš„blockÃ¤¸­¢Š ¸€¸ª­—¬¦¸²’Œinodeå¯¹
        dir_contents_datablock->inode_no = sfs_inode->inode_no;
        strcpy(dir_contents_datablock->filename, dentry->d_name.name);

        mark_buffer_dirty(bh);
        sync_dirty_buffer(bh);
        brelse(bh);

        if (mutex_lock_interruptible(&simplefs_inodes_mgmt_lock)) {
                mutex_unlock(&simplefs_directory_children_update_lock);
                sfs_trace("Failed to acquire mutex lock\n");
                return -EINTR;
        }

        //ä¿å­˜çˆ¶ç›®å½•inode
        parent_dir_inode->dir_children_count++;
        ret = simplefs_inode_save(sb, parent_dir_inode);
        if (ret) {
                mutex_unlock(&simplefs_inodes_mgmt_lock);
                mutex_unlock(&simplefs_directory_children_update_lock);

                /* TODO: Remove the newly created inode from the disk and in-memory inode store
                 ,* and also update the superblock, freemaps etc. to reflect the same.
                 ,* Basically, Undo all actions done during this create call */
                return ret;
        }

        mutex_unlock(&simplefs_inodes_mgmt_lock);
        mutex_unlock(&simplefs_directory_children_update_lock);

        inode_init_owner(inode, dir, mode);
        d_add(dentry, inode);

        return 0;
}
#+END_SRC
- simplefs_sb_get_object_count ï¼š è·å–å½“å‰super block ä¸­è®°å½•çš„inodeæ•°é‡
- simplefs_sb_get_a_freeblock : è·å–ç©ºé—²block
#+BEGIN_SRC c
int simplefs_sb_get_a_freeblock(struct super_block *vsb, uint64_t * out)
{
        //è·å–super block
        struct simplefs_super_block *sb = SIMPLEFS_SB(vsb);
        int i;
        int ret = 0;

        if (mutex_lock_interruptible(&simplefs_sb_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                ret = -EINTR;
                goto end;
        }

        /* Loop until we find a free block. We start the loop from 3,
         ,* as all prior blocks will always be in use */
        //ä»ç¬¬ä¸‰ä¸ªblock å¼€å§‹å¯»æ‰¾ï¼Œå‰ä¸¤ä¸ªåˆ†åˆ«æ˜¯(super block å’Œ inode table)
        for (i = 3; i < SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED; i++) {
                //é€šè¿‡ä½ä¸çš„æ–¹å¼æ¥è·å–ç©ºä½ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆæœ€å¤šæ”¯æŒ64ä¸ªblock(free_blocks æ˜¯64ä½)
                if (sb->free_blocks & (1 << i)) {
                        break;
                }
        }

        if (unlikely(i == SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) {
                printk(KERN_ERR "No more free blocks available");
                ret = -ENOSPC;
                goto end;
        }

        ,*out = i;

        //æ›´æ–°super block ä¸­è®°å½•çš„ç©ºé—²blockÃ¥€¼
        /* Remove the identified block from the free list */
        sb->free_blocks &= ~(1 << i);

        //åŒæ­¥super block ä¸ç¡¬ç›˜
        simplefs_sb_sync(vsb);

end:
        mutex_unlock(&simplefs_sb_lock);
        return ret;
}
#+END_SRC
- simplefs_sb_sync : åŒæ­¥super block ä¸ç¡¬ç›˜
- simplefs_inode_add : è·å–ä¸€ä¸ªinode
#+BEGIN_SRC c
void simplefs_inode_add(struct super_block *vsb, struct simplefs_inode *inode)
{
        struct simplefs_super_block *sb = SIMPLEFS_SB(vsb);
        struct buffer_head *bh;
        struct simplefs_inode *inode_iterator;

        if (mutex_lock_interruptible(&simplefs_inodes_mgmt_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                return;
        }

        bh = sb_bread(vsb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);
        BUG_ON(!bh);

        //è·å–inode table å†…å®¹
        inode_iterator = (struct simplefs_inode *)bh->b_data;

        if (mutex_lock_interruptible(&simplefs_sb_lock)) {
                sfs_trace("Failed to acquire mutex lock\n");
                return;
        }

        /* Append the new inode in the end in the inode store */
        //ç§»åŠ¨åˆ°inode table çš„ç¬¬ä¸€ä¸ªç©ºé—²å¤„
        inode_iterator += sb->inodes_count;

        memcpy(inode_iterator, inode, sizeof(struct simplefs_inode));
        //æ›´æ–°super block è®¡æ•°
        sb->inodes_count++;

        mark_buffer_dirty(bh);
        //åŒæ­¥super block åˆ°ç¡¬ç›˜
        simplefs_sb_sync(vsb);
        brelse(bh);

        mutex_unlock(&simplefs_sb_lock);
        mutex_unlock(&simplefs_inodes_mgmt_lock);
}
#+END_SRC
- simplefs_sb_sync 
- simplefs_inode_save 
- simplefs_inode_search 

*** æ–°å»ºæ–‡ä»¶
  æ–°å»ºæ–‡æ–‡ä»¶
* æ¯”è¾ƒé‡è¦çš„æ•°æ®ç»“æ„
#+BEGIN_SRC c
/**
 ,* @brief æ–‡ä»¶ç³»ç»Ÿæ€»è§ˆ
 ,*/
struct file_system_type {
        const char *name;
        int fs_flags;
#define FS_REQUIRES_DEV1
#define FS_BINARY_MOUNTDATA2
#define FS_HAS_SUBTYPE4
#define FS_USERNS_MOUNT8/* Can be mounted by userns root */
#define FS_USERNS_DEV_MOUNT16 /* A userns mount does not imply MNT_NODEV */
#define FS_USERNS_VISIBLE32/* FS must already be visible */
#define FS_RENAME_DOES_D_MOVE32768/* FS will handle d_move() during rename() internally. */
        struct dentry *(*mount) (struct file_system_type *, int,
                                 const char *, void *);
        void (*kill_sb) (struct super_block *);
        struct module *owner;
        struct file_system_type * next;
        struct hlist_head fs_supers;

        struct lock_class_key s_lock_key;
        struct lock_class_key s_umount_key;
        struct lock_class_key s_vfs_rename_key;
        struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];

        struct lock_class_key i_lock_key;
        struct lock_class_key i_mutex_key;
        struct lock_class_key i_mutex_dir_key;
};
/**
 ,* @brief super block ä¿¡æ¯åŠæ“ä½œç»“æ„ä½“
 ,*/
struct super_block {
        struct list_heads_list;/* Keep this first */
        dev_ts_dev;/* search index; _not_ kdev_t */
        unsigned chars_blocksize_bits;
        unsigned longs_blocksize;
        loff_ts_maxbytes;/* Max file size */
        struct file_system_type*s_type;
        const struct super_operations*s_op;
        const struct dquot_operations*dq_op;
        const struct quotactl_ops*s_qcop;
        const struct export_operations *s_export_op;
        unsigned longs_flags;
        unsigned longs_iflags;/* internal SB_I_* flags */
        unsigned longs_magic;
        struct dentry*s_root;
        struct rw_semaphores_umount;
        ints_count;
        atomic_ts_active;
        #ifdef CONFIG_SECURITY
        void                    *s_security;
        #endif
        const struct xattr_handler **s_xattr;

        struct hlist_bl_heads_anon;/* anonymous dentries for (nfs) exporting */
        struct list_heads_mounts;/* list of mounts; _not_ for fs use */
        struct block_device*s_bdev;
        struct backing_dev_info *s_bdi;
        struct mtd_info*s_mtd;
        struct hlist_nodes_instances;
        unsigned ints_quota_types;/* Bitmask of supported quota types */
        struct quota_infos_dquot;/* Diskquota specific options */

        struct sb_writerss_writers;

        char s_id[32];/* Informational name */
        u8 s_uuid[16];/* UUID */

        void *s_fs_info;/* Filesystem private info */
        unsigned ints_max_links;
        fmode_ts_mode;

        /* Granularity of c/m/atime in ns.
           Cannot be worse than a second */
        u32   s_time_gran;

        /*
         ,* The next field is for VFS *only*. No filesystems have any business
         ,* even looking at it. You had been warned.
         ,*/
        struct mutex s_vfs_rename_mutex;/* Kludge */

        /*
         ,* Filesystem subtype.  If non-empty the filesystem type field
         ,* in /proc/mounts will be "type.subtype"
         ,*/
        char *s_subtype;

        /*
         ,* Saved mount options for lazy filesystems using
         ,* generic_show_options()
         ,*/
        char __rcu *s_options;
        const struct dentry_operations *s_d_op; /* default d_op for dentries */

        /*
         ,* Saved pool identifier for cleancache (-1 means none)
         ,*/
        int cleancache_poolid;

        struct shrinker s_shrink;/* per-sb shrinker handle */

        /* Number of inodes with nlink == 0 but still referenced */
        atomic_long_t s_remove_count;

        /* Being remounted read-only */
        int s_readonly_remount;

        /* AIO completions deferred from interrupt context */
        struct workqueue_struct *s_dio_done_wq;
        struct hlist_head s_pins;

        /*
         ,* Keep the lru lists last in the structure so they always sit on their
         ,* own individual cachelines.
         ,*/
        struct list_lrus_dentry_lru ____cacheline_aligned_in_smp;
        struct list_lrus_inode_lru ____cacheline_aligned_in_smp;
        struct rcu_headrcu;
        struct work_structdestroy_work;

        struct mutexs_sync_lock;/* sync serialisation lock */

        /*
         ,* Indicates how deep in a filesystem stack this SB is
         ,*/
        int s_stack_depth;

        /* s_inode_list_lock protects s_inodes */
        spinlock_ts_inode_list_lock ____cacheline_aligned_in_smp;
        struct list_heads_inodes;/* all inodes */
};

/*
 ,* Keep mostly read-only and often accessed (especially for
 ,* the RCU path lookup and 'stat' data) fields at the beginning
 ,* of the 'struct inode'
 ,*/
struct inode {
        umode_t                i_mode;
        unsigned               shorti_opflags;
        kuid_t                 i_uid;
        kgid_t                 i_gid;
        unsigned int           i_flags;

        #ifdef CONFIG_FS_POSIX_ACL
        struct posix_acl       *i_acl;
        struct posix_acl       *i_default_acl;
        #endif

        const struct inode_operations  *i_op;
        struct super_block             *i_sb;
        struct address_space           *i_mapping;

        #ifdef CONFIG_SECURITY
        void                           *i_security;
        #endif

        /* Stat data, not accessed from path walking */
        unsigned long                  i_ino;
        /*
         ,* Filesystems may only read i_nlink directly.  They shall use the
         ,* following functions for modification:
         ,*
         ,*    (set|clear|inc|drop)_nlink
         ,*    inode_(inc|dec)_link_count
         ,*/
        union {
                const unsigned int i_nlink;
                unsigned int __i_nlink;
        };
        dev_t                  i_rdev;
        loff_t                 i_size;
        struct timespec        i_atime;
        struct timespec        i_mtime;
        struct timespec        i_ctime;
        spinlock_ti_lock;/* i_blocks, i_bytes, maybe i_size */
        unsigned short         i_bytes;
        unsigned int           i_blkbits;
        blkcnt_t               i_blocks;

        #ifdef __NEED_I_SIZE_ORDERED
        seqcount_t             i_size_seqcount;
        #endif

        /* Misc */
        unsigned long          i_state;
        struct mutex           i_mutex;

        unsigned long          dirtied_when;/* jiffies of first dirtying */
        unsigned long          dirtied_time_when;

        struct hlist_node      i_hash;
        struct list_head       i_io_list;/* backing dev IO list */
        #ifdef CONFIG_CGROUP_WRITEBACK
        struct bdi_writeback   *i_wb;/* the associated cgroup wb */

        /* foreign inode detection, see wbc_detach_inode() */
        int                     i_wb_frn_winner;
        u16                     i_wb_frn_avg_time;
        u16                     i_wb_frn_history;
        #endif
        struct list_head        i_lru;/* inode LRU list */
        struct list_head        i_sb_list;
        union {
                struct hlist_head  i_dentry;
                struct rcu_head    i_rcu;
        };
        u64                        i_version;
        atomic_t                   i_count;
        atomic_t                   i_dio_count;
        atomic_t                   i_writecount;
        #ifdef CONFIG_IMA
        atomic_t                   i_readcount; /* struct files open RO */
        #endif
        const struct file_operations   *i_fop;/* former ->i_op->default_file_ops */
        struct file_lock_context       *i_flctx;
        struct address_space           i_data;
        struct list_head               i_devices;
        union {
                struct pipe_inode_info *i_pipe;
                struct block_device    *i_bdev;
                struct cdev            *i_cdev;
                char                   *i_link;
        };

        __u32                          i_generation;

        #ifdef CONFIG_FSNOTIFY
        __u32                          i_fsnotify_mask; /* all events this inode cares about */
        struct hlist_head              i_fsnotify_marks;
        #endif

        void                           *i_private; /* fs or device private pointer */
};
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        const char * (*follow_link) (struct dentry *, void **);
        int (*permission) (struct inode *, int);
        struct posix_acl * (*get_acl)(struct inode *, int);

        int (*readlink) (struct dentry *, char __user *,int);
        void (*put_link) (struct inode *, void *);

        int (*create) (struct inode *,struct dentry *, umode_t, bool);
        int (*link) (struct dentry *,struct inode *,struct dentry *);
        int (*unlink) (struct inode *,struct dentry *);
        int (*symlink) (struct inode *,struct dentry *,const char *);
        int (*mkdir) (struct inode *,struct dentry *,umode_t);
        int (*rmdir) (struct inode *,struct dentry *);
        int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
        int (*rename) (struct inode *, struct dentry *,
                       struct inode *, struct dentry *);
        int (*rename2) (struct inode *, struct dentry *,
                        struct inode *, struct dentry *, unsigned int);
        int (*setattr) (struct dentry *, struct iattr *);
        int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
        int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
        ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
        ssize_t (*listxattr) (struct dentry *, char *, size_t);
        int (*removexattr) (struct dentry *, const char *);
        int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
                      u64 len);
        int (*update_time)(struct inode *, struct timespec *, int);
        int (*atomic_open)(struct inode *, struct dentry *,
                           struct file *, unsigned open_flag,
                           umode_t create_mode, int *opened);
        int (*tmpfile) (struct inode *, struct dentry *, umode_t);
        int (*set_acl)(struct inode *, struct posix_acl *, int);
} ____cacheline_aligned;

/**
 ,* @brief ä»£è¡¨çš„æ˜¯ä¸€ä¸ªè·¯å¾„
 ,*/
struct dentry {
        /* RCU lookup touched fields */
        unsigned int d_flags;/* protected by d_lock */
        seqcount_t d_seq;/* per dentry seqlock */
        struct hlist_bl_node d_hash;/* lookup hash list */
        struct dentry *d_parent;/* parent directory */
        struct qstr d_name;
        struct inode *d_inode;/* Where the name belongs to - NULL is
                               ,* negative */
        unsigned char d_iname[DNAME_INLINE_LEN];/* small names */

        /* Ref lookup also touches following */
        struct lockref d_lockref;/* per-dentry lock and refcount */
        const struct dentry_operations *d_op;
        struct super_block *d_sb;/* The root of the dentry tree */
        unsigned long d_time;/* used by d_revalidate */
        void *d_fsdata;/* fs-specific data */

        struct list_head d_lru;/* LRU list */
        struct list_head d_child;/* child of parent list */
        struct list_head d_subdirs;/* our children */
        /*
         ,* d_alias and d_rcu can share memory
         ,*/
        union {
                struct hlist_node d_alias;/* inode alias list */
                struct rcu_head d_rcu;
        } d_u;
};
/**
 ,* @brief ä»£è¡¨ä¸€ä¸ªæ–‡ä»¶çš„å¼•ç”¨ï¼ˆä¸€ä¸ªæ–‡ä»¶å¯ä»¥è¢«æ‰“å¼€å¤šæ¬¡å°±æœ‰å¤šä¸ªå¼•ç”¨ï¼Œä½†inodeå´æ˜¯ä»…æœ‰ä¸€ä¸ªï¼‰
 ,*/
struct file {
        union {
                struct llist_node     fu_llist;
                struct rcu_head       fu_rcuhead;
        } f_u;
        struct path                   f_path;
        struct inode                  *f_inode;/* cached value */
        const struct file_operations  *f_op;

        /*
         ,* Protects f_ep_links, f_flags.
         ,* Must not be taken from IRQ context.
         ,*/
        spinlock_t                    f_lock;
        atomic_long_t                 f_count;
        unsigned int                  f_flags;
        fmode_t                       f_mode;
        struct mutex                  f_pos_lock;
        loff_t                        f_pos;
        struct fown_struct            f_owner;
        const struct cred             *f_cred;
        struct file_ra_state          f_ra;

        u64                           f_version;
        #ifdef CONFIG_SECURITY
        void                          *f_security;
        #endif
        /* needed for tty driver, and maybe others */
        void                          *private_data;

        #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct list_head              f_ep_links;
        struct list_head              f_tfile_llink;
#endif /* #ifdef CONFIG_EPOLL */
        struct address_space          *f_mapping;
} __attribute__((aligned(4)));/* lest something weird decides that 2 is OK */
#+END_SRC

inode Tab å­˜åœ¨äºç¡¬ç›˜ä¸­ï¼Œå¦‚æœæ¯æ¬¡CPUä»ç¡¬ç›˜ä¸­è¯»å–é‚£ä¹ˆæ•ˆç‡ä¼šæ¯”è¾ƒä½ä¸‹ï¼Œ
æ‰€ä»¥å†…æ ¸ä¼šä¸ºinode Table ç”³è¯·ä¸€æ®µå†…å­˜ä»¥ä½œä¸ºç¼“å­˜ï¼Œç§°ä¸º *å¯¹åº”æ–‡ä»¶ç³»ç»Ÿçš„ inode cache*.
#+BEGIN_SRC c
static int __init init_inodecache(void)
{
        ext4_inode_cachep = kmem_cache_create("ext4_inode_cache",
                                              sizeof(struct ext4_inode_info),
                                              0, (SLAB_RECLAIM_ACCOUNT|
                                                  SLAB_MEM_SPREAD),
                                              init_once);
        if (ext4_inode_cachep == NULL)
                return -ENOMEM;
        return 0;
}
#+END_SRC

åŒæ ·åœ¨VFSå±‚é¢ä¸Šï¼Œä¹Ÿä¼šå¯¹æŠ½è±¡å‡ºæ¥çš„ inode å’Œ è·¯å¾„è¿›è¡Œç¼“å­˜(dentry), åˆ†åˆ«ç§°ä¸º icache å’Œ dcache.
#+BEGIN_SRC c
static void __init dcache_init(void)
{
        unsigned int loop;

        /*
         ,* A constructor could be added for stable state like the lists,
         ,* but it is probably not worth it because of the cache nature
         ,* of the dcache.
         ,*/
        dentry_cache = KMEM_CACHE(dentry,
                                  SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD);

        /* Hash may have been set up in dcache_init_early */
        if (!hashdist)
                return;

        dentry_hashtable =
                alloc_large_system_hash("Dentry cache",
                                        sizeof(struct hlist_bl_head),
                                        dhash_entries,
                                        13,
                                        0,
                                        &d_hash_shift,
                                        &d_hash_mask,
                                        0,
                                        0);

        for (loop = 0; loop < (1U << d_hash_shift); loop++)
                INIT_HLIST_BL_HEAD(dentry_hashtable + loop);
}
void __init inode_init(void)
{
        unsigned int loop;

        /* inode slab cache */
        inode_cachep = kmem_cache_create("inode_cache",
                                         sizeof(struct inode),
                                         0,
                                         (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|
                                          SLAB_MEM_SPREAD),
                                         init_once);

        /* Hash may have been set up in inode_init_early */
        if (!hashdist)
                return;

        inode_hashtable =
                alloc_large_system_hash("Inode-cache",
                                        sizeof(struct hlist_head),
                                        ihash_entries,
                                        14,
                                        0,
                                        &i_hash_shift,
                                        &i_hash_mask,
                                        0,
                                        0);

        for (loop = 0; loop < (1U << i_hash_shift); loop++)
                INIT_HLIST_HEAD(&inode_hashtable[loop]);
}
#+END_SRC
æœ€ç»ˆè¿™äº›ç”³è¯·çš„ç¼“å­˜éƒ½æ˜¯å†…æ ¸é€šè¿‡LRUç®—æ³•è¿›è¡Œå›æ”¶çš„(å†…æ ¸é€šè¿‡ shrinkæ–¹æ³•æ¥å›æ”¶slabå†…å­˜)
- shrink æ–¹æ³•éœ€è¦é©±åŠ¨ç¼–å†™è€…æ¥ä¸»åŠ¨å®ç°
