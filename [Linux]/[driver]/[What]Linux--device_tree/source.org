#+TITLE: [What]linux -> kernel解析设备树
#+DATE:  <2018-06-28 四> 
#+TAGS: driver
#+LAYOUT: post 
#+CATEGORIES: linux, driver, devicetree
#+NAME: <linux_driver_devicetree_source.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}


参考文档: =/Documentation/devicetree/booting-without-of.txt=

了解内核如何解析设备树对于写驱动至关重要。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* bootloader 将设备树传递给kernel
** bootloader 到 kernel
对于arm来讲，其参数传递的状态具体说明位于 =/arch/arm/kernel/head.S= :
#+BEGIN_EXAMPLE
  /*
   ,* Kernel startup entry point.
   ,* ---------------------------
   ,*
   ,* This is normally called from the decompressor code.  The requirements
   ,* are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
   ,* r1 = machine nr, r2 = atags or dtb pointer.
   ,*
   ,* This code is mostly position independent, so if you link the kernel at
   ,* 0xc0008000, you call this at __pa(0xc0008000).
   ,*
   ,* See linux/arch/arm/tools/mach-types for the complete list of machine
   ,* numbers for r1.
   ,*
   ,* We're trying to keep crap to a minimum; DO NOT add any machine specific
   ,* crap here - that's what the boot loader (or in extreme, well justified
   ,* circumstances, zImage) is for.
   ,*/
#+END_EXAMPLE
对于uboot对应的代码位于 =/arch/arm/lib/bootm.c= :
#+BEGIN_SRC c
  static void boot_jump_linux(bootm_headers_t *images, int flag)
  {
  #ifdef CONFIG_ARM64
    ...
  #else
    //目标id
    unsigned long machid = gd->bd->bi_arch_number;
    char *s;
    //入口函数，分别传入 r0, r1, r2
    void (*kernel_entry)(int zero, int arch, uint params);
    unsigned long r2;
    int fake = (flag & BOOTM_STATE_OS_FAKE_GO);

    //得到kernel的入口点地址
    kernel_entry = (void (*)(int, int, uint))images->ep;

    s = getenv("machid");
    if (s) {
      if (strict_strtoul(s, 16, &machid) < 0) {
        debug("strict_strtoul failed!\n");
        return;
      }
      printf("Using machid 0x%lx from environment\n", machid);
    }

    debug("## Transferring control to Linux (at address %08lx)" \
      "...\n", (ulong) kernel_entry);
    bootstage_mark(BOOTSTAGE_ID_RUN_OS);
    announce_and_cleanup(fake);

    //得到设备树或taglist地址
    if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len)
      r2 = (unsigned long)images->ft_addr;
    else
      r2 = gd->bd->bi_boot_params;

    if (!fake) {
  #ifdef CONFIG_ARMV7_NONSEC
      ...
  #endif
      //PC指向此地址并运行，此时便进入了内核
        kernel_entry(0, machid, r2);
    }
  #endif
  }
#+END_SRC
** kernel获取到 r0,r1,r2

