#+TITLE: [What]linux -> ALSA 基本驱动实现
#+DATE:  <2018-04-08 Sun> 
#+TAGS: driver
#+LAYOUT: post 
#+CATEGORIES: linux, driver, ALSA
#+NAME: <linux_driver_ALSA_client.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

参考书籍: =Linux设备驱动开发详解=
参考文档: =Documentation/sound/alsa/soc=

整理ALSA在嵌入式Linux上的设备驱动实现。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 硬件连接与驱动
** 硬件连接
soc与外部音频芯片的连接如下图所示：

[[./audio_hw.jpg]]

根据 [[https://kcmetercec.github.io/2018/03/05/linux_driver_overview_structure/][Linux设备驱动思想]] 可以知道与硬件相关的软件包括以下几部分：
1. IIC控制器驱动(platform driver)以及其对应的设备树
2. IIC客户端驱动(i2c client)以及其对应的设备树
3. DMA控制器驱动(dma engine driver)以及其对应的设备树
4. IIS控制器驱动(platform driver)以及其对应的设备树
   + IIS的操作一般会与DMA结合，所以其设备树中会包含对应的DMA节点
5. 有关音频子系统的软件分层
** 驱动接口
Linux下使用了 [[https://www.alsa-project.org/main/index.php/Main_Page][ALSA]] 来完成音频部分的驱动接口，要完成驱动的编写需要完成的底层驱动有：
1. 音频芯片控制驱动(Codec class drivers)：对应于IIC客户端驱动，并完成ALSA所必要的接口
   + 此部分是完全与芯片相关的，不涉及任何SOC，所以可以复用到其他任意SOC
2. 数据流驱动/平台驱动(Platform class drivers): 对应于IIS控制器驱动(包含DMA客户端操作),并完成ALSA所必要的接口
   + 此部分是完全与SOC相关的，不涉及任何外部芯片，所有可以与各种符合接口的芯片连接
3. 板级驱动(Machine class driver): 用于将控制驱动和数据流驱动建立连接关系并完成ALSA所必要的接口
   + 此部分指明了连接关系，不同的开发板可能具有不同的连接情况

ALSA在总体上都使用一个信息结构体和一个回调函数结构体来抽象化以上3种驱动：
- 信息结构体(DAI)是为了驱动主动向核心层反应此设备的能力范围
- 回调函数结构体(ops)是为了告诉核心层此设备可以如何操作

如下图所示:
[[./alsa_overview.jpg]]

* 驱动中的概念
** DAPM(Dynamic Audio Power Management)
音频动态电源管理是为了在操作音频芯片期间，其功耗尽量的小。这整个过程是在 ASOC core 中完成的，不需要应用代码的干预。

与DAPM相关的部分有：
1. codec 相关控制
2. 平台/板级控制
3. 数字信号控制(Path domain)
4. DAC和ADC控制(Stream Domain):根据当前情况使能或关闭相应的AD/DA
*** DAPM 相关小部件(include/sound/soc-dapm.h)
DAPM将其可以控制的部分抽象为小部件以单独控制，使用 =enum snd_soc_dapm_type= 来定义：
#+BEGIN_SRC c
/* dapm widget types */
enum snd_soc_dapm_type {
        snd_soc_dapm_input = 0,/* input pin */
        snd_soc_dapm_output,/* output pin */
        snd_soc_dapm_mux,/* selects 1 analog signal from many inputs */
        snd_soc_dapm_demux,/* connects the input to one of multiple outputs */
        snd_soc_dapm_mixer,/* mixes several analog signals together */
        snd_soc_dapm_mixer_named_ctl,/* mixer with named controls */
        snd_soc_dapm_pga,/* programmable gain/attenuation (volume) */
        snd_soc_dapm_out_drv,/* output driver */
        snd_soc_dapm_adc,/* analog to digital converter */
        snd_soc_dapm_dac,/* digital to analog converter */
        snd_soc_dapm_micbias,/* microphone bias (power) */
        snd_soc_dapm_mic,/* microphone */
        snd_soc_dapm_hp,/* headphones */
        snd_soc_dapm_spk,/* speaker */
        snd_soc_dapm_line,/* line input/output */
        snd_soc_dapm_switch,/* analog switch */
        snd_soc_dapm_vmid,/* codec bias/vmid - to minimise pops */
        snd_soc_dapm_pre,/* machine specific pre widget - exec first */
        snd_soc_dapm_post,/* machine specific post widget - exec last */
        snd_soc_dapm_supply,/* power/clock supply */
        snd_soc_dapm_regulator_supply,/* external regulator */
        snd_soc_dapm_clock_supply,/* external clock */
        snd_soc_dapm_aif_in,/* audio interface input */
        snd_soc_dapm_aif_out,/* audio interface output */
        snd_soc_dapm_siggen,/* signal generator */
        snd_soc_dapm_dai_in,/* link to DAI structure */
        snd_soc_dapm_dai_out,
        snd_soc_dapm_dai_link,/* link between two DAI structures */
        snd_soc_dapm_kcontrol,/* Auto-disabled kcontrol */
};
#+END_SRC
*** 小部件的表示和连接
- 每个小部件是通过结构 =snd_soc_dapm_widget= 来表示的，ALSA提供了宏 =SND_SOC_DAPM_XXX= 来帮助用户快速的填充 =snd_soc_dapm_widget=.
- 小部件应该按照顺序连接，使用 =snd_soc_dapm_route= 来表示这个连接顺序，依次是 sink<-control<-sink 的顺序。
#+BEGIN_SRC c
static const struct snd_soc_dapm_widget ssm2518_dapm_widgets[] = {
        SND_SOC_DAPM_DAC("DACL", "HiFi Playback", SSM2518_REG_POWER2, 1, 1),
        SND_SOC_DAPM_DAC("DACR", "HiFi Playback", SSM2518_REG_POWER2, 2, 1),

        SND_SOC_DAPM_OUTPUT("OUTL"),
        SND_SOC_DAPM_OUTPUT("OUTR"),
};
//DACL -> OUTL DACR -> OUTR
static const struct snd_soc_dapm_route ssm2518_routes[] = {
        { "OUTL", NULL, "DACL" },
        { "OUTR", NULL, "DACR" },
};
...
static struct snd_soc_codec_driver ssm2518_codec_driver = {
        .set_bias_level = ssm2518_set_bias_level,
        .set_sysclk = ssm2518_set_sysclk,
        .idle_bias_off = true,

        .controls = ssm2518_snd_controls,
        .num_controls = ARRAY_SIZE(ssm2518_snd_controls),
        .dapm_widgets = ssm2518_dapm_widgets,
        .num_dapm_widgets = ARRAY_SIZE(ssm2518_dapm_widgets),
        .dapm_routes = ssm2518_routes,
        .num_dapm_routes = ARRAY_SIZE(ssm2518_routes),
};
...
return snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,
                              &ssm2518_dai, 1);
...
#+END_SRC
*** 与流相关的小部件
流相关的就是包括snd_soc_dapm_adc、snd_soc_dapm_dac、snd_soc_dapm_aif_in、snd_soc_dapm_aif_out 部件的控制。

与之相关的宏是：
#+BEGIN_SRC c
//部件名，流名，寄存器，寄存器位，是否翻转
SND_SOC_DAPM_DAC(wname, stname, wreg, wshift, winvert)
SND_SOC_DAPM_AIF_IN(wname, stname, wslot, wreg, wshift, winvert)

/**
 ,* @brief 示例
 ,*/
...
SND_SOC_DAPM_DAC("HiFi DAC", "HiFi Playback", REG, 3, 1),
SND_SOC_DAPM_ADC("HiFi ADC", "HiFi Capture", REG, 2, 1),
...
SND_SOC_DAPM_AIF_IN("AIF1RX", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
SND_SOC_DAPM_AIF_OUT("AIF1TX", "AIF1 Capture", 0, SND_SOC_NOPM, 0, 0),
...
#+END_SRC
*** 与数字信号相关小部件
数字信号部件控制音频信号流向，与之相关的宏是:
#+BEGIN_SRC c
SND_SOC_DAPM_PGA(wname, wreg, wshift, winvert,\
wcontrols, wncontrols)

/**
 ,* @brief : 示例设置混音
 ,*/
/* Output Mixer */
static const snd_kcontrol_new_t wm8731_output_mixer_controls[] = {
        SOC_DAPM_SINGLE("Line Bypass Switch", WM8731_APANA, 3, 1, 0),
        SOC_DAPM_SINGLE("Mic Sidetone Switch", WM8731_APANA, 5, 1, 0),
        SOC_DAPM_SINGLE("HiFi Playback Switch", WM8731_APANA, 4, 1, 0),
};
...
SND_SOC_DAPM_MIXER("Output Mixer", WM8731_PWR, 4, 1, wm8731_output_mixer_controls,
                   ARRAY_SIZE(wm8731_output_mixer_controls)),
...
#+END_SRC

*** 平台相关小部件
平台相关部件主要控制除音频芯片外的部分，比如扬声器。
#+BEGIN_SRC c
/**
 ,* @brief 当外部麦克风插入时，使能其偏置电压
 ,*/
static int spitz_mic_bias(struct snd_soc_dapm_widget* w, int event)
{
        gpio_set_value(SPITZ_GPIO_MIC_BIAS, SND_SOC_DAPM_EVENT_ON(event));
        return 0;
}
...
SND_SOC_DAPM_MIC("Mic Jack", spitz_mic_bias),
...
#+END_SRC
** DAI(Digital Audio Interface)
数字音频接口，因为平台驱动和芯片驱动分离，所以在这两个驱动下都需要提供这个接口的操作信息及回调函数，相当于各管各。
* 音频芯片驱动(Codec class driver)
从总体来说，音频芯片驱动需要告诉ALSA的是：
1. DAI(Digital Audio Interface) : 此部分告知ALSA该设备所具备的可操作参数范围
2. 芯片具体驱动代码: 此部分通过统一接口告知ALSA可以通过统一接口来具体操作设备

此驱动必须实现以下接口：
1. DAI(Digital Audio Interface) 和 PCM 配置
2. 芯片控制IO操作
3. 混音(mixer)及音频控制
4. 编解码器音频控制
5. DAPM描述
6. DAPM事件处理

可选的实现以下接口：
1. DAC数字静音控制
** DAI和PCM配置
内核使用 =snd_soc_dai_driver= 来表示DAI和PCM配置：
#+BEGIN_SRC c
struct snd_soc_dai_ops {
        /*
         ,* DAI clocking configuration, all optional.
         ,* Called by soc_card drivers, normally in their hw_params.
         ,*/
        int (*set_sysclk)(struct snd_soc_dai *dai,
                          int clk_id, unsigned int freq, int dir);
        int (*set_pll)(struct snd_soc_dai *dai, int pll_id, int source,
                       unsigned int freq_in, unsigned int freq_out);
        int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
        int (*set_bclk_ratio)(struct snd_soc_dai *dai, unsigned int ratio);

        /*
         ,* DAI format configuration
         ,* Called by soc_card drivers, normally in their hw_params.
         ,*/
        int (*set_fmt)(struct snd_soc_dai *dai, unsigned int fmt);
        int (*xlate_tdm_slot_mask)(unsigned int slots,
                                   unsigned int *tx_mask, unsigned int *rx_mask);
        int (*set_tdm_slot)(struct snd_soc_dai *dai,
                            unsigned int tx_mask, unsigned int rx_mask,
                            int slots, int slot_width);
        int (*set_channel_map)(struct snd_soc_dai *dai,
                               unsigned int tx_num, unsigned int *tx_slot,
                               unsigned int rx_num, unsigned int *rx_slot);
        int (*set_tristate)(struct snd_soc_dai *dai, int tristate);

        /*
         ,* DAI digital mute - optional.
         ,* Called by soc-core to minimise any pops.
         ,*/
        int (*digital_mute)(struct snd_soc_dai *dai, int mute);
        int (*mute_stream)(struct snd_soc_dai *dai, int mute, int stream);

        /*
         ,* ALSA PCM audio operations - all optional.
         ,* Called by soc-core during audio PCM operations.
         ,*/
        int (*startup)(struct snd_pcm_substream *,
                       struct snd_soc_dai *);
        void (*shutdown)(struct snd_pcm_substream *,
                         struct snd_soc_dai *);
        int (*hw_params)(struct snd_pcm_substream *,
                         struct snd_pcm_hw_params *, struct snd_soc_dai *);
        int (*hw_free)(struct snd_pcm_substream *,
                       struct snd_soc_dai *);
        int (*prepare)(struct snd_pcm_substream *,
                       struct snd_soc_dai *);
        /*
         ,* NOTE: Commands passed to the trigger function are not necessarily
         ,* compatible with the current state of the dai. For example this
         ,* sequence of commands is possible: START STOP STOP.
         ,* So do not unconditionally use refcounting functions in the trigger
         ,* function, e.g. clk_enable/disable.
         ,*/
        int (*trigger)(struct snd_pcm_substream *, int,
                       struct snd_soc_dai *);
        int (*bespoke_trigger)(struct snd_pcm_substream *, int,
                               struct snd_soc_dai *);
        /*
         ,* For hardware based FIFO caused delay reporting.
         ,* Optional.
         ,*/
        snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *,
                                   struct snd_soc_dai *);
};
/* SoC PCM stream information */
struct snd_soc_pcm_stream {
        const char *stream_name;
        u64 formats;/* SNDRV_PCM_FMTBIT_* */
        unsigned int rates;/* SNDRV_PCM_RATE_* */
        unsigned int rate_min;/* min rate */
        unsigned int rate_max;/* max rate */
        unsigned int channels_min;/* min channels */
        unsigned int channels_max;/* max channels */
        unsigned int sig_bits;/* number of bits of content */
};
/*
 ,* Digital Audio Interface Driver.
 ,*
 ,* Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97
 ,* operations and capabilities. Codec and platform drivers will register this
 ,* structure for every DAI they have.
 ,*
 ,* This structure covers the clocking, formating and ALSA operations for each
 ,* interface.
 ,*/
struct snd_soc_dai_driver {
        /* DAI description */
        const char *name;
        unsigned int id;
        unsigned int base;

        /* DAI driver callbacks */
        int (*probe)(struct snd_soc_dai *dai);
        int (*remove)(struct snd_soc_dai *dai);
        int (*suspend)(struct snd_soc_dai *dai);
        int (*resume)(struct snd_soc_dai *dai);
        /* compress dai */
        int (*compress_new)(struct snd_soc_pcm_runtime *rtd, int num);
        /* DAI is also used for the control bus */
        bool bus_control;

        /* ops */
        const struct snd_soc_dai_ops *ops;

        /* DAI capabilities */
        struct snd_soc_pcm_stream capture;
        struct snd_soc_pcm_stream playback;
        unsigned int symmetric_rates:1;
        unsigned int symmetric_channels:1;
        unsigned int symmetric_samplebits:1;

        /* probe ordering - for components with runtime dependencies */
        int probe_order;
        int remove_order;
};
#+END_SRC
比如：
#+BEGIN_SRC c
#define SSM2518_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
                         SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32)

static const struct snd_soc_dai_ops ssm2518_dai_ops = {
        .startup = ssm2518_startup,
        .hw_params= ssm2518_hw_params,
        .digital_mute= ssm2518_mute,
        .set_fmt= ssm2518_set_dai_fmt,
        .set_tdm_slot= ssm2518_set_tdm_slot,
};
static struct snd_soc_dai_driver ssm2518_dai = {
        .name = "ssm2518-hifi",
        .playback = {
                .stream_name = "Playback",
                .channels_min = 2,
                .channels_max = 2,
                .rates = SNDRV_PCM_RATE_8000_96000,
                .formats = SSM2518_FORMATS,
        },
        .ops = &ssm2518_dai_ops,
};

...
return snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,
                              &ssm2518_dai, 1);
...
#+END_SRC
** 芯片控制IO操作
使用 =include/linux/regmap.h= 中的regmap来操作设备。
#+BEGIN_SRC c
...
ssm2518->regmap = devm_regmap_init_i2c(i2c, &ssm2518_regmap_config);
if (IS_ERR(ssm2518->regmap))
        return PTR_ERR(ssm2518->regmap);
...
ret = regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL1, ctrl1);
if (ret)
        return ret;
#+END_SRC
** 混音及音频控制 
所有的混音及音频控制都是使用宏来描述,存储于 =snd_kcontrol_new= 结构中:
#+BEGIN_SRC c
//名称,寄存器,寄存器位,屏蔽位,是否倒叙或反转
#define SOC_SINGLE(xname, reg, shift, max, invert) ...
#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) ...
#+END_SRC
比如:
#+BEGIN_SRC c
static const struct snd_kcontrol_new ssm2518_snd_controls[] = {
        SOC_SINGLE("Playback De-emphasis Switch", SSM2518_REG_MUTE_CTRL,
                   4, 1, 0),
        SOC_DOUBLE_R_TLV("Master Playback Volume", SSM2518_REG_LEFT_VOL,
                         SSM2518_REG_RIGHT_VOL, 0, 0xff, 1, ssm2518_vol_tlv),
        SOC_DOUBLE("Master Playback Switch", SSM2518_REG_MUTE_CTRL, 2, 1, 1, 1),

        SOC_SINGLE("Amp Low Power Mode Switch", SSM2518_REG_POWER2, 4, 1, 0),
        SOC_SINGLE("DAC Low Power Mode Switch", SSM2518_REG_POWER2, 3, 1, 0),

        SOC_SINGLE("DRC Limiter Switch", SSM2518_REG_DRC_1, 5, 1, 0),
        SOC_SINGLE("DRC Compressor Switch", SSM2518_REG_DRC_1, 4, 1, 0),
        SOC_SINGLE("DRC Expander Switch", SSM2518_REG_DRC_1, 3, 1, 0),
        SOC_SINGLE("DRC Noise Gate Switch", SSM2518_REG_DRC_1, 2, 1, 0),
        SOC_DOUBLE("DRC Switch", SSM2518_REG_DRC_1, 0, 1, 1, 0),

        SOC_SINGLE_TLV("DRC Limiter Threshold Volume",
                       SSM2518_REG_DRC_3, 4, 15, 1, ssm2518_limiter_tlv),
        SOC_SINGLE_TLV("DRC Compressor Lower Threshold Volume",
                       SSM2518_REG_DRC_3, 0, 15, 1, ssm2518_compressor_tlv),
        SOC_SINGLE_TLV("DRC Expander Upper Threshold Volume", SSM2518_REG_DRC_4,
                       4, 15, 1, ssm2518_expander_tlv),
        SOC_SINGLE_TLV("DRC Noise Gate Threshold Volume",
                       SSM2518_REG_DRC_4, 0, 15, 1, ssm2518_noise_gate_tlv),
        SOC_SINGLE_TLV("DRC Upper Output Threshold Volume",
                       SSM2518_REG_DRC_5, 4, 15, 1, ssm2518_limiter_tlv),
        SOC_SINGLE_TLV("DRC Lower Output Threshold Volume",
                       SSM2518_REG_DRC_5, 0, 15, 1, ssm2518_noise_gate_tlv),
        SOC_SINGLE_TLV("DRC Post Volume", SSM2518_REG_DRC_8,
                       2, 15, 1, ssm2518_post_drc_tlv),

        SOC_ENUM("DRC Peak Detector Attack Time",
                 ssm2518_drc_peak_detector_attack_time_enum),
        SOC_ENUM("DRC Peak Detector Release Time",
                 ssm2518_drc_peak_detector_release_time_enum),
        SOC_ENUM("DRC Attack Time", ssm2518_drc_attack_time_enum),
        SOC_ENUM("DRC Decay Time", ssm2518_drc_decay_time_enum),
        SOC_ENUM("DRC Hold Time", ssm2518_drc_hold_time_enum),
        SOC_ENUM("DRC Noise Gate Hold Time",
                 ssm2518_drc_noise_gate_hold_time_enum),
        SOC_ENUM("DRC RMS Averaging Time", ssm2518_drc_rms_averaging_time_enum),
};
static struct snd_soc_codec_driver ssm2518_codec_driver = {
        .set_bias_level = ssm2518_set_bias_level,
        .set_sysclk = ssm2518_set_sysclk,
        .idle_bias_off = true,

        .controls = ssm2518_snd_controls,
        .num_controls = ARRAY_SIZE(ssm2518_snd_controls),
        .dapm_widgets = ssm2518_dapm_widgets,
        .num_dapm_widgets = ARRAY_SIZE(ssm2518_dapm_widgets),
        .dapm_routes = ssm2518_routes,
        .num_dapm_routes = ARRAY_SIZE(ssm2518_routes),
};
return snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,
                              &ssm2518_dai, 1);

#+END_SRC
** 编解码控制
使用 =snd_soc_ops= 来表示控制操作:
#+BEGIN_SRC c
/* SoC audio ops */
struct snd_soc_ops {
        int (*startup)(struct snd_pcm_substream *);
        void (*shutdown)(struct snd_pcm_substream *);
        int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
        int (*hw_free)(struct snd_pcm_substream *);
        int (*prepare)(struct snd_pcm_substream *);
        int (*trigger)(struct snd_pcm_substream *, int);
};
#+END_SRC
** DAPM描述
** DAPM事件处理
通过回调函数来处理这个过程。
** DAC数字静音控制
也是通过回调函数来处理此过程。
#+BEGIN_SRC c
static int wm8974_mute(struct snd_soc_dai *dai, int mute)
{
        struct snd_soc_codec *codec = dai->codec;
        u16 mute_reg = snd_soc_read(codec, WM8974_DAC) & 0xffbf;

        if (mute)
                snd_soc_write(codec, WM8974_DAC, mute_reg | 0x40);
        else
                snd_soc_write(codec, WM8974_DAC, mute_reg);
        return 0;
}
#+END_SRC
** 实例
参考 [[https://elixir.bootlin.com/linux/v4.4/source/sound/soc/codecs/ssm2518.c][/sound/soc/codecs/ssm2518.c]]
* 平台驱动
平台驱动主要由DMA操作和DAI接口操作组成,分别用于产生数据流和告知上层平台接口的能力。
** DMA 操作
DMA操作需要填充结构体 =snd_soc_platform_driver= 
#+BEGIN_SRC c
/**
 ,* @brief pcm 流操作类
 ,* @param open: 当PCM流被打开时调用
 ,* @param close: 当PCM流被关闭时调用
 ,* @param ioctl: 与上层 snd_pcm_lib_ioctl() 函数对应
 ,* @param hw_params: 设置硬件参数
 ,* @param hw_free: 释放由 hw_params() 分配的资源
 ,* @param prepare: PCM被准备(snd_pcm_prepare())时调用，可以设置采样率、格式等
 ,* @param trigger: 控制PCM的开始、停止或暂停
 ,* @param pointer: 查询目前缓冲区的硬件位置
 ,*/
struct snd_pcm_ops {
        int (*open)(struct snd_pcm_substream *substream);
        int (*close)(struct snd_pcm_substream *substream);
        int (*ioctl)(struct snd_pcm_substream * substream,
                     unsigned int cmd, void *arg);
        int (*hw_params)(struct snd_pcm_substream *substream,
                         struct snd_pcm_hw_params *params);
        int (*hw_free)(struct snd_pcm_substream *substream);
        int (*prepare)(struct snd_pcm_substream *substream);
        int (*trigger)(struct snd_pcm_substream *substream, int cmd);
        snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
        int (*get_time_info)(struct snd_pcm_substream *substream,
                             struct timespec *system_ts, struct timespec *audio_ts,
                             struct snd_pcm_audio_tstamp_config *audio_tstamp_config,
                             struct snd_pcm_audio_tstamp_report *audio_tstamp_report);
        int (*copy)(struct snd_pcm_substream *substream, int channel,
                    snd_pcm_uframes_t pos,
                    void __user *buf, snd_pcm_uframes_t count);
        int (*silence)(struct snd_pcm_substream *substream, int channel,
                       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
        struct page *(*page)(struct snd_pcm_substream *substream,
                             unsigned long offset);
        int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);
        int (*ack)(struct snd_pcm_substream *substream);
};
/* SoC platform interface */
struct snd_soc_platform_driver {

        int (*probe)(struct snd_soc_platform *);
        int (*remove)(struct snd_soc_platform *);
        struct snd_soc_component_driver component_driver;

        /* pcm creation and destruction */
        int (*pcm_new)(struct snd_soc_pcm_runtime *);
        void (*pcm_free)(struct snd_pcm *);

        /*
         ,* For platform caused delay reporting.
         ,* Optional.
         ,*/
        snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *,
                                   struct snd_soc_dai *);

        /* platform stream pcm ops */
        const struct snd_pcm_ops *ops;

        /* platform stream compress ops */
        const struct snd_compr_ops *compr_ops;

        int (*bespoke_trigger)(struct snd_pcm_substream *, int);
};
#+END_SRC
** DAI接口
与音频芯片类似，只是它描述的是CPU这边的DAI接口说明。
** 实例(axi-i2s.c)
#+BEGIN_SRC c
/*
 ,* Copyright (C) 2012-2013, Analog Devices Inc.
 ,* Author: Lars-Peter Clausen <lars@metafoo.de>
 ,*
 ,* Licensed under the GPL-2.
 ,*/

#include <linux/clk.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/platform_device.h>
#include <linux/regmap.h>
#include <linux/slab.h>

#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/dmaengine_pcm.h>

#define AXI_I2S_REG_RESET0x00
#define AXI_I2S_REG_CTRL0x04
#define AXI_I2S_REG_CLK_CTRL0x08
#define AXI_I2S_REG_STATUS0x10

#define AXI_I2S_REG_RX_FIFO0x28
#define AXI_I2S_REG_TX_FIFO0x2C

#define AXI_I2S_RESET_GLOBALBIT(0)
#define AXI_I2S_RESET_TX_FIFOBIT(1)
#define AXI_I2S_RESET_RX_FIFOBIT(2)

#define AXI_I2S_CTRL_TX_ENBIT(0)
#define AXI_I2S_CTRL_RX_ENBIT(1)

/* The frame size is configurable, but for now we always set it 64 bit */
#define AXI_I2S_BITS_PER_FRAME 64

struct axi_i2s {
        struct regmap *regmap;
        struct clk *clk;
        struct clk *clk_ref;

        struct snd_soc_dai_driver dai_driver;

        struct snd_dmaengine_dai_dma_data capture_dma_data;
        struct snd_dmaengine_dai_dma_data playback_dma_data;

        struct snd_ratnum ratnum;
        struct snd_pcm_hw_constraint_ratnums rate_constraints;
};

static int axi_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
                           struct snd_soc_dai *dai)
{
        struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
        unsigned int mask, val;

        if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
                mask = AXI_I2S_CTRL_RX_EN;
        else
                mask = AXI_I2S_CTRL_TX_EN;

        switch (cmd) {
        case SNDRV_PCM_TRIGGER_START:
        case SNDRV_PCM_TRIGGER_RESUME:
        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
                val = mask;
                break;
        case SNDRV_PCM_TRIGGER_STOP:
        case SNDRV_PCM_TRIGGER_SUSPEND:
        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
                val = 0;
                break;
        default:
                return -EINVAL;
        }

        regmap_update_bits(i2s->regmap, AXI_I2S_REG_CTRL, mask, val);

        return 0;
}

static int axi_i2s_hw_params(struct snd_pcm_substream *substream,
                             struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
{
        struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
        unsigned int bclk_div, word_size;
        unsigned int bclk_rate;

        bclk_rate = params_rate(params) * AXI_I2S_BITS_PER_FRAME;

        word_size = AXI_I2S_BITS_PER_FRAME / 2 - 1;
        bclk_div = DIV_ROUND_UP(clk_get_rate(i2s->clk_ref), bclk_rate) / 2 - 1;

        regmap_write(i2s->regmap, AXI_I2S_REG_CLK_CTRL, (word_size << 16) |
                     bclk_div);

        return 0;
}

static int axi_i2s_startup(struct snd_pcm_substream *substream,
                           struct snd_soc_dai *dai)
{
        struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);
        uint32_t mask;
        int ret;

        if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
                mask = AXI_I2S_RESET_RX_FIFO;
        else
                mask = AXI_I2S_RESET_TX_FIFO;

        regmap_write(i2s->regmap, AXI_I2S_REG_RESET, mask);

        ret = snd_pcm_hw_constraint_ratnums(substream->runtime, 0,
                                            SNDRV_PCM_HW_PARAM_RATE,
                                            &i2s->rate_constraints);
        if (ret)
                return ret;

        return clk_prepare_enable(i2s->clk_ref);
}

static void axi_i2s_shutdown(struct snd_pcm_substream *substream,
                             struct snd_soc_dai *dai)
{
        struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);

        clk_disable_unprepare(i2s->clk_ref);
}

static int axi_i2s_dai_probe(struct snd_soc_dai *dai)
{
        struct axi_i2s *i2s = snd_soc_dai_get_drvdata(dai);

        snd_soc_dai_init_dma_data(dai, &i2s->playback_dma_data,
                                  &i2s->capture_dma_data);

        return 0;
}

static const struct snd_soc_dai_ops axi_i2s_dai_ops = {
        .startup = axi_i2s_startup,
        .shutdown = axi_i2s_shutdown,
        .trigger = axi_i2s_trigger,
        .hw_params = axi_i2s_hw_params,
};

static struct snd_soc_dai_driver axi_i2s_dai = {
        .probe = axi_i2s_dai_probe,
        .playback = {
                .channels_min = 2,
                .channels_max = 2,
                .rates = SNDRV_PCM_RATE_KNOT,
                .formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_U32_LE,
        },
        .capture = {
                .channels_min = 2,
                .channels_max = 2,
                .rates = SNDRV_PCM_RATE_KNOT,
                .formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_U32_LE,
        },
        .ops = &axi_i2s_dai_ops,
        .symmetric_rates = 1,
};

static const struct snd_soc_component_driver axi_i2s_component = {
        .name = "axi-i2s",
};

static const struct regmap_config axi_i2s_regmap_config = {
        .reg_bits = 32,
        .reg_stride = 4,
        .val_bits = 32,
        .max_register = AXI_I2S_REG_STATUS,
};

static int axi_i2s_probe(struct platform_device *pdev)
{
        struct resource *res;
        struct axi_i2s *i2s;
        void __iomem *base;
        int ret;

        i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
        if (!i2s)
                return -ENOMEM;

        platform_set_drvdata(pdev, i2s);

        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
        base = devm_ioremap_resource(&pdev->dev, res);
        if (IS_ERR(base))
                return PTR_ERR(base);

        i2s->regmap = devm_regmap_init_mmio(&pdev->dev, base,
                                            &axi_i2s_regmap_config);
        if (IS_ERR(i2s->regmap))
                return PTR_ERR(i2s->regmap);

        i2s->clk = devm_clk_get(&pdev->dev, "axi");
        if (IS_ERR(i2s->clk))
                return PTR_ERR(i2s->clk);

        i2s->clk_ref = devm_clk_get(&pdev->dev, "ref");
        if (IS_ERR(i2s->clk_ref))
                return PTR_ERR(i2s->clk_ref);

        ret = clk_prepare_enable(i2s->clk);
        if (ret)
                return ret;

        i2s->playback_dma_data.addr = res->start + AXI_I2S_REG_TX_FIFO;
        i2s->playback_dma_data.addr_width = 4;
        i2s->playback_dma_data.maxburst = 1;

        i2s->capture_dma_data.addr = res->start + AXI_I2S_REG_RX_FIFO;
        i2s->capture_dma_data.addr_width = 4;
        i2s->capture_dma_data.maxburst = 1;

        i2s->ratnum.num = clk_get_rate(i2s->clk_ref) / 2 / AXI_I2S_BITS_PER_FRAME;
        i2s->ratnum.den_step = 1;
        i2s->ratnum.den_min = 1;
        i2s->ratnum.den_max = 64;

        i2s->rate_constraints.rats = &i2s->ratnum;
        i2s->rate_constraints.nrats = 1;

        regmap_write(i2s->regmap, AXI_I2S_REG_RESET, AXI_I2S_RESET_GLOBAL);

        ret = devm_snd_soc_register_component(&pdev->dev, &axi_i2s_component,
                                              &axi_i2s_dai, 1);
        if (ret)
                goto err_clk_disable;

        ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
        if (ret)
                goto err_clk_disable;

        return 0;

err_clk_disable:
        clk_disable_unprepare(i2s->clk);
        return ret;
}

static int axi_i2s_dev_remove(struct platform_device *pdev)
{
        struct axi_i2s *i2s = platform_get_drvdata(pdev);

        clk_disable_unprepare(i2s->clk);

        return 0;
}

static const struct of_device_id axi_i2s_of_match[] = {
        { .compatible = "adi,axi-i2s-1.00.a", },
        {},
};
MODULE_DEVICE_TABLE(of, axi_i2s_of_match);

static struct platform_driver axi_i2s_driver = {
        .driver = {
                .name = "axi-i2s",
                .of_match_table = axi_i2s_of_match,
        },
        .probe = axi_i2s_probe,
        .remove = axi_i2s_dev_remove,
};
module_platform_driver(axi_i2s_driver);

MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
MODULE_DESCRIPTION("AXI I2S driver");
MODULE_LICENSE("GPL");
#+END_SRC
* 板级驱动
板级驱动用于将芯片驱动和平台驱动连接在一起，并且还用来描述其他附加信息。

** 声卡的表示
使用 =snd_soc_card= 来表示一个声卡：
#+BEGIN_SRC c
/* SoC card */
struct snd_soc_card {
        const char *name;
        const char *long_name;
        const char *driver_name;
        struct device *dev;
        struct snd_card *snd_card;
        struct module *owner;

        struct mutex mutex;
        struct mutex dapm_mutex;

        bool instantiated;

        int (*probe)(struct snd_soc_card *card);
        int (*late_probe)(struct snd_soc_card *card);
        int (*remove)(struct snd_soc_card *card);

        /* the pre and post PM functions are used to do any PM work before and
         ,* after the codec and DAI's do any PM work. */
        int (*suspend_pre)(struct snd_soc_card *card);
        int (*suspend_post)(struct snd_soc_card *card);
        int (*resume_pre)(struct snd_soc_card *card);
        int (*resume_post)(struct snd_soc_card *card);

        /* callbacks */
        int (*set_bias_level)(struct snd_soc_card *,
                              struct snd_soc_dapm_context *dapm,
                              enum snd_soc_bias_level level);
        int (*set_bias_level_post)(struct snd_soc_card *,
                                   struct snd_soc_dapm_context *dapm,
                                   enum snd_soc_bias_level level);

        long pmdown_time;

        /* CPU <--> Codec DAI links  */
        struct snd_soc_dai_link *dai_link;
        int num_links;
        struct snd_soc_pcm_runtime *rtd;
        int num_rtd;

        /* optional codec specific configuration */
        struct snd_soc_codec_conf *codec_conf;
        int num_configs;

        /*
         ,* optional auxiliary devices such as amplifiers or codecs with DAI
         ,* link unused
         ,*/
        struct snd_soc_aux_dev *aux_dev;
        int num_aux_devs;
        struct snd_soc_pcm_runtime *rtd_aux;
        int num_aux_rtd;

        const struct snd_kcontrol_new *controls;
        int num_controls;

        /*
         ,* Card-specific routes and widgets.
         ,* Note: of_dapm_xxx for Device Tree; Otherwise for driver build-in.
         ,*/
        const struct snd_soc_dapm_widget *dapm_widgets;
        int num_dapm_widgets;
        const struct snd_soc_dapm_route *dapm_routes;
        int num_dapm_routes;
        const struct snd_soc_dapm_widget *of_dapm_widgets;
        int num_of_dapm_widgets;
        const struct snd_soc_dapm_route *of_dapm_routes;
        int num_of_dapm_routes;
        bool fully_routed;

        struct work_struct deferred_resume_work;

        /* lists of probed devices belonging to this card */
        struct list_head codec_dev_list;

        struct list_head widgets;
        struct list_head paths;
        struct list_head dapm_list;
        struct list_head dapm_dirty;

        /* attached dynamic objects */
        struct list_head dobj_list;

        /* Generic DAPM context for the card */
        struct snd_soc_dapm_context dapm;
        struct snd_soc_dapm_stats dapm_stats;
        struct snd_soc_dapm_update *update;

        #ifdef CONFIG_DEBUG_FS
        struct dentry *debugfs_card_root;
        struct dentry *debugfs_pop_time;
        #endif
        u32 pop_time;

        void *drvdata;
};
#+END_SRC
** 板级DAI配置
板级DAI配置将所有的设备驱动和平台驱动连接在一起， =snd_soc_dai_link= 用于连接二者：
#+BEGIN_SRC c
struct snd_soc_dai_link {
        /* config - must be set by machine driver */
        const char *name;/* Codec name */
        const char *stream_name;/* Stream name */
        /*
         ,* You MAY specify the link's CPU-side device, either by device name,
         ,* or by DT/OF node, but not both. If this information is omitted,
         ,* the CPU-side DAI is matched using .cpu_dai_name only, which hence
         ,* must be globally unique. These fields are currently typically used
         ,* only for codec to codec links, or systems using device tree.
         ,*/
        const char *cpu_name;
        struct device_node *cpu_of_node;
        /*
         ,* You MAY specify the DAI name of the CPU DAI. If this information is
         ,* omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node
         ,* only, which only works well when that device exposes a single DAI.
         ,*/
        const char *cpu_dai_name;
        /*
         ,* You MUST specify the link's codec, either by device name, or by
         ,* DT/OF node, but not both.
         ,*/
        const char *codec_name;
        struct device_node *codec_of_node;
        /* You MUST specify the DAI name within the codec */
        const char *codec_dai_name;

        struct snd_soc_dai_link_component *codecs;
        unsigned int num_codecs;

        /*
         ,* You MAY specify the link's platform/PCM/DMA driver, either by
         ,* device name, or by DT/OF node, but not both. Some forms of link
         ,* do not need a platform.
         ,*/
        const char *platform_name;
        struct device_node *platform_of_node;
        int be_id;/* optional ID for machine driver BE identification */

        const struct snd_soc_pcm_stream *params;
        unsigned int num_params;

        unsigned int dai_fmt;           /* format to set on init */

        enum snd_soc_dpcm_trigger trigger[2]; /* trigger type for DPCM */

        /* codec/machine specific init - e.g. add machine controls */
        int (*init)(struct snd_soc_pcm_runtime *rtd);

        /* optional hw_params re-writing for BE and FE sync */
        int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,
                                  struct snd_pcm_hw_params *params);

        /* machine stream operations */
        const struct snd_soc_ops *ops;
        const struct snd_soc_compr_ops *compr_ops;

        /* For unidirectional dai links */
        bool playback_only;
        bool capture_only;

        /* Mark this pcm with non atomic ops */
        bool nonatomic;

        /* Keep DAI active over suspend */
        unsigned int ignore_suspend:1;

        /* Symmetry requirements */
        unsigned int symmetric_rates:1;
        unsigned int symmetric_channels:1;
        unsigned int symmetric_samplebits:1;

        /* Do not create a PCM for this DAI link (Backend link) */
        unsigned int no_pcm:1;

        /* This DAI link can route to other DAI links at runtime (Frontend)*/
        unsigned int dynamic:1;

        /* DPCM capture and Playback support */
        unsigned int dpcm_capture:1;
        unsigned int dpcm_playback:1;

        /* DPCM used FE & BE merged format */
        unsigned int dpcm_merged_format:1;

        /* pmdown_time is ignored at stop */
        unsigned int ignore_pmdown_time:1;
};
#+END_SRC
比如：
#+BEGIN_SRC c
/* corgi digital audio interface glue - connects codec <--> CPU */
static struct snd_soc_dai_link corgi_dai = {
        .name = "WM8731",
        .stream_name = "WM8731",
        .cpu_dai_name = "pxa-is2-dai",
        .codec_dai_name = "wm8731-hifi",
        .platform_name = "pxa-pcm-audio",
        .codec_name = "wm8713-codec.0-001a",
        .init = corgi_wm8731_init,
        .ops = &corgi_ops,
};
/* corgi audio machine driver */
static struct snd_soc_card snd_soc_corgi = {
        .name = "Corgi",
        .dai_link = &corgi_dai,
        .num_links = 1,
};
#+END_SRC
** 实例(zed_adau1761.c)
#+BEGIN_SRC c
/*
 ,*  Copyright (C) 2012-2013, Analog Devices Inc.
 ,*Author: Lars-Peter Clausen <lars@metafoo.de>
 ,*
 ,*  This program is free software; you can redistribute it and/or modify it
 ,*  under  the terms of the GNU General  Public License as published by the
 ,*  Free Software Foundation;  either version 2 of the License, or (at your
 ,*  option) any later version.
 ,*
 ,*  You should have received a copy of the GNU General Public License along
 ,*  with this program; if not, write to the Free Software Foundation, Inc.,
 ,*  675 Mass Ave, Cambridge, MA 02139, USA.
 ,*
 ,*/

#include <linux/module.h>
#include <linux/timer.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/soc.h>
#include "../codecs/adau17x1.h"

static const struct snd_soc_dapm_widget zed_adau1761_widgets[] = {
        SND_SOC_DAPM_SPK("Line Out", NULL),
        SND_SOC_DAPM_HP("Headphone Out", NULL),
        SND_SOC_DAPM_MIC("Mic In", NULL),
        SND_SOC_DAPM_MIC("Line In", NULL),
};

static const struct snd_soc_dapm_route zed_adau1761_routes[] = {
        { "Line Out", NULL, "LOUT" },
        { "Line Out", NULL, "ROUT" },
        { "Headphone Out", NULL, "LHP" },
        { "Headphone Out", NULL, "RHP" },
        { "Mic In", NULL, "MICBIAS" },
        { "LINN", NULL, "Mic In" },
        { "RINN", NULL, "Mic In" },
        { "LAUX", NULL, "Line In" },
        { "RAUX", NULL, "Line In" },
};

static int zed_adau1761_hw_params(struct snd_pcm_substream *substream,
                                  struct snd_pcm_hw_params *params)
{
        struct snd_soc_pcm_runtime *rtd = substream->private_data;
        struct snd_soc_dai *codec_dai = rtd->codec_dai;
        unsigned int pll_rate;
        int ret;

        switch (params_rate(params)) {
        case 48000:
        case 8000:
        case 12000:
        case 16000:
        case 24000:
        case 32000:
        case 96000:
                pll_rate = 48000 * 1024;
                break;
        case 44100:
        case 7350:
        case 11025:
        case 14700:
        case 22050:
        case 29400:
        case 88200:
                pll_rate = 44100 * 1024;
                break;
        default:
                return -EINVAL;
        }

        ret = snd_soc_dai_set_pll(codec_dai, ADAU17X1_PLL,
                                  ADAU17X1_PLL_SRC_MCLK, 12288000, pll_rate);
        if (ret)
                return ret;

        ret = snd_soc_dai_set_sysclk(codec_dai, ADAU17X1_CLK_SRC_PLL, pll_rate,
                                     SND_SOC_CLOCK_IN);

        return ret;
}

static struct snd_soc_ops zed_adau1761_ops = {
        .hw_params = zed_adau1761_hw_params,
};

static struct snd_soc_dai_link zed_adau1761_dai_link = {
        .name = "adau1761",
        .stream_name = "adau1761",
        .codec_dai_name = "adau-hifi",
        .dai_fmt = SND_SOC_DAIFMT_I2S |
        SND_SOC_DAIFMT_NB_NF |
        SND_SOC_DAIFMT_CBS_CFS,
        .ops = &zed_adau1761_ops,
};

static struct snd_soc_card zed_adau1761_card = {
        .name = "ZED ADAU1761",
        .owner = THIS_MODULE,
        .dai_link = &zed_adau1761_dai_link,
        .num_links = 1,
        .dapm_widgets = zed_adau1761_widgets,
        .num_dapm_widgets = ARRAY_SIZE(zed_adau1761_widgets),
        .dapm_routes = zed_adau1761_routes,
        .num_dapm_routes = ARRAY_SIZE(zed_adau1761_routes),
        .fully_routed = true,
};

static int zed_adau1761_probe(struct platform_device *pdev)
{
        struct snd_soc_card *card = &zed_adau1761_card;
        struct device_node *of_node = pdev->dev.of_node;

        if (!of_node)
                return -ENXIO;

        card->dev = &pdev->dev;

        zed_adau1761_dai_link.codec_of_node = of_parse_phandle(of_node, "audio-codec", 0);
        zed_adau1761_dai_link.cpu_of_node = of_parse_phandle(of_node, "cpu-dai", 0);
        zed_adau1761_dai_link.platform_of_node = zed_adau1761_dai_link.cpu_of_node;

        if (!zed_adau1761_dai_link.codec_of_node ||
            !zed_adau1761_dai_link.cpu_of_node)
                return -ENXIO;

        return snd_soc_register_card(card);
}

static int zed_adau1761_remove(struct platform_device *pdev)
{
        struct snd_soc_card *card = platform_get_drvdata(pdev);

        snd_soc_unregister_card(card);

        return 0;
}

static const struct of_device_id zed_adau1761_of_match[] = {
        { .compatible = "digilent,zed-sound", },
        {},
};
MODULE_DEVICE_TABLE(of, zed_adau1761_of_match);

static struct platform_driver zed_adau1761_card_driver = {
        .driver = {
                .name = "zed-adau1761-snd",
                .owner = THIS_MODULE,
                .of_match_table = zed_adau1761_of_match,
                .pm = &snd_soc_pm_ops,
        },
        .probe = zed_adau1761_probe,
        .remove = zed_adau1761_remove,
};
module_platform_driver(zed_adau1761_card_driver);

MODULE_DESCRIPTION("ASoC ZED board ADAU1761 driver");
MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:zed-adau1761-snd");
#+END_SRC
