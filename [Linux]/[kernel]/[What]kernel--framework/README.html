<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>README</title>
<!-- 2017-11-21 Tue 16:09 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="cec" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">README</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. [What] kernel &#x2013;&gt; framework</a>
<ul>
<li><a href="#sec-1-1">1.1. 时钟管理子系统(clock)</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. driver 使用通用API(clock consumer)</a></li>
<li><a href="#sec-1-1-2">1.1.2. 编写 clock 通用逻辑(clock provider)</a></li>
<li><a href="#sec-1-1-3">1.1.3. 编写底层逻辑</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. I2C子系统</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. 总体概览</a></li>
<li><a href="#sec-1-2-2">1.2.2. 控制器驱动的编写</a></li>
<li><a href="#sec-1-2-3">1.2.3. 设备驱动的编写</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> [What] kernel &#x2013;&gt; framework</h2>
<div class="outline-text-2" id="text-1">
<p>
参考网站: <i>窝窝科技</i>
</p>

<p>
参考书籍: <a id="Linux" name="Linux"></a>
</p>

<p>
<i>编写底层逻辑</i>
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 时钟管理子系统(clock)</h3>
<div class="outline-text-3" id="text-1-1">
<p>
commom clock framework 是用来管理系统 clock 资源的子系统, 根据职能由 <b>顶层到底层</b> 分为3个部分(很多框架的实现层次都是这种方式):
</p>
<ol class="org-ol">
<li>向其他 driver 提供操作 clocks 的通用 API(就类似于I2C,SPI设备使用总线提供的操作函数一样)
</li>
<li>实现 clock 控制的通用逻辑, 这部分与硬件无关
</li>
<li>将和硬件相关的 clock 控制逻辑封装成操作函数集, 交由底层的 platform 开发者实现, 由通用逻辑调用.
</li>
</ol>

<p>
很多芯片都具有时钟树,以满足不同设备的运行速度需求.参考熟悉的 STM32 的系统时钟树可以发现,其组成部分有:
</p>
<ul class="org-ul">
<li>外部晶体振荡器
</li>
<li>PLL
</li>
<li>多路选择器
</li>
<li>分频器
</li>
<li>时钟使能
</li>
</ul>

<p>
common clock framework 的管理对象就是这些可以调节的各个部分, 在软件中以 <code>struct clk</code> 来表示, 主要包括:
</p>
<ul class="org-ul">
<li>时钟使能和失能
</li>
<li>设置时钟频率
</li>
<li>设置时钟树的连接关系
</li>
</ul>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> driver 使用通用API(clock consumer)</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
通用API位于 <code>include/linux/clk.h</code> 中.
</p>
</div>

<ol class="org-ol"><li><a id="sec-1-1-1-1" name="sec-1-1-1-1"></a>使用顺序<br  /><div class="outline-text-5" id="text-1-1-1-1">
<p>
具体的时钟设备是通过设备树来表示的, 而clock框架通过读取当前设备接点的时钟描述, 而得到对应的具体时钟驱动.
</p>

<p>
对于使用者来说, 仅仅需要通过在设备节点添加时钟属性, 然后调用clock API即可, 不用关心内部的实现.
</p>

<p>
一般来说, 在设备树中会有先列出的整个系统时钟名称, 其他节点引用此名称即可:
</p>
<pre class="example">
slcr: slcr@f8000000 {
  #address-cells = &lt;1&gt;;
  #size-cells = &lt;1&gt;;
  compatible = "xlnx, zynq-slcr", "syscon";
  reg = &lt;0xf8000000 0x1000&gt;;
  ranges;
  clkc: clkc:@100{
    #clock-cells = &lt;1&gt;;
    compatible = "xlnx, ps7-clkc";
    ps-clk-frequency = &lt;33333333&gt;;
    fclk-enable = &lt;0&gt;;
                          //  0       1         2          3
    clocl-output-names = "armpll", "ddrpll", "iopll", "cpu_6or4x",
                          //  4          5        6       7        8
                          "cpu_3or2x","cpu_2x","cpu_1x","ddr2x","ddr3x",
                          //9     10     11     12     13     14
                          "dci","lqspi","smc","pcap","gem0","gem1",
                          //15      16      17      18      19     20
                          "fclk0","fclk1","fclk2","fclk3","can0","can1",
                          //21      22       23     24      25     26
                          "sdio0","sdio1","uart0","uart1","spi0","spi1",
                          //27      28       29            30
                          "dma","usb0_aper","usb1_aper","gem0_aper",
                          //31           32            33
                          "gem1_aper","sdio0_aper","sdio1_aper",
                          //34            35          36          37
                          "spi0_aper","spi1_aper","can0_aper","can1_aper",
                          //38             39         40           41
                          "i2c0_aper","i2c1_aper","uart0_aper","uart1_aper",
                          //  42           43         44        45
                          "gpio_aper","lqspi_aper","smc_aper","swdt",
                          //46          47
                          "dbg_trc","dbg_apb";
     reg = &lt;0x100 0x100&gt;;
  };
};

sdhci0: sdhc@e0100000{
  compatible = "arasan, sdhi-8.9a";
  status = "disabled";
  /// 为下面两个引用时钟定义别名,用于 clk_get() 函数引用
  clock-names = "clk_xin", "clk_ahb";
  clocks = &lt;&amp;clkc 21&gt;, &lt;&amp;clkc 32&gt;;
  interrupt-parent = &lt;&amp;intc&gt;;
  interrupts = &lt;0 24 4&gt;;
  reg = &lt;0xe0100000 0x1000&gt;;
};
</pre>
</div>
</li>

<li><a id="sec-1-1-1-2" name="sec-1-1-1-2"></a>API<br  /><ol class="org-ol"><li><a id="sec-1-1-1-2-1" name="sec-1-1-1-2-1"></a>获取 strucl clk<br  /><div class="outline-text-6" id="text-1-1-1-2-1">
<p>
每个时钟对象都由一个 <code>struct clk</code> 结构体来表示, 这些结构体通过链表挂接在一起, 形成和时钟树一样的结构, 所以在操作时钟前, 首先需要通过设备树节点获取时钟.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#20197; device &#25351;&#38024;&#25110; id &#23383;&#31526;&#20018;(&#21487;&#20197;&#30475;&#20316;name, &#20063;&#23601;&#26159;&#35774;&#22791;&#33410;&#28857;&#20013;&#30340; clock-names &#23646;&#24615;)&#20026;&#21442;&#25968;, &#26597;&#25214;clock</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> dev &#21644; id &#20219;&#24847;&#19968;&#20010;&#21487;&#20197;&#20026;&#31354;, &#22914;&#26524; id &#20026;&#31354;,&#21017;&#24517;&#39035;&#35201;&#26377; device tree &#25903;&#25345;.</span>
<span style="color: #E6DB74; font-style: italic;"> * id &#21487;&#20197;&#26159;&#19968;&#20010;&#31616;&#21333;&#30340;&#21517;&#31216;, &#20063;&#21487;&#20197;&#26159;&#19968;&#20010;&#39044;&#20808;&#23450;&#20041;&#30340;, &#21807;&#19968;&#26631;&#35782;(&#22312;&#24179;&#21488;&#25552;&#20379;&#30340;&#22836;&#25991;&#20214;&#20013;&#23450;&#20041;, &#22914; mach/clk.h);</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@warning</span><span style="color: #E6DB74; font-style: italic;"> &#19981;&#33021;&#22312;&#20013;&#26029;&#19978;&#19979;&#25991;&#20013;&#35843;&#29992;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_get</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">id</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#19982;get&#30340;&#21453;&#25805;&#20316;, &#21644; get &#25104;&#23545;&#20351;&#29992;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">clk_put</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#30456;&#27604; clk_get ,&#27492;&#20989;&#25968;&#21487;&#20197;&#33258;&#21160;&#37322;&#25918;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">devm_clk_get</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">id</span>);
<span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">devm_clk_put</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#30456;&#27604; clk_get , &#20351;&#29992;&#35774;&#22791;&#21517;&#31216;&#20195;&#26367; device &#32467;&#26500;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_get_sys</span>(<span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">dev_id</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">con_id</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#30452;&#25509;&#20174;&#23545;&#24212;&#30340;&#35774;&#22791;&#26641;&#33410;&#28857;&#20013;&#33719;&#21462; clk</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">of_clk_get</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">np</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">index</span>);
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">of_clk_get_by_name</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">np</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>);
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">of_clk_get_from_provider</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">of_phandle_args</span> *<span style="color: #F92672;">clkspec</span>);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-1-1-2-2" name="sec-1-1-1-2-2"></a>控制 clock<br  /><div class="outline-text-6" id="text-1-1-1-2-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> *</span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#21551;&#21160;&#21644;&#20572;&#27490; clock &#21069;&#30340;&#20934;&#22791;&#21450;&#21892;&#21518;&#24037;&#20316;, &#21487;&#33021;&#20250;&#24341;&#36215;&#30561;&#30496;(&#31561;&#24453;PLL&#31283;&#23450;&#30340;&#26102;&#38388;)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@warning</span><span style="color: #E6DB74; font-style: italic;"> &#19981;&#33021;&#22312;&#20013;&#26029;&#22788;&#29702;&#20013;&#35843;&#29992;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_prepare</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">clk_upprepare</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#21551;&#21160;&#21450;&#20572;&#27490;clock,&#19981;&#20250;&#24341;&#36215;&#30561;&#30496;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_enable</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">clk_disable</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#27492;&#20989;&#25968;&#22833;&#19978;&#38754;4&#20010;&#20989;&#25968;&#30340;&#32452;&#21512;&#39034;&#24207;&#20026; prepare -&gt; enable -&gt; disable -&gt; unprepared</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@warning</span><span style="color: #E6DB74; font-style: italic;"> &#36825;&#20004;&#20010;&#20989;&#25968;&#19981;&#33021;&#22312;&#21407;&#23376;&#25805;&#20316;&#20013;&#20351;&#29992;, &#22240;&#20026;&#20989;&#25968;&#21487;&#33021;&#20250;&#24341;&#36215;&#30561;&#30496;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_prepare_enable</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">lck</span>);
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">clk_disable_upprepare</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> clock &#39057;&#29575;&#30340;&#30340;&#33719;&#21462;&#21644;&#35774;&#32622;.</span>
<span style="color: #E6DB74; font-style: italic;"> * &#24182;&#19981;&#19968;&#23450;&#20250;&#35774;&#32622;&#25104;&#21151;,&#22240;&#20026;&#20998;&#39057;&#27604;&#26377;&#38480;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@warning</span><span style="color: #E6DB74; font-style: italic;"> &#20026;&#20102;&#30830;&#20445;&#35774;&#32622;&#25104;&#21151;, &#38656;&#35201;&#20808;&#35843;&#29992; clk_round_rate &#33719;&#21462;&#29702;&#24819;&#35774;&#32622;&#20540;&#30340;&#23454;&#38469;&#35774;&#32622;&#20540;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672; font-style: italic;">clk_get_rate</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_set_rate</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">rate</span>);
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672; font-style: italic;">clk_round_rate</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">rate</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#33719;&#21462;&#21644;&#36873;&#25321;&#29238;&#26102;&#38047;,&#24418;&#25104;&#26102;&#38047;&#26641;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_set_parent</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">parent</span>);
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_get_parent</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-1-1-2-3" name="sec-1-1-1-2-3"></a>其他接口<br  /><div class="outline-text-6" id="text-1-1-1-2-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#29992;&#20110;&#27880;&#20876;&#21644;&#27880;&#38144;&#19968;&#20010;&#28040;&#24687;,&#24403;clock rate &#25913;&#21464;&#26102;, &#23601;&#20250;&#36890;&#30693;&#27492;&#39537;&#21160;.</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_notifier_register</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">notifer_block</span> *<span style="color: #F92672;">nb</span>);
<span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_notifier_unregister</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">notifer_block</span> *<span style="color: #F92672;">nb</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#32473; clk &#36215;&#21035;&#21517;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">clk_add_alias</span>(<span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">alias</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">alias_dev_name</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">id</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>);
</pre>
</div>
</div>
</li></ol>
</li>
<li><a id="sec-1-1-1-3" name="sec-1-1-1-3"></a>使用详解<br  /><div class="outline-text-5" id="text-1-1-1-3">
<p>
参考: <code>Documentation/devicetree/bindings/clock/clock-bindings.txt</code>
</p>
</div>
<ol class="org-ol"><li><a id="sec-1-1-1-3-1" name="sec-1-1-1-3-1"></a>在 device tree 中设置需要使用的 clock<br  /><div class="outline-text-6" id="text-1-1-1-3-1">
<pre class="example">
/**
 * @note 此设备使用两个 clock, baud 取自 osc 的 1号通道, register 取自 ref 的 0号通道.
 * 用于 clk_get 使用名字来得到时钟结构体
 */
device{
    clocks = &lt;&amp;osc 1&gt;, &lt;&amp;ref 0&gt;;
    clock-names = "baud", "register";
};
</pre>
</div>
</li>
<li><a id="sec-1-1-1-3-2" name="sec-1-1-1-3-2"></a>系统解析<br  /><div class="outline-text-6" id="text-1-1-1-3-2">
<p>
系统启动后, device tree 代码会解析 clock 有关的关键字, 并将解析后的信息放在 platform<sub>device</sub> 相关的字段中.
</p>
</div>
</li>
<li><a id="sec-1-1-1-3-3" name="sec-1-1-1-3-3"></a>driver 使用<br  /><div class="outline-text-6" id="text-1-1-1-3-3">
<p>
具体的driver可以在probe的时候, 以clock的名称为参数, 调用 clk<sub>get</sub> 接口, 获取clock的对象, 然后使用此对象为参数使用上述函数.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">xxx_probe</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">platform_device</span> *<span style="color: #F92672;">pdev</span>)
{
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">baud_clk</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">ret</span>;

        baud_clk = devm_clk_get(&amp;pdev-&gt;dev, <span style="color: #E6DB74;">"baud"</span>);
        <span style="color: #66D9EF;">if</span>(IS_ERR(baud_clk))
        {
                ....
        }
        ret = clk_prepare_enable(baud_clk);
        <span style="color: #66D9EF;">if</span>(ret)
        {
                ...
        }
}
</pre>
</div>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 编写 clock 通用逻辑(clock provider)</h4>
<div class="outline-text-4" id="text-1-1-2">
</div><ol class="org-ol"><li><a id="sec-1-1-2-1" name="sec-1-1-2-1"></a>编写设备树<br  /><div class="outline-text-5" id="text-1-1-2-1">
<p>
provider 的设备树有两种写法:
</p>
<ol class="org-ol">
<li>将系统所有的clock抽象为一个虚拟的设备, 用一个节点表示, 称为 <code>clock controller</code>.
</li>
</ol>
<pre class="example">
clock:clock-controller@0x10030000{
    compatible = "samsung,exynos4210-clock";
    reg = &lt;0x10030000 0x20000&gt;;
    /// 为0时代表只有一个时钟输出, 为1时代表有多个时钟输出
    #clock-cells = &lt;1&gt;;
};

mct@10050000{
    compatible = "samsung, exynos4210-mct";
    ....
    /**
    * @note clk_get 方法读取 clocks 属性来得到对应的 struct clk 指针
    * 当 provider 节点中的 #clock-cells 属性为0时, 只需要提供一个 clock provider name(称为 phandle);
    * 为 1时, 则还需要额外提供一个序号. 可以在头文件中 define 这些序号, 比数字更加易懂.
    * clock-names 是为 clocks 中指定的两个时钟设置名称, 这样 clk_get 就可以直接使用此名称.
    */
    clocks = &lt;&amp;clock 3&gt;, &lt;&amp;clock 334&gt;;
    clock-names = "fin_pll", "mct";
</pre>
<ol class="org-ol">
<li>将每个clock都分别表示一个节点, 而每一个节点即是 provider 也是 consumer（因为需要连接）
</li>
</ol>
<pre class="example">
clocks{
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    ranges;
    dummy:dummy{
        #clock-cells = &lt;0&gt;;
        compatible = "fixed-clock";
        clock-frequency = &lt;0&gt;;
    };
    //root clock
    osc24M: osc24M@01c2005{
            #clock-cells = &lt;0&gt;;
            compatible = "allwinner, sun4i-soc-clk";
            reg = &lt;0x01c20050 0x4&gt;;
            clock-frequency = &lt;24000000&gt;;
    };
    //root clock
    osc32k:osc32k{
        #clock-cells = &lt;0&gt;;
        compatible = "fixed-clock";
        clock-frequency = &lt;32768&gt;;
    };
    /**
     * @note pll1 是provider 也是 consumer
    */
    pll1:pll1@01c20000{
        #clock-cells = &lt;0&gt;;
        compatible = "allwinner,sun4i-pll1-clk";
        reg = &lt;0x01c20000 0x4&gt;;
        clock2 = &lt;&amp;osc24M&gt;;
    };
    cpu: cpu@01c20054{
         #clock-cells = &lt;0&gt;;
         compatible = "allwinner, sun4i-cpu-clk";
         reg = &lt;0x01c20054 0x04&gt;;
         clocks = &lt;&amp;osc32k&gt;, &lt;&amp;osc24M&gt;,&lt;&amp;pll1&gt;,&lt;&amp;dummy&gt;;
    };
    /**
     * @note ahb_gates  是provider 也是 consumer
    */
    ahb_gates:ahb_gates@01c20060{
        #clock-cells = &lt;1&gt;;
        compatible = "allwinner,sun4i-ahb-gates-clk";
        reg = &lt;0x01c20060 0x08&gt;;
        clocks = &lt;&amp;ahb&gt;;
        /**
        * @warning: clock-output-names 关键字只是为了方便 clock privider 编程方便, consumer 不可见
        */
        clock-output-names = "ahb_usb0", "ahb_ehci0",
        "ahb_ohci0", "ahb_ehi1"......
    };
};
</pre>
</div>
</li>
<li><a id="sec-1-1-2-2" name="sec-1-1-2-2"></a>API<br  /><div class="outline-text-5" id="text-1-1-2-2">
<p>
位于 <code>include/linux/clk_provider.h</code>
</p>
</div>
<ol class="org-ol"><li><a id="sec-1-1-2-2-1" name="sec-1-1-2-2-1"></a>struct clk<sub>hw</sub><br  /><div class="outline-text-6" id="text-1-1-2-2-1">
<p>
framework 提供了 struct clk<sub>hw</sub> 结构, 用于从 clock　provider 的角度, 描述clock :
#+BEGIN<sub>SRC</sub> c
struct clk<sub>hw</sub>{
        struct clk　*clk;
        <i>/</i> 用于描述一个 clock 的静态数据
        const struct clk<sub>init</sub><sub>data</sub> *init;
};
/**
 ,* @param name: clock 的名称
 ,* @param ops: 该clock 的操作函数集
 ,* @param parent<sub>names</sub>: 该clock所有的parent clock 的名称, 这是一个字符串数组
 ,* @param num<sub>parents</sub>: parent 个数
 ,* @param flags : framework 级别的 flags
 ,*/
struct clk<sub>init</sub><sub>data</sub>{
        const char  *name;
        const struct clk<sub>ops</sub> *ops;
        const char **parent<sub>names</sub>;
        u8   num<sub>parents</sub>;
        unsigned long flags;
};
/**
 ,* @brief framework flags 可以使用或的关系
 ,*
 ,*/
#define CLK<sub>SET</sub><sub>RATE</sub><sub>GATE</sub>                       BIT(0) <i><i>/在改变该 clock 的 rate时, 必须关闭
#define CLK<sub>SET</sub><sub>PARENT</sub><sub>GATE</sub>                     BIT(1) /</i></i> 在改变该 clock 的 parent 时, 必须关闭
#define CLK<sub>SET</sub><sub>RATE</sub><sub>PARENT</sub>                     BIT(2) <i>/</i> 改变该 clock 的rate时, 要将改变传递到上层 parent
#define CLK<sub>IGNORE</sub><sub>UNUSED</sub>                       BIT(3) <i>/</i> 忽略 disable unused 的调用
#define CLK<sub>IS</sub><sub>ROOT</sub>                             BIT(4) <i>/</i> 该clcok 为 root clock, 没有parent
#define CLK<sub>IS</sub><sub>BASIC</sub>                            BIT(5) <i>/</i> 不再使用
#define CLK<sub>GET</sub><sub>RATE</sub><sub>NOCAHE</sub>                     BIT(6) <i>/</i> get rate 时, 不要从缓存中拿, 而是重新计算
</p>

<p>
struct clk<sub>ops</sub>{
        int              (*prepare)(struct clk<sub>hw</sub> *hw);
        void             (*unprepare)(struct clk<sub>hw</sub> *hw);
        int              (*is<sub>prepared</sub>)(struct clk<sub>hw</sub> *hw);
        <i>/</i> 自动清除没有被使用的时钟
        void             (*unprepare<sub>unused</sub>)(struct clk<sub>hw</sub> *hw);
        int              (*enable)(struct clk<sub>hw</sub> *hw);
        void             (*disable)(struct clk<sub>hw</sub> *hw);
        int              (*is<sub>enabled</sub>)(struct clk<sub>hw</sub> *hw);
        <i>/</i> 自动失能没有被使用的时钟
        void             (*disable<sub>unused</sub>)(struct clk<sub>hw</sub> *hw);
        <i>/</i> 重新计算并返回 clock rate
        unsigned long    (*recalc<sub>rate</sub>)(struct clk<sub>hw</sub> *hw, unsigned long parent<sub>rate</sub>);
        long             (*round<sub>rate</sub>)(struct clk<sub>hw</sub> *hw, unsigned long, unsigned long *);
        int              (*set<sub>parent</sub>)(struct clk<sub>hw</sub> *hw, u8 index);
        u8               (*get<sub>parent</sub>)(struct clk<sub>hw</sub> *hw);
        int              (*set<sub>rate</sub>)(struct clk<sub>hw</sub> *hw, unsigned long, unsigned long);
        <i>/</i> clock 被 register 时自动被调用
        void             (*init)(struct clk<sub>hw</sub> *hw);
};
+END<sub>SRC</sub>
</p>
</div>
</li>
<li><a id="sec-1-1-2-2-2" name="sec-1-1-2-2-2"></a>clk<sub>register</sub><br  /><div class="outline-text-6" id="text-1-1-2-2-2">
<p>
通过 register 将 struct clk<sub>hw</sub> 注册到 kernel 中. <b>clock framework 的核心代码会把它们转换为 struct clk 变量</b>,
并以 tree 的形式组织起来.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">hw</span>);
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">devm_clk_register</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">hw</span>);

<span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">clk_unregister</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
<span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">devm_clk_unregister</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-1-2-2-3" name="sec-1-1-2-2-3"></a>clock 分类及register<br  /><div class="outline-text-6" id="text-1-1-2-2-3">
<p>
根据 clock 的特点, clock framework 将 clock 分为fixed rate, gate, devider, mux, fixed factor, composite.六类.
</p>

<p>
每一类clock都有相似的功能, 相似的控制方式, 因而可以使用相同的逻辑, 统一处理.
</p>
<ul class="org-ul">
<li>fixed rate clock
</li>
</ul>
<p>
此类 clock 具有固定的频率, 不能开关, 不能调整频率, 不能选择 parent, 不需要提供任何的 <code>clk_ops</code> 回调函数, 是最简单的一类 clock.
</p>

<p>
可以直接通过设备树配置, <b>clock framework core 直接从设备树中解出 clock 信息, 并自动注册到 kernel, 不需要任何driver支持</b>.
</p>

<p>
framework 使用 struct clk<sub>fixed</sub><sub>rate</sub> 结构来表示这种 clock, 另外提供了一个接口, 可以直接注册.
</p>
<pre class="example">
/// provider
ad9361_clkin:ad9361_clock@0{
    #clock-cells = &lt;0&gt;;
    compatible = "fixed-clock";
    clock-frequency = &lt;40000000&gt;;
    clock-output-names = "ad9361_ext_refclk";
};

/// consumer
adc_9361@0{
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;0&gt;;
    compatible = "adi,ad9361";

    clocks = &lt;&amp;ad9361_clkin 0&gt;;
    clock-names = "ad9361_ext_refclk";
};
</pre>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#21482;&#35201;&#22312;&#35774;&#22791;&#26641;&#20013;&#23450;&#20041;&#20102;&#26102;&#38047;&#33410;&#28857;,&#37027;&#20040;&#19979;&#38754;&#36825;&#20123;&#20989;&#25968;&#21017;&#19981;&#29992;&#20851;&#24515;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_fixed_rate</span>{
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> <span style="color: #F92672;">hw</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">fixed_rate</span>;
        <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">flags</span>;
};

<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_ops</span> <span style="color: #F92672;">clk_fixed_rate_ops</span>;
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_fixed_rate</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                    <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">parent_name</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                                    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">fixed_rate</span>);
</pre>
</div>
<ul class="org-ul">
<li>gate clock
</li>
</ul>
<p>
此类 clock 只可开关(使用 enable/disable 函数),使用下面的函数注册:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> name : clock &#21517;&#31216;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> parent_namei : parent clock &#21517;&#31216;, &#22914;&#26524;&#27809;&#26377;&#21017;&#20026; NULL</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> flags : &#21516;&#19978;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> reg : &#25511;&#21046; clock&#24320;&#20851;&#30340;&#34394;&#25311;&#22320;&#22336;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> bit_idx : &#25511;&#21046;bit&#20301;(&#26159;1 &#24320;&#36824;&#26159;0&#24320;).</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> clk_gate_flags: &#24403;&#20026; CLK_GATE_SET_TO_DISABLE, &#34920;&#31034;&#20889;1&#20851;&#38381; clock</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> lock : &#22914;&#26524;&#24320;&#20851;&#38656;&#35201;&#20114;&#26021;, &#21487;&#20197;&#25552;&#20379;&#19968;&#20010; spinlock</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_gate</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                              <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">parent_name</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                              <span style="color: #66D9EF;">void</span> <span style="color: #F92672;">__iomem</span> *reg, u8_bit_idx,
                              <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">clk_gate_flags</span>, <span style="color: #66D9EF;">spinlock_t</span> *<span style="color: #F92672;">lock</span>);
</pre>
</div>
<ul class="org-ul">
<li>divider clock
</li>
</ul>
<p>
此类 clock 可以设置分频值(因而会提供 recalc<sub>rate</sub>/ set<sub>rate</sub>/ round<sub>rate</sub> 回调).
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> shift : &#25511;&#21046;&#20998;&#39057;&#27604;&#30340;&#20301;&#22312;&#23492;&#23384;&#22120;&#20013;&#30340;&#20559;&#31227;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> width : &#20998;&#39057;&#27604;&#30340;&#20301;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> clk_divider_flags:</span>
<span style="color: #E6DB74; font-style: italic;"> * CLK_DIVIDER_ONE_BASED: &#23454;&#38469; divider &#30340;&#20540;&#23601;&#26159;&#23492;&#23384;&#22120;&#30340;&#20540;</span>
<span style="color: #E6DB74; font-style: italic;"> * CLK_DIVIDER_POWER_OF_TWO: &#23454;&#38469;&#30340; divider &#20540;&#26159;&#23492;&#23384;&#22120;&#20540;&#30340;2&#27425;&#26041;</span>
<span style="color: #E6DB74; font-style: italic;"> * CLK_DIVIDER_ALLOW_ZERO:  divider &#20540;&#21487;&#20197;&#20301;0</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_divider</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                 <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">parent_name</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                                 <span style="color: #66D9EF;">void</span> <span style="color: #F92672;">__iomem</span> *reg, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">shift</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">width</span>,
                                 <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">clk_divider_flags</span>, <span style="color: #66D9EF;">spinlock_t</span> *<span style="color: #F92672;">lock</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#29992;&#20110;&#27880;&#20876;&#19981;&#35268;&#21017;&#30340;&#20998;&#39057; clock</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_divider_table</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                       <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">parent_name</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                                       <span style="color: #66D9EF;">void</span> <span style="color: #F92672;">__iomem</span> *reg, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">shift</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">width</span>,
                                       <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">clk_divider_flags</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_div_table</span> *<span style="color: #F92672;">table</span>,
                                       <span style="color: #66D9EF;">spinlock_t</span> *<span style="color: #F92672;">lock</span>);
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_div_table</span>{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">val</span>;    <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">&#23492;&#23384;&#22120;&#30340;&#20540;</span>
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">div</span>;   <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">&#23545;&#24212;&#30340;&#20998;&#39057;&#20540;</span>
};
</pre>
</div>
<ul class="org-ul">
<li>mux clock
</li>
</ul>
<p>
这是一个多通道选择的时钟, 所以这类 clock 可以选择多个 parent, 需要 <code>get_parent, set_parent, recal_rate</code> 函数支持.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> parent_names :  &#23383;&#31526;&#20018;&#25968;&#32452;, &#25551;&#36848;&#25152;&#26377;&#21487;&#33021;&#30340; parent</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> num_parents : parent &#20010;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> shift, width : &#36873;&#25321; parent &#30340;&#23492;&#23384;&#22120;&#30340;&#20559;&#31227;,&#23485;&#24230;.&#40664;&#35748;&#23492;&#23384;&#22120;&#20540;&#20026;0&#23545;&#24212;&#31532;&#19968;&#20010; parent</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> clk_mux_flags :</span>
<span style="color: #E6DB74; font-style: italic;"> * CLK_MUX_INDEX_ONE: &#23492;&#23384;&#22120;&#20540;&#19981;&#26159;&#20174;0&#24320;&#22987;, &#32780;&#26159;&#20174;1&#24320;&#22987;</span>
<span style="color: #E6DB74; font-style: italic;"> * CLK_MUX_INDEX_BIT :&#23492;&#23384;&#22120;&#30340;&#20540;&#20026; 2 &#30340;&#24130;; </span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_mux</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                             <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> **<span style="color: #F92672;">parent_names</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">num_parents</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                             <span style="color: #66D9EF;">void</span> <span style="color: #F92672;">__iomem</span> *reg, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">shift</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">width</span>,
                             <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">clk_mux_flags</span>, <span style="color: #66D9EF;">spinlock_t</span> *<span style="color: #F92672;">lock</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> : &#27880;&#20876; mux &#25511;&#21046;&#19981;&#35268;&#21017;&#30340; lock</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_mux_table</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                   <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> **<span style="color: #F92672;">parent_names</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">num_parents</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                                   <span style="color: #66D9EF;">void</span> <span style="color: #F92672;">__iomem</span> *reg, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">shift</span>, u32&#12288;mask,
                                   <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">clk_mux_flags</span>, <span style="color: #66D9EF;">u32</span> *<span style="color: #F92672;">table</span>, <span style="color: #66D9EF;">spinlock_t</span> *<span style="color: #F92672;">lock</span>);
</pre>
</div>

<ul class="org-ul">
<li>fixed factor clock
</li>
</ul>
<p>
此类 clock 具有固定的 factor(即 multiplier 和 divider), 虽然 mult 和 divider 不可变, 但是由于parent可变, 所以也会提供 recalc<sub>rate</sub>, set<sub>rate</sub>, round<sub>rate</sub> 等回调).可以直接在设备树中配置即可, 底层自动使用下面的函数.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_fix_factor</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                    <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">parent_name</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>,
                                    <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">mult</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">div</span>);
</pre>
</div>
<ul class="org-ul">
<li>composite lock
</li>
</ul>
<p>
是 mux,divider,gate 等 clock的组合,所以如下接口注册
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register_composite</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">name</span>,
                                   <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> **<span style="color: #F92672;">parent_names</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">num_parents</span>,
                                   <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">mux_hw</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_ops</span> *<span style="color: #F92672;">mux_ops</span>,
                                   <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">rate_hw</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_ops</span> *<span style="color: #F92672;">rate_ops</span>,
                                   <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">gae_hw</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_ops</span> *<span style="color: #F92672;">gate_ops</span>,
                                   <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span> <span style="color: #F92672;">flags</span>);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-1-2-2-4" name="sec-1-1-2-2-4"></a>设备树相关API<br  /><div class="outline-text-6" id="text-1-1-2-2-4">
<p>
provider 需要将clock的对应信息告知 framework 的 OF 模块, 这样才可以帮助将 consumer 的DTS转换为对应的 struct clk结构.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> np : &#23545;&#24212;&#30340;&#35774;&#22791;&#26641;&#32467;&#28857;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> clk_src_get: &#33719;&#21462; struct clk&#25351;&#38024;&#30340;&#22238;&#35843;&#20989;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> args : &#22312;&#35774;&#22791;&#26641;&#20013;&#33719;&#21462;&#21040;&#30340;&#21442;&#25968; &#27604;&#22914;: clocks = &lt;&amp;clock 32&gt;, &lt;&amp;clock 45&gt;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> data : &#20445;&#23384; struct clk &#30340;&#25351;&#38024;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> data : </span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">of_clk_add_provider</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">np</span>,
                        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *(*<span style="color: #F92672;">clk_src_get</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">of_phandle_args</span> *<span style="color: #F92672;">args</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #F92672;">data</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #F92672;">data</span>);

<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;">: &#23545;&#20110;&#25152;&#26377;&#26102;&#38047;&#37117;&#20197;&#21015;&#34920;&#26041;&#24335;&#23384;&#22312;&#33410;&#28857;&#20013;&#26102;,clock framework core &#25552;&#20379;&#19968;&#20010;&#40664;&#35748;&#30340;&#20250;&#35843;&#29992;&#30340;&#20989;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> *</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_onecell_data</span>{
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> **<span style="color: #F92672;">clks</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">clk_num</span>;
};
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">of_clk_src_onecell_get</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">of_phandle_args</span> *<span style="color: #F92672;">clkspec</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #F92672;">data</span>);
</pre>
</div>
</div>
</li></ol>
</li>
<li><a id="sec-1-1-2-3" name="sec-1-1-2-3"></a>编写步骤<br  /><div class="outline-text-5" id="text-1-1-2-3">
<ol class="org-ol">
<li>分析硬件的 clock tree, 按照 framework 中的 clock 的类别, 将它们分类
</li>
<li>将 clock<sub>tree</sub> 在DTC中描述出来. 
<ul class="org-ul">
<li>对于 fixed rate clocks. compatible 中固定为 "fixed-clock", 并提供 "clock-frequency" , "clock-out-names" 关键字.之后不需要在 driver 中做任何处理, framework会帮助我们搞定.
</li>
<li>对于 fixed factor clock. compatible 为 "fixed-factor-clock", 并提供 "clock-div", "clock-mult", "clock-output-names".然后交给 framework 搞定
</li>
</ul>
</li>
<li>对于不能由 framework 处理的 clock, 需要在driver中使用 struct of<sub>device</sub><sub>id</sub> 进行匹配, 并在初始化时调用 OF模块,查找所有的 DTS匹配项, 并执行register.
</li>
<li>注册 clock 的同时, 将返回 struct clk指针, 保存在一个数组中, 并使用 <code>of_clk_add_privider</code> 告知 framework.
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> 编写底层逻辑</h4>
<div class="outline-text-4" id="text-1-1-3">
</div><ol class="org-ol"><li><a id="sec-1-1-3-1" name="sec-1-1-3-1"></a>分析 struct clk 结构<br  /><div class="outline-text-5" id="text-1-1-3-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> parent :&#35813;clock&#24403;&#21069;&#30340;parent clock &#30340; struct clk &#25351;&#38024;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> parents: &#20445;&#23384;&#25152;&#26377;&#21487;&#33021;&#30340; parent clock &#30340; struct clk &#25351;&#38024;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> rate: &#24403;&#21069; clock rate</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> new_rate: &#26032;&#35774;&#32622;&#30340; clock rate</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> enable_count, prepare_count: &#34987;enable&#21644; prepare &#30340;&#27425;&#25968;, &#29992;&#20110;&#30830;&#20445;&#21644; disable/unprepare &#25104;&#23545;&#35843;&#29992;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> children : children clocks, &#20197;&#38142;&#34920;&#30340;&#24418;&#24335;&#32452;&#32455;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> child_node: &#19968;&#20010; list node, &#33258;&#24049;&#20316;&#20026;child &#26102;, &#25346;&#21040; parent &#30340; children list &#26102;&#20351;&#29992;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> notifier_count: &#35760;&#24405;&#27880;&#20876;&#21040;notifier&#30340;&#20010;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span>{
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span>              *<span style="color: #F92672;">name</span>;
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_ops</span> *<span style="color: #F92672;">ops</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span>            *<span style="color: #F92672;">hw</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span>                 *<span style="color: #F92672;">parent</span>;
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span>               **<span style="color: #F92672;">parent_names</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span>                **<span style="color: #F92672;">parents</span>;
        <span style="color: #66D9EF;">u8</span>                          <span style="color: #F92672;">num_parents</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>      <span style="color: #F92672;">rate</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>      <span style="color: #F92672;">new_rate</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">long</span>      <span style="color: #F92672;">flags</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>         <span style="color: #F92672;">enable_count</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span>         <span style="color: #F92672;">prepate_count</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">hlist_head</span>  <span style="color: #F92672;">children</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">hlist_node</span>  <span style="color: #F92672;">child_node</span>;
        unsigen <span style="color: #66D9EF;">int</span>           <span style="color: #F92672;">notifier_count</span>;
<span style="color: #A6E22E;">        #ifdef</span> CONFIG_COMMON_CLK_DEBUG
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">dentry</span>        *<span style="color: #F92672;">dentry</span>;
<span style="color: #A6E22E;">        #endif</span>
};
</pre>
</div>
</div>
</li>
<li><a id="sec-1-1-3-2" name="sec-1-1-3-2"></a>clock register/unregister<br  /><ol class="org-ol"><li><a id="sec-1-1-3-2-1" name="sec-1-1-3-2-1"></a>clk<sub>register</sub><br  /><div class="outline-text-6" id="text-1-1-3-2-1">
<p>
clk<sub>register</sub> 是所有 register 接口的共同实现, 负责将 clock 注册到 kernel, 并返回代表该 clock 的strcut clk 指针.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672; font-style: italic;">clk_register</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> *<span style="color: #F92672;">dev</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk_hw</span> *<span style="color: #F92672;">hw</span>)
{
        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">i</span>, <span style="color: #F92672;">ret</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">clk</span> *<span style="color: #F92672;">clk</span>;
        clk = kzalloc(<span style="color: #66D9EF;">sizeof</span>(*clk), GPF_KERNEL);
        <span style="color: #66D9EF;">if</span>(<span style="font-weight: bold;">!</span>clk)
        {
                pr_err(<span style="color: #E6DB74;">"%s: could not allocate clk\n"</span>, __func__);
                ret = -ENOMEM;
                <span style="color: #66D9EF;">goto</span> <span style="color: #AE81FF;">fail_out</span>;
        }
        clk-&gt;name = kstrdup(hw-&gt;init-&gt;name, GFP_KERNEL);
        <span style="color: #66D9EF;">if</span>(<span style="font-weight: bold;">!</span>clk-&gt;name)
        {
                pr_err(<span style="color: #E6DB74;">"%s, could not allocate clk-&gt;name\n"</span>, __func__);
                ret = -ENOMEM;
                <span style="color: #66D9EF;">goto</span> <span style="color: #AE81FF;">fail_name</span>;
        }
        clk-&gt;ops = hw-&gt;init-&gt;ops;
        <span style="color: #66D9EF;">if</span>(dev &amp;&amp; dev-&gt;driver)
                clk-&gt;owner = dev-&gt;driver-&gt;owner;
        clk-&gt;hw = hw;
        clk-&gt;flags = hw-&gt;init-&gt;flags;
        clk-&gt;num_parents = hw-&gt;init-&gt;num_parents;
        hw-&gt;clk = clk;

        clk-&gt;parent_names = kcalloc(clk-&gt;num_parents, <span style="color: #66D9EF;">sizeof</span>(<span style="color: #66D9EF;">char</span> *), GFP_KERNEL);

        <span style="color: #66D9EF;">if</span>(<span style="font-weight: bold;">!</span>clk-&gt;parent_names)
        {
                pr_err(<span style="color: #E6DB74;">"%s: could not allocate clk-&gt;parent_names\n"</span>, __func__);
                ret = -ENOMEM;
                <span style="color: #66D9EF;">goto</span> <span style="color: #AE81FF;">fail_parent_names</span>;
        }
        <span style="color: #66D9EF;">for</span>( i = 0; i &lt; clk-&gt;num_parents; i++)
        {
                clk-&gt;parent_names[i] = kstrdup(hw-&gt;init-&gt;parent_names[i], GFP_KERNEL);
                <span style="color: #66D9EF;">if</span>(<span style="font-weight: bold;">!</span>clk-&gt;parent_names[i])
                {
                        pr_err(<span style="color: #E6DB74;">"%s: could not copy parent_names\n"</span>, __func__);
                        ret = -ENOMEM;
                        <span style="color: #66D9EF;">goto</span> <span style="color: #AE81FF;">fail_parent_names_copy</span>;
                }
        }

        ret = __clk_init(dev, clk);
        <span style="color: #66D9EF;">if</span>(<span style="font-weight: bold;">!</span>ret)
                <span style="color: #66D9EF;">return</span> clk;

<span style="color: #AE81FF;">fail_parent_names_copy</span>:
        <span style="color: #66D9EF;">while</span>(--i &gt;= 0)
                kfree(clk-&gt;parent_names[i]);
        kfree(clk-&gt;parent_names);
<span style="color: #AE81FF;">fail_parent_names</span>:
        kfree(clk-&gt;name);
<span style="color: #AE81FF;">fail_name</span>:
        kfree(clk);
<span style="color: #AE81FF;">fail_out</span>:
        <span style="color: #66D9EF;">return</span> ERR_PTR(ret);

}
EXPORT_SYMBOL_GPL(clk_register);
</pre>
</div>
</div>
</li></ol>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> I2C子系统</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 总体概览</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Linux 的 I2C 体系结构分为3个组成部分:
</p>
<ul class="org-ul">
<li>I2C核心
</li>
</ul>
<p>
I2C核心提供了I2C总线驱动和设备驱动的注册和注销方法, I2C通信方法, 上层的与具体适配器无关的代码以及探测设备, 检测设备地址的上层代码等.
</p>
<ul class="org-ul">
<li>I2C总线驱动
</li>
</ul>
<p>
所谓的总线驱动也就是I2C控制器的驱动, 与之相关的有 <code>I2C控制器数据结构i2c_adapter</code>, <code>I2C控制器的算法数据结构i2c_algorithm</code>, <code>控制I2C控制器产生通信信号的函数</code>.
</p>

<p>
经由I2C总线驱动的代码, 我们可以控制I2C控制器以主机的方式产生开始位, 停止位, 读写操作, 以及以从机的方式被读写, 产生ACK, NACK等.
</p>

<p>
I2C控制器一般是直接挂接在CPU总线上的, 所以其驱动也是 <code>platform_driver</code>.
</p>
<ul class="org-ul">
<li>I2C设备驱动
</li>
</ul>
<p>
I2C设备也就是与控制器相连接的设备.与之相关的有 <code>i2c_driver</code>, <code>i2c_client</code> 数据结构, 以及对应的功能函数.
</p>

<p>
在Linux系统中, I2C设备及驱动位于 <code>/sys/bus/i2c/</code> 文件夹下.
</p>

<p>
在Linux源码中, i2c驱动目录具有如下结构:
</p>
<ul class="org-ul">
<li>i2c-core.c / i2c-core.h
</li>
</ul>
<p>
实现了I2C的核心功能以及 <code>/proc/bus/i2c*</code> 的接口
</p>
<ul class="org-ul">
<li>i2c-dev.c
</li>
</ul>
<p>
实现了I2C控制器设备文件的功能, 每个I2C控制器都被分配一个设备.通过控制器访问设备时的主设备号位89, 次设备号为 0~255.
也就是说, 此文件提供了通用的接口, 应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间和寄存器, 并控制设备的工作方式.
</p>

<p>
应用程序通过 <code>i2c-%d</code> (i2c-0, i2c-1,&#x2026;.)文件名并使用文件操作接口 open(), write(), read(), ioctl(), close() 等来访问这个设备.
</p>

<p>
<b>当然,使用此文件就需要在用户代码中设置好设备的操作地址, 具体寄存器操作.虽然说可以省事, 但没有实现很好的分层.</b>
</p>
<ul class="org-ul">
<li>busses
</li>
</ul>
<p>
此文件夹包含了I2C控制器的驱动
</p>
<ul class="org-ul">
<li>algos
</li>
</ul>
<p>
实现了一些I2C控制器的通信方法.也就是I2C协议包生成的逻辑, 一般都是由硬件来实现.
</p>
<ul class="org-ul">
<li>i2c.h (include/linux/)
</li>
</ul>
<p>
提供对 <code>i2c_adapter, i2c_algorithm, i2c_driver, i2c_client</code> 数据结构的定义.
</p>

<p>
总体的软件拓扑抽象层次如下图所示:
<a href="./i2c_softTopology.bmp">I2C软件拓扑</a>
整个构架的软件层次如下图所示:
<a href="./i2c_framework.bmp">I2C框架</a>
</p>

<p>
经过I2C framework 的抽象, consumer 可以不用关心I2C总线的技术细节, 只需要通过简单的API, 就可以与 slave devices 进行数据交互.
正常情况下, consumer 是位于内核态的其他driver. 于此同时, I2C framework也通过字符设备向用户空间提供类似的接口, 用户空间程序可以通过该接口访问 slave devices.
</p>

<p>
I2C core 使用 <code>i2c_adapter,i2c_algorithm</code> 抽象I2C控制器的功能, <code>i2c_driver, i2c_client</code> 抽象 I2C slave device 的功能.
另外, 基于I2C协议, 通过 smbus 模块实现 SMBus的功能.
</p>

<p>
<a href="./i2c_smbus.bmp">i2c &amp; smbus</a>
</p>

<p>
I2C muxes 用于实现I2C BUS的多路复用功能, 实际使用较少.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 控制器驱动的编写</h4>
<div class="outline-text-4" id="text-1-2-2">
</div><ol class="org-ol"><li><a id="sec-1-2-2-1" name="sec-1-2-2-1"></a>数据结构<br  /><div class="outline-text-5" id="text-1-2-2-1">
<p>
与控制器驱动密切相关的就是 <code>i2c_adapter, i2c_algorithm</code> 结构体, 具体描述一下:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> struct i2c_msg - an I2C transaction segment beginning with START(&#29992;&#25143;&#31354;&#38388;&#20063;&#21487;&#20197;&#29992;)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> addr -&gt; &#20174;&#26426;&#22320;&#22336;,&#25903;&#25345;7&#20301;&#25110;&#32773;10&#20301;, 10&#20301;&#26102;&#38656;&#35201;&#20351;&#29992; I2C_M_TEN&#26631;&#35760;,&#20197;&#21450;&#39537;&#21160;&#36820;&#22238; I2C_FUNC_10BIT_ADDR</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> flags -&gt; &#26631;&#26126;&#27492;&#27425;&#20256;&#36755;&#26631;&#35760;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> len -&gt; &#35835;&#21462;&#25110;&#32773;&#20889;&#20837;&#30340;&#23383;&#33410;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> buf -&gt; &#35835;&#20889;&#32531;&#23384;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_msg</span>{
        <span style="color: #66D9EF;">__u16</span> <span style="color: #F92672;">addr</span>;
        <span style="color: #66D9EF;">__u16</span> <span style="color: #F92672;">flags</span>;
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_TEN</span> 0x0010 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">this is a ten bit chip address</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_RD</span> 0x0001 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">read data, from slave to master</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_STOP</span> 0x8000 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">if I2C_FUNC_PROTOCOL_MANGLING</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_NOSTART</span> 0x4000 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">if I2C_FUNC_NOSTART</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_REV_DIR_ADDR</span> 0x2000 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">if I2C_FUNC_PROTOCOL_MANGLING</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_IGNORE_NAK</span> 0x1000 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">if I2C_FUNC_PROTOCOL_MANGLING</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_NO_RD_ACK</span> 0x0800 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">if I2C_FUNC_PROTOCOL_MANGLING</span>
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672;">I2C_M_RECV_LEN</span> 0x0400 <span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">length will be first received byte</span>
        <span style="color: #66D9EF;">__u16</span> <span style="color: #F92672;">len</span>;
        <span style="color: #66D9EF;">__u8</span> *<span style="color: #F92672;">buf</span>;
};
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> struct i2c_algorithm - represent I2C transfer method(&#23545;&#24212;&#19968;&#22871;&#36890;&#20449;&#21327;&#35758;)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> master_xfer -&gt; I2C&#20256;&#36755;&#20989;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> smbus_xfer -&gt; smbus&#20256;&#36755;&#20989;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> functionality -&gt; &#36820;&#22238; algorithm/adapter &#25152;&#25903;&#25345;&#30340;&#21151;&#33021;, I2C_FUNC_XXX</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> reg_slave / unreg_slave -&gt; &#27880;&#20876;&#21450;&#27880;&#38144;&#20174;&#35774;&#22791;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#20851;&#20110; master_xfer &#30340;&#38169;&#35823;&#36820;&#22238;&#35828;&#26126;&#25991;&#20214;&#20301;&#20110; Documentation/i2c/fault-codes</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_algorithm</span>{
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">master_xfer</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_msg</span> *<span style="color: #F92672;">msgs</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">num</span>);
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">smbus_xfer</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">u16</span> <span style="color: #F92672;">addr</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #F92672;">flags</span>,
                          <span style="color: #66D9EF;">char</span> <span style="color: #F92672;">read_write</span>, <span style="color: #66D9EF;">u8</span> <span style="color: #F92672;">command</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">size</span>, <span style="color: #66D9EF;">union</span> <span style="color: #66D9EF;">i2c_smbus_data</span> *<span style="color: #F92672;">data</span>);
        u32 (*functionality)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *);
<span style="color: #A6E22E;">#if</span> IS_ENABLED(CONFIG_I2C_SLAVE)
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">reg_slave</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672;">client</span>);
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">unreg_slave</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672;">client</span>);
<span style="color: #A6E22E;">#endif</span>
};
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> i2c_adapter is the structure used to identify a physical i2c bus along with</span>
<span style="color: #E6DB74; font-style: italic;"> * the access algorithms necessary to access it.(&#20195;&#34920;&#25511;&#21046;&#22120;)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> class -&gt; &#27492;&#39537;&#21160;&#25152;&#25903;&#25345;&#30340;&#35774;&#22791;&#31867;&#22411;(I2C_CLASS_HWMON, I2C_CLASS_DDC....)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> timeout -&gt; &#24403;&#37325;&#35797;&#36229;&#36807;&#19968;&#23450;&#26102;&#38388;(jiffies), &#20572;&#27490;&#37325;&#35797;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> retries -&gt; &#35774;&#23450;&#24403;&#20256;&#36755;&#22833;&#36133;&#26102;, &#37325;&#35797;&#20256;&#36755;&#30340;&#27425;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> nr -&gt; &#27492;&#25511;&#21046;&#22120;&#30340;ID, &#19968;&#33324;&#30001;&#35774;&#22791;&#26641;&#35299;&#26512;.</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span>{
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">module</span> *<span style="color: #F92672;">owner</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">class</span>;
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_algorithm</span> *<span style="color: #F92672;">algo</span>;
        <span style="color: #66D9EF;">void</span> *<span style="color: #F92672;">algo_data</span>;

        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">rt_mutex</span> <span style="color: #F92672;">bus_lock</span>;

        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">timeout</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">retries</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> <span style="color: #F92672;">dev</span>;

        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">nr</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #F92672;">name</span>[48];
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">completion</span> <span style="color: #F92672;">dev_released</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">mutex</span> <span style="color: #F92672;">userspace_clients_lock</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #F92672;">userspace_clients</span>;

        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_bus_recovery_info</span> *<span style="color: #F92672;">bus_recovery_info</span>;
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter_quirks</span> *<span style="color: #F92672;">quirks</span>;
};

<span style="color: #A6E22E;">#define</span> <span style="color: #F92672; font-style: italic;">to_i2c_adapter</span>(<span style="color: #F92672;">d</span>) container_of(d, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span>, dev)
</pre>
</div>
</div>
</li>
<li><a id="sec-1-2-2-2" name="sec-1-2-2-2"></a>传输标志<br  /><div class="outline-text-5" id="text-1-2-2-2">
<p>
一般情况下, i2c<sub>msg</sub> 中的 flag 为0, 也就是按照标准传输方式, 具体如下表(表明了 master<sub>xfer</sub>() 的执行流程):
</p>

<p>
[] 表示从机返回.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">标记</th>
<th scope="col" class="left">读写</th>
<th scope="col" class="left">协议</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">0</td>
<td class="left">写</td>
<td class="left">S Addr<sub>Wr</sub> [A] Data [A]&#x2026;..Data [A] P</td>
</tr>

<tr>
<td class="left">0</td>
<td class="left">读</td>
<td class="left">S Addr<sub>Rd</sub> [A] Data [A]&#x2026;..Data NA P</td>
</tr>

<tr>
<td class="left">0</td>
<td class="left">混合</td>
<td class="left">S Addr<sub>Rd</sub> [A] [Data] NA S Addr<sub>Wr</sub> [A] Data [A] P</td>
</tr>

<tr>
<td class="left">I2C<sub>M</sub><sub>IGNORE</sub><sub>NAK</sub></td>
<td class="left">&#xa0;</td>
<td class="left">读取操作时, 忽略 slave 返回的 NA, 把它当作 ACK信号继续读取</td>
</tr>

<tr>
<td class="left">I2C<sub>M</sub><sub>NO</sub><sub>RD</sub><sub>ACK</sub></td>
<td class="left">&#xa0;</td>
<td class="left">读取的时候忽略所有的 A 和 NA</td>
</tr>

<tr>
<td class="left">I2C<sub>M</sub><sub>NOSTART</sub></td>
<td class="left">混合</td>
<td class="left">S Addr<sub>Rd</sub> [A] [Data] NA <del>S Addr<sub>Wr</sub> [A]</del> Data [A] P</td>
</tr>

<tr>
<td class="left">I2C<sub>M</sub><sub>REVDIR</sub><sub>ADDR</sub></td>
<td class="left">&#xa0;</td>
<td class="left">读写翻转, 读的时候发 Wr 信号, 写的时候发 Rd 信号</td>
</tr>

<tr>
<td class="left">I2C<sub>M</sub><sub>STOP</sub></td>
<td class="left">&#xa0;</td>
<td class="left">传输完一个 msg 后发送一个 STOP 信号</td>
</tr>
</tbody>
</table>

<p>
对应的 master<sub>xfer</sub>() 模板类似于:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_adapter_xxx_xfer</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_msg</span> *<span style="color: #F92672;">msgs</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">num</span>)
{
        ...
        <span style="color: #66D9EF;">for</span>(i = 0; i &lt; num; i++)
        {
                i2c_adapter_xxx_start();

                <span style="color: #66D9EF;">if</span>(msgs[i]-&gt;flags &amp; I2C_M_RD)
                {
                        i2c_adapter_xxx_setaddr((msgs[i]-&gt;addr &lt;&lt; 1) | 1);
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_readbytes(msgs[i]-&gt;buf, msgs[i]-&gt;len);

                }
                <span style="color: #66D9EF;">else</span>
                {
                        i2c_adapter_xxx_setaddr((msgs[i]-&gt;addr &lt;&lt;1));
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_writegbytes(msgs[i]-&gt;buf, msgs[i]-&gt;len);
                }
        }
        i2c_adapter_xxx_stop();
}
</pre>
</div>
</div>
</li>
<li><a id="sec-1-2-2-3" name="sec-1-2-2-3"></a>函数接口<br  /><div class="outline-text-5" id="text-1-2-2-3">
<p>
控制器驱动可以使用的接口.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#23558;&#27492; adapter &#27880;&#20876;&#36827;&#20869;&#26680;, &#20869;&#26680;&#33258;&#21160;&#20998;&#37197;ID&#21495;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_add_adapter</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *);
<span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">&#19982;&#19978;&#38754;&#30456;&#27604;, &#38656;&#35201;&#20027;&#21160;&#25552;&#20379;&#19968;&#20010;ID&#21495;</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_add_numbered_adapter</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#23558;&#27492; adapter &#20174;&#20869;&#26680;&#20013;&#21024;&#38500;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">i2c_del_adapter</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#33719;&#21462; adapter &#25152;&#25903;&#25345;&#30340;&#21151;&#33021;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">u32</span> <span style="color: #F92672; font-style: italic;">i2c_get_functionality</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#26816;&#26597; adapter &#26159;&#21542;&#20855;&#22791;&#25351;&#23450;&#30340;&#21151;&#33021;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_check_functionality</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">u32</span> <span style="color: #F92672;">func</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#33719;&#21462; adapter ID</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">inline</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_adapter_id</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#26681;&#25454; adapter ID &#33719;&#21462; adapter</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672; font-style: italic;">i2c_get_adapter</span>(<span style="color: #66D9EF;">int</span> <span style="color: #F92672;">nr</span>);
<span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">&#19982;&#19978;&#38754;&#20989;&#25968;&#38656;&#35201;&#25104;&#23545;&#20351;&#29992;</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">void</span> <span style="color: #F92672; font-style: italic;">i2c_put_adapter</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>);
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#36890;&#36807; device_node &#26597;&#25214;&#23545;&#24212;&#30340; adapter &#32467;&#26500;, &#20351;&#29992;&#23436;&#25104;&#21518;&#38656;&#35201;&#20351;&#29992; put_device &#20989;&#25968;&#20943;&#21435;&#35745;&#25968;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672; font-style: italic;">of_find_i2c_adapter_by_node</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">node</span>);
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="sec-1-2-2-3-1" name="sec-1-2-2-3-1"></a>i2c<sub>add</sub><sub>adapter</sub> 流程<br  /><div class="outline-text-6" id="text-1-2-2-3-1">
<ul class="org-ul">
<li>分配ID
</li>
</ul>
<p>
当用户主动分配ID时, 则是执行的以下流程:
</p>

<p>
i2c<sub>add</sub><sub>numbered</sub><sub>adapter</sub> &#x2013;&gt; _<sub>i2c</sub><sub>add</sub><sub>numbered</sub><sub>adapter</sub> &#x2013;&gt; i2c<sub>register</sub><sub>adapter</sub> 
</p>

<p>
当用户选择自动分配ID时, 则使用 <code>i2c_add_adapter</code> 函数, 此函数会首先搜寻设备树中的 alias ID, 比如 <code>i2c0</code>,
如果没有搜到, 则使用 <code>idr_alloc</code> 分配一个ID.
</p>
<ul class="org-ul">
<li>创建设备
</li>
</ul>
<p>
adapter ID 分配完后, 或执行 <code>i2c_register_adapter</code> ,该接口会在 <code>/sys/devices/xxxxx.i2c/</code> 中创建该 adapter 的目录(/sys/devices/xxxxx.i2c/i2c-n).
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#32463;&#36807;&#20197;&#19979;&#20960;&#27493;, &#26368;&#32456;&#22312; /sys/bus/i2c/devices/ &#20013;&#21019;&#24314;&#23545;&#24212;&#30340;&#31526;&#21495;&#38142;&#25509;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
dev_set_name(&amp;adap-&gt;dev, <span style="color: #E6DB74;">"i2c-%d"</span>, adap-&gt;nr);
adap-&gt;dev.bus = &amp;i2c_bus_type;
adap-&gt;dev.type = &amp;i2c_adapter_type;

<span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">device_register --&gt; device_add --&gt; bus_add_device --&gt; sysfs_create_link</span>
res = device_register&amp;adap-&gt;dev);
</pre>
</div>
<ul class="org-ul">
<li>I2C slave device 的创建和注册
</li>
</ul>
<p>
I2C adapter 注册的时候, 会为它下面所有的 slave device 创建一个 <code>struce i2c_client</code> 结构, 并注册到 I2C bus.
</p>

<p>
i2c<sub>register</sub><sub>adapter</sub> &#x2013;&gt; of<sub>i2c</sub><sub>register</sub><sub>devices</sub> &#x2013;&gt; i2c<sub>new</sub><sub>device</sub> 
</p>
</div>
</li></ol>
</li>

<li><a id="sec-1-2-2-4" name="sec-1-2-2-4"></a>编写步骤(drivers/i2c/busses/i2c-cadence.c)<br  /><div class="outline-text-5" id="text-1-2-2-4">
<p>
编写驱动需要填充 <code>i2c_adapter</code> 结构体, 所以顺序如下:
</p>
<ul class="org-ul">
<li>在设备树文件中, 提供控制器节点的定义:
</li>
</ul>
<pre class="example">
i2c0: i2c@44e0b000{
      compatible = "ti, omap4-i2c";
      #address-cells = &lt;1&gt;;
      #size-cells = &lt;0&gt;;
      ti,hwmods = "i2c1";
      reg = &lt;0x44e0b000 0x1000&gt;;
      interrupt = &lt;70&gt;;
      status = "disabled";
};
</pre>
<ul class="org-ul">
<li>在 <code>deiver/i2c/busses</code> 目录下新建 <code>i2c-xxx.c</code> 驱动文件, 并编写 platform driver 的基本结构.
</li>
<li>定义一个 <code>struct i2c_algorithm</code> 结构, 并根据控制器填充回调函数(functionality(), master<sub>xfer</sub>())
</li>
<li>在 platform driver 的 probe 函数中, 分配一个 adapter 结构, 并初始化. 
</li>
<li>调用 <code>i2c_add_adapter / i2c_add_numbered_adapter</code> 结构将其注册到内核.
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">xxx_i2c_probe</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">platform_device</span> *<span style="color: #F92672;">pdev</span>)
{
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>;

        ...
        xxx_adapter_hw_init();
        adap-&gt;dev.parent = &amp;pdev-&gt;dev;
        adap-&gt;dev.of_node = pdev-&gt;dev.of_node;

        rc = i2c_add_adapter(adap);
        ...
}
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">xxx_i2c_remove</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">platform_device</span> *<span style="color: #F92672;">pdev</span>)
{
        ...
        xxx_adapter_hw_free();
        i2c_dev_adapter(&amp;dev-&gt;adapter);

        <span style="color: #66D9EF;">return</span> 0;
}
<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">of_device_id</span> <span style="color: #F92672;">xxx_i2c_of_match</span>[] = {
        {.compatible = <span style="color: #E6DB74;">"vendor, xxx-i2c"</span>,},
        {},
};
MODULE_DEVICE_TABLE(of, xxx_i2c_of_match);

<span style="color: #66D9EF;">static</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">platform_driver</span> <span style="color: #F92672;">xxx_i2c_driver</span> =
{
        .driver = {
                .name = <span style="color: #E6DB74;">"xxx-i2c"</span>,
                .owner = THIS_MODULE,
                .of_match_table = xxx_i2c_of_match,
        },
        .probe = xxx_i2c_probe,
        .remove = xxx_i2c_remove,
};
module_platform_driver(xxx_i2c_driver);
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> 设备驱动的编写</h4>
<div class="outline-text-4" id="text-1-2-3">
</div><ol class="org-ol"><li><a id="sec-1-2-3-1" name="sec-1-2-3-1"></a>数据结构<br  /><div class="outline-text-5" id="text-1-2-3-1">
<p>
I2C framework 使用 <code>struct i2c_client</code> 抽象 i2c slave device:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> struct i2c_client - represent an I2C slave device</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> flags -&gt; I2C_CLIENT_TEN &#20195;&#34920;&#20351;&#29992;10&#20301;&#22320;&#22336;, I2C_CLIENT_PEC &#20351;&#29992;SMBus &#38169;&#35823;&#26816;&#26597;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> addr -&gt; &#35774;&#22791;&#30340;&#22320;&#22336;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> name -&gt; &#35774;&#22791;&#21517;&#31216;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> afapter -&gt; &#25346;&#36733;&#30340;&#25511;&#21046;&#22120;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> detected -&gt; &#25346;&#25509;&#21516;&#19968;&#24635;&#32447;&#19978;&#30340;&#35774;&#22791;&#38142;&#34920;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span>{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #F92672;">flags</span>;
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> <span style="color: #F92672;">addr</span>;
        <span style="color: #66D9EF;">char</span> <span style="color: #F92672;">name</span>[I2C_NAME_SIZE];
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adapter</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device</span> <span style="color: #F92672;">dev</span>;
        <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">irq</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #F92672;">detected</span>;
<span style="color: #A6E22E;">#if</span> IS_ENABLE(CONFIG_I2C_SLAVE)
        <span style="color: #66D9EF;">i2c_slave_cb_t</span> <span style="color: #F92672;">slave_cb</span>;
<span style="color: #A6E22E;">#endif</span>
};
<span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> struct i2c_driver - represent an I2C device driver</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> class -&gt; &#34920;&#31034;&#27492;&#39537;&#21160;&#25903;&#25345;&#21738;&#31181;&#31867;&#22411;&#30340;I2C&#35774;&#22791;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> attach_afapter -&gt; (&#27492;&#20989;&#25968;&#19981;&#20877;&#20351;&#29992;)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> probe -&gt; &#32465;&#23450;&#35774;&#22791;&#30340;&#22238;&#35843;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> remove -&gt; &#21368;&#36733;&#35774;&#22791;&#30340;&#22238;&#35843;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> shutdown -&gt; &#20851;&#38381;&#35774;&#22791;&#30340;&#22238;&#35843;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> alert -&gt; &#35686;&#21578;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> command -&gt; callback for bus-wide signaling(optional)</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> id_table -&gt; &#21015;&#20986;&#27492;&#39537;&#21160;&#25903;&#25345;&#30340;I2C&#35774;&#22791;, &#24635;&#32447;&#39537;&#21160;&#20989;&#25968; </span><span style="color: #AE81FF; font-style: italic;">i2c_device_match()</span><span style="color: #E6DB74; font-style: italic;"> &#20013;&#20250;&#35843;&#29992; </span><span style="color: #AE81FF; font-style: italic;">i2c_match_id()</span>
<span style="color: #E6DB74; font-style: italic;"> * &#20989;&#25968;&#21305;&#37197;&#29992;&#25143;&#23450;&#20041;&#30340;ID &#21644; &#39537;&#21160;ID</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> decetct -&gt; &#29992;&#20110;&#26816;&#27979;&#35774;&#22791;&#30340;&#22238;&#35843;</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> address_list -&gt; &#24050;&#32463;&#25346;&#36733;&#30340;I2C&#35774;&#22791;&#22320;&#22336;.</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@param</span><span style="color: #E6DB74; font-style: italic;"> clients: &#38142;&#25509;&#25152;&#26377;&#24050;&#32463;&#25346;&#36733;&#30340;&#35774;&#22791;</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_driver</span>{
        <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">class</span>;
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">attach_adapter</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *) __deprecated;
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">probe</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_device_id</span> *);
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">remove</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #F92672; font-style: italic;">shutdown</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *);
        <span style="color: #66D9EF;">void</span> (*<span style="color: #F92672; font-style: italic;">alert</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">data</span>);
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">command</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672;">client</span>, <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">cmd</span>, <span style="color: #66D9EF;">void</span> *<span style="color: #F92672;">arg</span>);
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_driver</span> <span style="color: #F92672;">driver</span>;
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_device_id</span> *<span style="color: #F92672;">id_table</span>;
        <span style="color: #66D9EF;">int</span> (*<span style="color: #F92672; font-style: italic;">detect</span>)(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_board_info</span> *);
        <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">unsigned</span> <span style="color: #66D9EF;">short</span> *<span style="color: #F92672;">address_list</span>;
        <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">list_head</span> <span style="color: #F92672;">clients</span>;
};
<span style="color: #A6E22E;">#define</span> <span style="color: #F92672; font-style: italic;">to_i2c_driver</span>(<span style="color: #F92672;">d</span>) container_of(d, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_driver</span>, driver)
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-3-2" name="sec-1-2-3-2"></a>函数接口<br  /><div class="outline-text-5" id="text-1-2-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #E6DB74; font-style: italic;">/**</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@brief</span><span style="color: #E6DB74; font-style: italic;"> &#36890;&#36807;&#35774;&#22791;&#26641;&#33719;&#21462;&#23545;&#24212;&#30340; client &#25110;&#32773; adapter</span>
<span style="color: #E6DB74; font-style: italic;"> * </span><span style="color: #AE81FF; font-style: italic;">@note</span><span style="color: #E6DB74; font-style: italic;"> &#20351;&#29992;&#27492;&#20989;&#25968;&#21518;, &#24517;&#39035;&#35843;&#29992; </span><span style="color: #AE81FF; font-style: italic;">put_device()</span><span style="color: #E6DB74; font-style: italic;"> &#26469;&#35299;&#38500;&#24341;&#29992;&#35745;&#25968;.</span>
<span style="color: #E6DB74; font-style: italic;"> */</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672; font-style: italic;">of_find_i2c_device_by_node</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">node</span>);
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672; font-style: italic;">of_find_i2c_adapter_by_node</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">device_node</span> *<span style="color: #F92672;">node</span>);

<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_master_send</span>(<span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672;">client</span>, <span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">buf</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">count</span>);
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_master_recv</span>(<span style="color: #66D9EF;">const</span> <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_client</span> *<span style="color: #F92672;">client</span>, <span style="color: #66D9EF;">char</span> *<span style="color: #F92672;">buf</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">count</span>);

<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">i2c_transfer</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_msg</span> *<span style="color: #F92672;">msgs</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">num</span>);
<span style="color: #465457; font-style: italic;">/// </span><span style="color: #465457; font-style: italic;">unclocked flavor</span>
<span style="color: #66D9EF;">extern</span> <span style="color: #66D9EF;">int</span> <span style="color: #F92672; font-style: italic;">__i2c_transfer</span>(<span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_adapter</span> *<span style="color: #F92672;">adap</span>, <span style="color: #66D9EF;">struct</span> <span style="color: #66D9EF;">i2c_msg</span> *<span style="color: #F92672;">msgs</span>, <span style="color: #66D9EF;">int</span> <span style="color: #F92672;">num</span>);
</pre>
</div>
</div>
</li>
<li><a id="sec-1-2-3-3" name="sec-1-2-3-3"></a>编写流程<br  /><div class="outline-text-5" id="text-1-2-3-3">
<p>
I2C总线上的设备有两种形态, 一种是设备全部使用I2C与系统通信, 一种是设备的I2C仅仅用于一部分, 还有另外一部分接口.
</p>

<p>
第二种形式的连接, 需要看哪个通信为主就以哪个为主要考虑驱动.
</p>

<p>
比如第一种形式, 设备树节点就是I2C总线的一个子节点:
</p>
<pre class="example">
&amp;i2c1{
    clocl-frequency = &lt;100000&gt;;
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;;
    status = "okay"
    ....
    pmic: pf0100@08{
          compatible = "fsl, pfuze100";
    };
};
</pre>

<p>
第二种形式, I2C仅仅是它的一个子功能
</p>
<pre class="example">
&amp;hdmi{
    ddc-i2c-bus = &lt;&amp;i2c2&gt;;
    status = "okay";
};
</pre>
</div>

<ol class="org-ol"><li><a id="sec-1-2-3-3-1" name="sec-1-2-3-3-1"></a>形式1的编写步骤(drivers/misc/eeprom/at24.c  drivers/regulator/fpuze100-regulator.c)<br  /><div class="outline-text-6" id="text-1-2-3-3-1">
<ul class="org-ul">
<li>根据设备的硬件连接, 设置其设备树.
</li>
</ul>
<pre class="example">
i2c0{
    status = "okay";
    clock-frequency = &lt;400000&gt;;
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_i2c0_default&gt;;

    i2cswitch@74 {
                 compatible = "nxp, pca9548";
                 #address-cells = &lt;1&gt;;
                 #size-cells = &lt;0&gt;;
                 reg = &lt;0x74&gt;;
                 i2c@0{
                    #address-cells = &lt;1&gt;;
                    #size-cells = &lt;0&gt;;
                    reg = &lt;2&gt;;
                    eeprom@&lt;54&gt;{
                        compatible = "at, 24c08";
                        reg = &lt;0x54&gt;;
                    };
                 };
    };
};
</pre>
<ul class="org-ul">
<li>定义一个 <code>struct i2c_driver</code> 变量, 并调用 module<sub>i2c</sub><sub>driver</sub> 将其注册到 I2C core 中
</li>
</ul>
<p>
该变量包含应该包含的DTS中的 compatible 字段相同的 of<sub>match</sub><sub>table</sub>, 以及一个 probe接口.
( <code>module_i2c_driver</code> 是一个宏, 自动完成了 <code>xxx_init, xxx_exit</code> 函数)
</p>
<ul class="org-ul">
<li>在 adapter 注册时, 会自动为它的 slave device 创建 <code>struct i2c_client</code> 结构, 并匹配 <code>struct i2c_driver</code> 变量, 调用对应的 probe接口.
</li>
<li>i2c<sub>driver</sub> 的 probe 接口的输入参数是 <code>struct i2c_client</code> 类型指针, 可以调用 <code>i2c_master_send/i2c_master_recv</code> 接口进行简单的I2C传输.同时也可以通过该指针获得所属的 i2c<sub>adapter</sub> 指针, 然后通过 i2c<sub>transfer</sub> 接口进行更为复杂的 read, write 操作.(参考 <code>drivers/base/regmap/regmap-i2c.c</code> 中的 regmap<sub>i2c</sub><sub>read</sub> 接口).
</li>
<li>实现I2C设备所对应类型的具体驱动. i2c<sub>device</sub> 只是实现设备与总线的挂接, 而如果此设备驱动兼容多种真实设备, 那就需要为对应的设备实现对应的 <code>read(), write(), ioctl()</code> 函数.一般来讲, 通过misc框架新建一个字符设备驱动即可.
</li>
</ul>
</div>
</li>
<li><a id="sec-1-2-3-3-2" name="sec-1-2-3-3-2"></a>形态2的编写步骤<br  /></li></ol>
</li></ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: cec</p>
<p class="date">Created: 2017-11-21 Tue 16:09</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>