* [What] kernel --> framework
参考网站: [[www.wowotech.net][窝窝科技]]

参考书籍: <<Linux设备驱动开发详解>>

- [[#%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86%E5%AD%90%E7%B3%BB%E7%BB%9F(clock)][时钟管理子系统(clock)]]
  + [[#driver%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8API(consumer)][driver使用通用API]]
  + [[#%E7%BC%96%E5%86%99clock%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91(provider)][编写clock通用逻辑(provider)]]
  + [[#%E7%BC%96%E5%86%99%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91][编写底层逻辑]]
- [[#I2C%E5%AD%90%E7%B3%BB%E7%BB%9F][I2C子系统]]
- [[#gpio subsystem][gpio subsystem]]
  + [[#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8][直接使用]]
  + [[#%E6%A6%82%E8%A7%88][概览]]
- [[#中断与时钟][中断与时钟]]


** 时钟管理子系统(clock)
commom clock framework 是用来管理系统 clock 资源的子系统, 根据职能由 *顶层到底层* 分为3个部分(很多框架的实现层次都是这种方式):
1. 向其他 driver 提供操作 clocks 的通用 API(就类似于I2C,SPI设备使用总线提供的操作函数一样)
2. 实现 clock 控制的通用逻辑, 这部分与硬件无关
3. 将和硬件相关的 clock 控制逻辑封装成操作函数集, 交由底层的 platform 开发者实现, 由通用逻辑调用.

很多芯片都具有时钟树,以满足不同设备的运行速度需求.参考熟悉的 STM32 的系统时钟树可以发现,其组成部分有:
- 外部晶体振荡器
- PLL
- 多路选择器
- 分频器
- 时钟使能

common clock framework 的管理对象就是这些可以调节的各个部分, 在软件中以 =struct clk= 来表示, 主要包括:
- 时钟使能和失能
- 设置时钟频率
- 设置时钟树的连接关系

*** driver使用通用API(consumer)
通用API位于 =include/linux/clk.h= 中.

**** 使用顺序
具体的时钟设备是通过设备树来表示的, 而clock框架通过读取当前设备接点的时钟描述, 而得到对应的具体时钟驱动.

对于使用者来说, 仅仅需要通过在设备节点添加时钟属性, 然后调用clock API即可, 不用关心内部的实现.

一般来说, 在设备树中会有先列出的整个系统时钟名称, 其他节点引用此名称即可:
#+begin_example
slcr: slcr@f8000000 {
  #address-cells = <1>;
  #size-cells = <1>;
  compatible = "xlnx, zynq-slcr", "syscon";
  reg = <0xf8000000 0x1000>;
  ranges;
  clkc: clkc:@100{
    #clock-cells = <1>;
    compatible = "xlnx, ps7-clkc";
    ps-clk-frequency = <33333333>;
    fclk-enable = <0>;
                          //  0       1         2          3
    clocl-output-names = "armpll", "ddrpll", "iopll", "cpu_6or4x",
                          //  4          5        6       7        8
                          "cpu_3or2x","cpu_2x","cpu_1x","ddr2x","ddr3x",
                          //9     10     11     12     13     14
                          "dci","lqspi","smc","pcap","gem0","gem1",
                          //15      16      17      18      19     20
                          "fclk0","fclk1","fclk2","fclk3","can0","can1",
                          //21      22       23     24      25     26
                          "sdio0","sdio1","uart0","uart1","spi0","spi1",
                          //27      28       29            30
                          "dma","usb0_aper","usb1_aper","gem0_aper",
                          //31           32            33
                          "gem1_aper","sdio0_aper","sdio1_aper",
                          //34            35          36          37
                          "spi0_aper","spi1_aper","can0_aper","can1_aper",
                          //38             39         40           41
                          "i2c0_aper","i2c1_aper","uart0_aper","uart1_aper",
                          //  42           43         44        45
                          "gpio_aper","lqspi_aper","smc_aper","swdt",
                          //46          47
                          "dbg_trc","dbg_apb";
     reg = <0x100 0x100>;
  };
};

sdhci0: sdhc@e0100000{
  compatible = "arasan, sdhi-8.9a";
  status = "disabled";
  /// 为下面两个引用时钟定义别名,用于 clk_get() 函数引用
  clock-names = "clk_xin", "clk_ahb";
  clocks = <&clkc 21>, <&clkc 32>;
  interrupt-parent = <&intc>;
  interrupts = <0 24 4>;
  reg = <0xe0100000 0x1000>;
};
#+end_example

**** API
***** 获取 strucl clk 
每个时钟对象都由一个 =struct clk= 结构体来表示, 这些结构体通过链表挂接在一起, 形成和时钟树一样的结构, 所以在操作时钟前, 首先需要通过设备树节点获取时钟.
#+BEGIN_SRC c
/**
 ,* @brief 以 device 指针或 id 字符串(可以看作name, 也就是设备节点中的 clock-names 属性)为参数, 查找clock
 ,* @note dev 和 id 任意一个可以为空, 如果 id 为空,则必须要有 device tree 支持.
 ,* id 可以是一个简单的名称, 也可以是一个预先定义的, 唯一标识(在平台提供的头文件中定义, 如 mach/clk.h);
 ,* @warning 不能在中断上下文中调用
 ,*/
struct clk *clk_get(struct device *dev, const char *id);
/**
 ,* @note 与get的反操作, 和 get 成对使用
 ,*/
void clk_put(struct clk *clk);
/**
 ,* @note 相比 clk_get ,此函数可以自动释放
 ,*/
struct clk *devm_clk_get(struct device *dev, const char *id);
void devm_clk_put(struct device *dev, struct clk *clk);
/**
 ,* @note 相比 clk_get , 使用设备名称代替 device 结构
 ,*/
struct clk *clk_get_sys(const char *dev_id, const char *con_id);
/**
 ,* @note 直接从对应的设备树节点中获取 clk
 ,*/
struct clk *of_clk_get(struct device_node *np, int index);
struct clk *of_clk_get_by_name(struct device_node *np, const char *name);
struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec);

#+END_SRC
***** 控制 clock
#+BEGIN_SRC c
/**
 ,*@note 启动和停止 clock 前的准备及善后工作, 可能会引起睡眠(等待PLL稳定的时间)
 ,* @warning 不能在中断处理中调用
 ,*/
int clk_prepare(struct clk *clk);
void clk_upprepare(struct clk *clk);

/**
 ,* @note 启动及停止clock,不会引起睡眠
 ,*/
static inline int clk_enable(struct clk *clk);
static inline void clk_disable(struct clk *clk);

/**
 ,* @note 此函数失上面4个函数的组合顺序为 prepare -> enable -> disable -> unprepared
 ,* @warning 这两个函数不能在原子操作中使用, 因为函数可能会引起睡眠
 ,*/
static inline int clk_prepare_enable(struct clk *lck);
static inline void clk_disable_upprepare(struct clk *clk);
/**
 ,* @note clock 频率的的获取和设置.
 ,* 并不一定会设置成功,因为分频比有限
 ,* @warning 为了确保设置成功, 需要先调用 clk_round_rate 获取理想设置值的实际设置值
 ,*/
static inline unsigned long clk_get_rate(struct clk *clk);
static inline int clk_set_rate(struct clk *clk, unsigned long rate);
static inline long clk_round_rate(struct clk *clk, unsigned long rate);

/**
 ,* @note 获取和选择父时钟,形成时钟树
 ,*/
static inline int clk_set_parent(struct clk *clk, struct clk *parent);
static inline struct clk *clk_get_parent(struct clk *clk);

#+END_SRC
***** 其他接口
#+BEGIN_SRC c
/**
 ,* @note 用于注册和注销一个消息,当clock rate 改变时, 就会通知此驱动.
 ,*/
int clk_notifier_register(struct clk *clk, struct notifer_block *nb);
int clk_notifier_unregister(struct clk *clk, struct notifer_block *nb);

/**
 ,* @brief 给 clk 起别名
 ,*/
int clk_add_alias(const char *alias, const char *alias_dev_name, char *id, struct device *dev);
#+END_SRC
**** 使用详解
参考: =Documentation/devicetree/bindings/clock/clock-bindings.txt=
***** 在 device tree 中设置需要使用的 clock
#+begin_example
/**
 ,* @note 此设备使用两个 clock, baud 取自 osc 的 1号通道, register 取自 ref 的 0号通道.
 ,* 用于 clk_get 使用名字来得到时钟结构体
 ,*/
device{
    clocks = <&osc 1>, <&ref 0>;
    clock-names = "baud", "register";
};
#+end_example
***** 系统解析
系统启动后, device tree 代码会解析 clock 有关的关键字, 并将解析后的信息放在 platform_device 相关的字段中.
***** driver 使用
具体的driver可以在probe的时候, 以clock的名称为参数, 调用 clk_get 接口, 获取clock的对象, 然后使用此对象为参数使用上述函数.
#+BEGIN_SRC c
int xxx_probe(struct platform_device *pdev)
{
        struct clk *baud_clk;
        int ret;

        baud_clk = devm_clk_get(&pdev->dev, "baud");
        if(IS_ERR(baud_clk))
        {
                ....
        }
        ret = clk_prepare_enable(baud_clk);
        if(ret)
        {
                ...
        }
}
#+END_SRC
*** 编写clock通用逻辑(provider)
**** 编写设备树
provider 的设备树有两种写法:
1. 将系统所有的clock抽象为一个虚拟的设备, 用一个节点表示, 称为 =clock controller=.
#+begin_example
clock:clock-controller@0x10030000{
    compatible = "samsung,exynos4210-clock";
    reg = <0x10030000 0x20000>;
    /// 为0时代表只有一个时钟输出, 为1时代表有多个时钟输出
    #clock-cells = <1>;
};

mct@10050000{
    compatible = "samsung, exynos4210-mct";
    ....
    /**
    ,* @note clk_get 方法读取 clocks 属性来得到对应的 struct clk 指针
    ,* 当 provider 节点中的 #clock-cells 属性为0时, 只需要提供一个 clock provider name(称为 phandle);
    ,* 为 1时, 则还需要额外提供一个序号. 可以在头文件中 define 这些序号, 比数字更加易懂.
    ,* clock-names 是为 clocks 中指定的两个时钟设置名称, 这样 clk_get 就可以直接使用此名称.
    ,*/
    clocks = <&clock 3>, <&clock 334>;
    clock-names = "fin_pll", "mct";
#+end_example
2. 将每个clock都分别表示一个节点, 而每一个节点即是 provider 也是 consumer（因为需要连接）
#+begin_example
clocks{
    #address-cells = <1>;
    #size-cells = <1>;
    ranges;
    dummy:dummy{
        #clock-cells = <0>;
        compatible = "fixed-clock";
        clock-frequency = <0>;
    };
    //root clock
    osc24M: osc24M@01c2005{
            #clock-cells = <0>;
            compatible = "allwinner, sun4i-soc-clk";
            reg = <0x01c20050 0x4>;
            clock-frequency = <24000000>;
    };
    //root clock
    osc32k:osc32k{
        #clock-cells = <0>;
        compatible = "fixed-clock";
        clock-frequency = <32768>;
    };
    /**
     ,* @note pll1 是provider 也是 consumer
    ,*/
    pll1:pll1@01c20000{
        #clock-cells = <0>;
        compatible = "allwinner,sun4i-pll1-clk";
        reg = <0x01c20000 0x4>;
        clock2 = <&osc24M>;
    };
    cpu: cpu@01c20054{
         #clock-cells = <0>;
         compatible = "allwinner, sun4i-cpu-clk";
         reg = <0x01c20054 0x04>;
         clocks = <&osc32k>, <&osc24M>,<&pll1>,<&dummy>;
    };
    /**
     ,* @note ahb_gates  是provider 也是 consumer
    ,*/
    ahb_gates:ahb_gates@01c20060{
        #clock-cells = <1>;
        compatible = "allwinner,sun4i-ahb-gates-clk";
        reg = <0x01c20060 0x08>;
        clocks = <&ahb>;
        /**
        ,* @warning: clock-output-names 关键字只是为了方便 clock privider 编程方便, consumer 不可见
        ,*/
        clock-output-names = "ahb_usb0", "ahb_ehci0",
        "ahb_ohci0", "ahb_ehi1"......
    };
};
#+end_example
**** API 
位于 =include/linux/clk_provider.h=
***** struct clk_hw
framework 提供了 struct clk_hw 结构, 用于从 clock　provider 的角度, 描述clock :
#+BEGIN_SRC c
struct clk_hw{
        struct clk　*clk;
        /// 用于描述一个 clock 的静态数据
        const struct clk_init_data *init;
};
/**
 ,* @param name: clock 的名称
 ,* @param ops: 该clock 的操作函数集
 ,* @param parent_names: 该clock所有的parent clock 的名称, 这是一个字符串数组
 ,* @param num_parents: parent 个数
 ,* @param flags : framework 级别的 flags
 ,*/
struct clk_init_data{
        const char  *name;
        const struct clk_ops *ops;
        const char **parent_names;
        u8   num_parents;
        unsigned long flags;
};
/**
 ,* @brief framework flags 可以使用或的关系
 ,*
 ,*/
#define CLK_SET_RATE_GATE                       BIT(0) ///在改变该 clock 的 rate时, 必须关闭
#define CLK_SET_PARENT_GATE                     BIT(1) /// 在改变该 clock 的 parent 时, 必须关闭
#define CLK_SET_RATE_PARENT                     BIT(2) /// 改变该 clock 的rate时, 要将改变传递到上层 parent
#define CLK_IGNORE_UNUSED                       BIT(3) /// 忽略 disable unused 的调用
#define CLK_IS_ROOT                             BIT(4) /// 该clcok 为 root clock, 没有parent
#define CLK_IS_BASIC                            BIT(5) /// 不再使用
#define CLK_GET_RATE_NOCAHE                     BIT(6) /// get rate 时, 不要从缓存中拿, 而是重新计算

struct clk_ops{
        int              (*prepare)(struct clk_hw *hw);
        void             (*unprepare)(struct clk_hw *hw);
        int              (*is_prepared)(struct clk_hw *hw);
        /// 自动清除没有被使用的时钟
        void             (*unprepare_unused)(struct clk_hw *hw);
        int              (*enable)(struct clk_hw *hw);
        void             (*disable)(struct clk_hw *hw);
        int              (*is_enabled)(struct clk_hw *hw);
        /// 自动失能没有被使用的时钟
        void             (*disable_unused)(struct clk_hw *hw);
        /// 重新计算并返回 clock rate
        unsigned long    (*recalc_rate)(struct clk_hw *hw, unsigned long parent_rate);
        long             (*round_rate)(struct clk_hw *hw, unsigned long, unsigned long *);
        int              (*set_parent)(struct clk_hw *hw, u8 index);
        u8               (*get_parent)(struct clk_hw *hw);
        int              (*set_rate)(struct clk_hw *hw, unsigned long, unsigned long);
        /// clock 被 register 时自动被调用
        void             (*init)(struct clk_hw *hw);
};
+END_SRC
***** clk_register
通过 register 将 struct clk_hw 注册到 kernel 中. *clock framework 的核心代码会把它们转换为 struct clk 变量*,
并以 tree 的形式组织起来.
#+BEGIN_SRC c
struct clk *clk_register(struct device *dev, struct clk_hw *hw);
struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw);

void clk_unregister(struct clk *clk);
void devm_clk_unregister(struct device *dev, struct clk *clk);
#+END_SRC 
***** clock 分类及register
根据 clock 的特点, clock framework 将 clock 分为fixed rate, gate, devider, mux, fixed factor, composite.六类.

每一类clock都有相似的功能, 相似的控制方式, 因而可以使用相同的逻辑, 统一处理.
- fixed rate clock
此类 clock 具有固定的频率, 不能开关, 不能调整频率, 不能选择 parent, 不需要提供任何的 =clk_ops= 回调函数, 是最简单的一类 clock.

可以直接通过设备树配置, *clock framework core 直接从设备树中解出 clock 信息, 并自动注册到 kernel, 不需要任何driver支持*.

framework 使用 struct clk_fixed_rate 结构来表示这种 clock, 另外提供了一个接口, 可以直接注册.
#+begin_example
/// provider
ad9361_clkin:ad9361_clock@0{
    #clock-cells = <0>;
    compatible = "fixed-clock";
    clock-frequency = <40000000>;
    clock-output-names = "ad9361_ext_refclk";
};

/// consumer
adc_9361@0{
    #address-cells = <1>;
    #size-cells = <0>;
    compatible = "adi,ad9361";

    clocks = <&ad9361_clkin 0>;
    clock-names = "ad9361_ext_refclk";
};

#+end_example
#+BEGIN_SRC c
/**
 ,* @note 只要在设备树中定义了时钟节点,那么下面这些函数则不用关心
 ,*/
struct clk_fixed_rate{
        struct clk_hw hw;
        unsigned long fixed_rate;
        u8 flags;
};

extern const struct clk_ops clk_fixed_rate_ops;
struct clk *clk_register_fixed_rate(struct device *dev, const char *name,
                                    const char *parent_name, unsigned long flags,
                                    unsigned long fixed_rate);
#+END_SRC
- gate clock
此类 clock 只可开关(使用 enable/disable 函数),使用下面的函数注册:
#+BEGIN_SRC c
/**
 ,* @param name : clock 名称
 ,* @param parent_namei : parent clock 名称, 如果没有则为 NULL
 ,* @param flags : 同上
 ,* @param reg : 控制 clock开关的虚拟地址
 ,* @param bit_idx : 控制bit位(是1 开还是0开).
 ,* @param clk_gate_flags: 当为 CLK_GATE_SET_TO_DISABLE, 表示写1关闭 clock
 ,* @param lock : 如果开关需要互斥, 可以提供一个 spinlock
 ,*/
struct clk *clk_register_gate(struct device *dev, const char *name,
                              const char *parent_name, unsigned long flags,
                              void __iomem *reg, u8_bit_idx,
                              u8 clk_gate_flags, spinlock_t *lock);
#+END_SRC
- divider clock
此类 clock 可以设置分频值(因而会提供 recalc_rate/ set_rate/ round_rate 回调).
#+BEGIN_SRC c
/**
 ,* @param shift : 控制分频比的位在寄存器中的偏移
 ,* @param width : 分频比的位数
 ,* @param clk_divider_flags:
 ,* CLK_DIVIDER_ONE_BASED: 实际 divider 的值就是寄存器的值
 ,* CLK_DIVIDER_POWER_OF_TWO: 实际的 divider 值是寄存器值的2次方
 ,* CLK_DIVIDER_ALLOW_ZERO:  divider 值可以位0
 ,*/
struct clk *clk_register_divider(struct device *dev, const char *name,
                                 const char *parent_name, unsigned long flags,
                                 void __iomem *reg, u8 shift, u8 width,
                                 u8 clk_divider_flags, spinlock_t *lock);

/**
 ,* @brief 用于注册不规则的分频 clock
 ,*/
struct clk *clk_register_divider_table(struct device *dev, const char *name,
                                       const char *parent_name, unsigned long flags,
                                       void __iomem *reg, u8 shift, u8 width,
                                       u8 clk_divider_flags, const struct clk_div_table *table,
                                       spinlock_t *lock);
struct clk_div_table{
        unsigned int val;    /// 寄存器的值
        unsigned int div;   /// 对应的分频值
};
#+END_SRC
- mux clock
这是一个多通道选择的时钟, 所以这类 clock 可以选择多个 parent, 需要 =get_parent, set_parent, recal_rate= 函数支持.
#+BEGIN_SRC c
/**
 ,* @param parent_names :  字符串数组, 描述所有可能的 parent
 ,* @param num_parents : parent 个数
 ,* @param shift, width : 选择 parent 的寄存器的偏移,宽度.默认寄存器值为0对应第一个 parent
 ,* @param clk_mux_flags :
 ,* CLK_MUX_INDEX_ONE: 寄存器值不是从0开始, 而是从1开始
 ,* CLK_MUX_INDEX_BIT :寄存器的值为 2 的幂; 
 ,*/
struct clk *clk_register_mux(struct device *dev, const char *name,
                             const char **parent_names, u8 num_parents, unsigned long flags,
                             void __iomem *reg, u8 shift, u8 width,
                             u8 clk_mux_flags, spinlock_t *lock);

/**
 ,* @brief : 注册 mux 控制不规则的 lock
 ,*/
struct clk *clk_register_mux_table(struct device *dev, const char *name,
                                   const char **parent_names, u8 num_parents, unsigned long flags,
                                   void __iomem *reg, u8 shift, u32　mask,
                                   u8 clk_mux_flags, u32 *table, spinlock_t *lock);
#+END_SRC

- fixed factor clock
此类 clock 具有固定的 factor(即 multiplier 和 divider), 虽然 mult 和 divider 不可变, 但是由于parent可变, 所以也会提供 recalc_rate, set_rate, round_rate 等回调).可以直接在设备树中配置即可, 底层自动使用下面的函数.
#+BEGIN_SRC c
struct clk *clk_register_fix_factor(struct device *dev, const char *name,
                                    const char *parent_name, unsigned long flags,
                                    unsigned int mult, unsigned int div);
#+END_SRC
- composite lock
是 mux,divider,gate 等 clock的组合,所以如下接口注册
#+BEGIN_SRC c
struct clk *clk_register_composite(struct device *dev, const char *name,
                                   const char **parent_names, int num_parents,
                                   struct clk_hw *mux_hw, const struct clk_ops *mux_ops,
                                   struct clk_hw *rate_hw, const struct clk_ops *rate_ops,
                                   struct clk_hw *gae_hw, const struct clk_ops *gate_ops,
                                   unsigned long flags);
#+END_SRC
***** 设备树相关API
provider 需要将clock的对应信息告知 framework 的 OF 模块, 这样才可以帮助将 consumer 的DTS转换为对应的 struct clk结构.
#+BEGIN_SRC c
/**
 ,* @param np : 对应的设备树结点
 ,* @param clk_src_get: 获取 struct clk指针的回调函数
 ,* @param args : 在设备树中获取到的参数 比如: clocks = <&clock 32>, <&clock 45>
 ,* @param data : 保存 struct clk 的指针
 ,* @param data : 
 ,*/
int of_clk_add_provider(struct device_node *np,
                        struct clk *(*clk_src_get)(struct of_phandle_args *args, void *data, void *data);

/**
 ,* @note: 对于所有时钟都以列表方式存在节点中时,clock framework core 提供一个默认的会调用的函数
 ,*
 ,*/
struct clk_onecell_data{
        struct clk **clks;
        unsigned int clk_num;
};
struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data);
#+END_SRC
**** 编写步骤
1. 分析硬件的 clock tree, 按照 framework 中的 clock 的类别, 将它们分类
2. 将 clock_tree 在DTC中描述出来. 
   - 对于 fixed rate clocks. compatible 中固定为 "fixed-clock", 并提供 "clock-frequency" , "clock-out-names" 关键字.之后不需要在 driver 中做任何处理, framework会帮助我们搞定.
   - 对于 fixed factor clock. compatible 为 "fixed-factor-clock", 并提供 "clock-div", "clock-mult", "clock-output-names".然后交给 framework 搞定
3. 对于不能由 framework 处理的 clock, 需要在driver中使用 struct of_device_id 进行匹配, 并在初始化时调用 OF模块,查找所有的 DTS匹配项, 并执行register.
4. 注册 clock 的同时, 将返回 struct clk指针, 保存在一个数组中, 并使用 =of_clk_add_privider= 告知 framework.
*** 编写底层逻辑
**** 分析 struct clk 结构
#+BEGIN_SRC c
/**
 ,* @param parent :该clock当前的parent clock 的 struct clk 指针
 ,* @param parents: 保存所有可能的 parent clock 的 struct clk 指针
 ,* @param rate: 当前 clock rate
 ,* @param new_rate: 新设置的 clock rate
 ,* @param enable_count, prepare_count: 被enable和 prepare 的次数, 用于确保和 disable/unprepare 成对调用
 ,* @param children : children clocks, 以链表的形式组织
 ,* @param child_node: 一个 list node, 自己作为child 时, 挂到 parent 的 children list 时使用
 ,* @param notifier_count: 记录注册到notifier的个数
 ,*/
struct clk{
        const char              *name;
        const struct clk_ops *ops;
        struct clk_hw            *hw;
        struct clk                 *parent;
        const char               **parent_names;
        struct clk                **parents;
        u8                          num_parents;
        unsigned long      rate;
        unsigned long      new_rate;
        unsigned long      flags;
        unsigned int         enable_count;
        unsigned int         prepate_count;
        struct hlist_head  children;
        struct hlist_node  child_node;
        unsigen int           notifier_count;
        #ifdef CONFIG_COMMON_CLK_DEBUG
        struct dentry        *dentry;
        #endif
};
#+END_SRC
**** clock register/unregister
***** clk_register
clk_register 是所有 register 接口的共同实现, 负责将 clock 注册到 kernel, 并返回代表该 clock 的strcut clk 指针.
#+BEGIN_SRC c
struct clk *clk_register(struct device *dev, struct clk_hw *hw)
{
        int i, ret;
        struct clk *clk;
        clk = kzalloc(sizeof(*clk), GPF_KERNEL);
        if(!clk)
        {
                pr_err("%s: could not allocate clk\n", __func__);
                ret = -ENOMEM;
                goto fail_out;
        }
        clk->name = kstrdup(hw->init->name, GFP_KERNEL);
        if(!clk->name)
        {
                pr_err("%s, could not allocate clk->name\n", __func__);
                ret = -ENOMEM;
                goto fail_name;
        }
        clk->ops = hw->init->ops;
        if(dev && dev->driver)
                clk->owner = dev->driver->owner;
        clk->hw = hw;
        clk->flags = hw->init->flags;
        clk->num_parents = hw->init->num_parents;
        hw->clk = clk;

        clk->parent_names = kcalloc(clk->num_parents, sizeof(char *), GFP_KERNEL);

        if(!clk->parent_names)
        {
                pr_err("%s: could not allocate clk->parent_names\n", __func__);
                ret = -ENOMEM;
                goto fail_parent_names;
        }
        for( i = 0; i < clk->num_parents; i++)
        {
                clk->parent_names[i] = kstrdup(hw->init->parent_names[i], GFP_KERNEL);
                if(!clk->parent_names[i])
                {
                        pr_err("%s: could not copy parent_names\n", __func__);
                        ret = -ENOMEM;
                        goto fail_parent_names_copy;
                }
        }

        ret = __clk_init(dev, clk);
        if(!ret)
                return clk;

fail_parent_names_copy:
        while(--i >= 0)
                kfree(clk->parent_names[i]);
        kfree(clk->parent_names);
fail_parent_names:
        kfree(clk->name);
fail_name:
        kfree(clk);
fail_out:
        return ERR_PTR(ret);
             
}
EXPORT_SYMBOL_GPL(clk_register);
#+END_SRC
** I2C子系统
*** 总体概览
Linux 的 I2C 体系结构分为3个组成部分:
- I2C核心
I2C核心提供了I2C总线驱动和设备驱动的注册和注销方法, I2C通信方法, 上层的与具体适配器无关的代码以及探测设备, 检测设备地址的上层代码等.
- I2C总线驱动
所谓的总线驱动也就是I2C控制器的驱动, 与之相关的有 =I2C控制器数据结构i2c_adapter=, =I2C控制器的算法数据结构i2c_algorithm=, =控制I2C控制器产生通信信号的函数=.

经由I2C总线驱动的代码, 我们可以控制I2C控制器以主机的方式产生开始位, 停止位, 读写操作, 以及以从机的方式被读写, 产生ACK, NACK等.

I2C控制器一般是直接挂接在CPU总线上的, 所以其驱动也是 =platform_driver=.
- I2C设备驱动
I2C设备也就是与控制器相连接的设备.与之相关的有 =i2c_driver=, =i2c_client= 数据结构, 以及对应的功能函数.

在Linux系统中, I2C设备及驱动位于 =/sys/bus/i2c/= 文件夹下.

在Linux源码中, i2c驱动目录具有如下结构:
- i2c-core.c / i2c-core.h
实现了I2C的核心功能以及 =/proc/bus/i2c*= 的接口
- i2c-dev.c
实现了I2C控制器设备文件的功能, 每个I2C控制器都被分配一个设备.通过控制器访问设备时的主设备号位89, 次设备号为 0~255.
也就是说, 此文件提供了通用的接口, 应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间和寄存器, 并控制设备的工作方式.

应用程序通过 =i2c-%d= (i2c-0, i2c-1,....)文件名并使用文件操作接口 open(), write(), read(), ioctl(), close() 等来访问这个设备.

*当然,使用此文件就需要在用户代码中设置好设备的操作地址, 具体寄存器操作.虽然说可以省事, 但没有实现很好的分层.*
- busses
此文件夹包含了I2C控制器的驱动
- algos
实现了一些I2C控制器的通信方法.也就是I2C协议包生成的逻辑, 一般都是由硬件来实现.
- i2c.h (include/linux/)
提供对 =i2c_adapter, i2c_algorithm, i2c_driver, i2c_client= 数据结构的定义.

总体的软件拓扑抽象层次如下图所示:

[[i2c_softTopology.bmp][I2C软件拓扑]]

整个构架的软件层次如下图所示:

[[i2c_framework.bmp][I2C框架]]

经过I2C framework 的抽象, consumer 可以不用关心I2C总线的技术细节, 只需要通过简单的API, 就可以与 slave devices 进行数据交互.
正常情况下, consumer 是位于内核态的其他driver. 于此同时, I2C framework也通过字符设备向用户空间提供类似的接口, 用户空间程序可以通过该接口访问 slave devices.

I2C core 使用 =i2c_adapter,i2c_algorithm= 抽象I2C控制器的功能, =i2c_driver, i2c_client= 抽象 I2C slave device 的功能.
另外, 基于I2C协议, 通过 smbus 模块实现 SMBus的功能.

[[./i2c_smbus.bmp][i2c & smbus]]

I2C muxes 用于实现I2C BUS的多路复用功能, 实际使用较少.
*** 控制器驱动的编写
**** 数据结构
与控制器驱动密切相关的就是 =i2c_adapter, i2c_algorithm= 结构体, 具体描述一下:
#+BEGIN_SRC c
/**
 ,* @brief struct i2c_msg - an I2C transaction segment beginning with START(用户空间也可以用)
 ,* @brief addr -> 从机地址,支持7位或者10位, 10位时需要使用 I2C_M_TEN标记,以及驱动返回 I2C_FUNC_10BIT_ADDR
 ,* @brief flags -> 标明此次传输标记
 ,* @brief len -> 读取或者写入的字节数
 ,* @brief buf -> 读写缓存
 ,*/
struct i2c_msg{
        __u16 addr;
        __u16 flags;
#define I2C_M_TEN 0x0010 /// this is a ten bit chip address
#define I2C_M_RD 0x0001 /// read data, from slave to master
#define I2C_M_STOP 0x8000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_NOSTART 0x4000 /// if I2C_FUNC_NOSTART
#define I2C_M_REV_DIR_ADDR 0x2000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_IGNORE_NAK 0x1000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_NO_RD_ACK 0x0800 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_RECV_LEN 0x0400 /// length will be first received byte
        __u16 len;
        __u8 *buf;
};
/**
 ,* @brief struct i2c_algorithm - represent I2C transfer method(对应一套通信协议)
 ,* @param master_xfer -> I2C传输函数
 ,* @param smbus_xfer -> smbus传输函数
 ,* @param functionality -> 返回 algorithm/adapter 所支持的功能, I2C_FUNC_XXX
 ,* @param reg_slave / unreg_slave -> 注册及注销从设备
 ,* @note 关于 master_xfer 的错误返回说明文件位于 Documentation/i2c/fault-codes
 ,*/
struct i2c_algorithm{
        int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
        int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr, unsigned short flags,
                          char read_write, u8 command, int size, union i2c_smbus_data *data);
        u32 (*functionality)(struct i2c_adapter *);
#if IS_ENABLED(CONFIG_I2C_SLAVE)
        int (*reg_slave)(struct i2c_client *client);
        int (*unreg_slave)(struct i2c_client *client);
#endif
};
/**
 ,* @brief i2c_adapter is the structure used to identify a physical i2c bus along with
 ,* the access algorithms necessary to access it.(代表控制器)
 ,* @param class -> 此驱动所支持的设备类型(I2C_CLASS_HWMON, I2C_CLASS_DDC....)
 ,* @param timeout -> 当重试超过一定时间(jiffies), 停止重试
 ,* @param retries -> 设定当传输失败时, 重试传输的次数
 ,* @param nr -> 此控制器的ID, 一般由设备树解析.
 ,*/
struct i2c_adapter{
        struct module *owner;
        unsigned int class;
        const struct i2c_algorithm *algo;
        void *algo_data;
        
        struct rt_mutex bus_lock;
        
        int timeout;
        int retries;
        struct device dev;
        
        int nr;
        char name[48];
        struct completion dev_released;
        struct mutex userspace_clients_lock;
        struct list_head userspace_clients;
        
        struct i2c_bus_recovery_info *bus_recovery_info;
        const struct i2c_adapter_quirks *quirks;
};

#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)
#+END_SRC
**** 传输标志
一般情况下, i2c_msg 中的 flag 为0, 也就是按照标准传输方式, 具体如下表(表明了 master_xfer() 的执行流程):

[] 表示从机返回.
| 标记              | 读写 | 协议                                                       |
|-------------------+------+------------------------------------------------------------|
| 0                 | 写   | S Addr_Wr [A] Data [A].....Data [A] P                      |
| 0                 | 读   | S Addr_Rd [A] Data [A].....Data NA P                       |
| 0                 | 混合 | S Addr_Rd [A] [Data] NA S Addr_Wr [A] Data [A] P           |
| I2C_M_IGNORE_NAK  |      | 读取操作时, 忽略 slave 返回的 NA, 把它当作 ACK信号继续读取 |
| I2C_M_NO_RD_ACK   |      | 读取的时候忽略所有的 A 和 NA                               |
| I2C_M_NOSTART     | 混合 | S Addr_Rd [A] [Data] NA +S Addr_Wr [A]+ Data [A] P         |
| I2C_M_REVDIR_ADDR |      | 读写翻转, 读的时候发 Wr 信号, 写的时候发 Rd 信号           |
| I2C_M_STOP        |      | 传输完一个 msg 后发送一个 STOP 信号                        |

对应的 master_xfer() 模板类似于:
#+BEGIN_SRC c
static int i2c_adapter_xxx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
{
        ...
        for(i = 0; i < num; i++)
        {
                i2c_adapter_xxx_start();

                if(msgs[i]->flags & I2C_M_RD)
                {
                        i2c_adapter_xxx_setaddr((msgs[i]->addr << 1) | 1);
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_readbytes(msgs[i]->buf, msgs[i]->len);
                        
                }
                else
                {
                        i2c_adapter_xxx_setaddr((msgs[i]->addr <<1));
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_writegbytes(msgs[i]->buf, msgs[i]->len);
                }
        }
        i2c_adapter_xxx_stop();
}
#+END_SRC
**** 函数接口
控制器驱动可以使用的接口.
#+BEGIN_SRC c
/**
 ,* @brief 将此 adapter 注册进内核, 内核自动分配ID号
 ,*/
extern int i2c_add_adapter(struct i2c_adapter *);
/// 与上面相比, 需要主动提供一个ID号
extern int i2c_add_numbered_adapter(struct i2c_adapter *);
/**
 ,* @brief 将此 adapter 从内核中删除
 ,*/
extern void i2c_del_adapter(struct i2c_adapter *);
/**
 ,* @brief 获取 adapter 所支持的功能
 ,*/
static inline u32 i2c_get_functionality(struct i2c_adapter *adap);
/**
 ,* @brief 检查 adapter 是否具备指定的功能
 ,*/
static inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func);
/**
 ,* @brief 获取 adapter ID
 ,*/
static inline int i2c_adapter_id(struct i2c_adapter *adap);
/**
 ,* @brief 根据 adapter ID 获取 adapter
 ,*/
extern struct i2c_adapter *i2c_get_adapter(int nr);
/// 与上面函数需要成对使用
extern void i2c_put_adapter(struct i2c_adapter *adap);
/**
 ,* @brief 通过 device_node 查找对应的 adapter 结构, 使用完成后需要使用 put_device 函数减去计数
 ,*/
extern struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);

#+END_SRC
***** i2c_add_adapter 流程

- 分配ID
当用户主动分配ID时, 则是执行的以下流程:

i2c_add_numbered_adapter --> __i2c_add_numbered_adapter --> i2c_register_adapter 

当用户选择自动分配ID时, 则使用 =i2c_add_adapter= 函数, 此函数会首先搜寻设备树中的 alias ID, 比如 =i2c0=,
如果没有搜到, 则使用 =idr_alloc= 分配一个ID.
- 创建设备
adapter ID 分配完后, 或执行 =i2c_register_adapter= ,该接口会在 =/sys/devices/xxxxx.i2c/= 中创建该 adapter 的目录(/sys/devices/xxxxx.i2c/i2c-n).
#+BEGIN_SRC c
/**
 ,* @note 经过以下几步, 最终在 /sys/bus/i2c/devices/ 中创建对应的符号链接
 ,*/
dev_set_name(&adap->dev, "i2c-%d", adap->nr);
adap->dev.bus = &i2c_bus_type;
adap->dev.type = &i2c_adapter_type;

/// device_register --> device_add --> bus_add_device --> sysfs_create_link
res = device_register&adap->dev);

#+END_SRC
- I2C slave device 的创建和注册
I2C adapter 注册的时候, 会为它下面所有的 slave device 创建一个 =struce i2c_client= 结构, 并注册到 I2C bus.

i2c_register_adapter --> of_i2c_register_devices --> i2c_new_device 

**** 编写步骤(drivers/i2c/busses/i2c-cadence.c)
编写驱动需要填充 =i2c_adapter= 结构体, 所以顺序如下:
- 在设备树文件中, 提供控制器节点的定义:
#+begin_example
i2c0: i2c@44e0b000{
      compatible = "ti, omap4-i2c";
      #address-cells = <1>;
      #size-cells = <0>;
      ti,hwmods = "i2c1";
      reg = <0x44e0b000 0x1000>;
      interrupt = <70>;
      status = "disabled";
};
#+end_example
- 在 =deiver/i2c/busses= 目录下新建 =i2c-xxx.c= 驱动文件, 并编写 platform driver 的基本结构.
- 定义一个 =struct i2c_algorithm= 结构, 并根据控制器填充回调函数(functionality(), master_xfer())
- 在 platform driver 的 probe 函数中, 分配一个 adapter 结构, 并初始化. 
- 调用 =i2c_add_adapter / i2c_add_numbered_adapter= 结构将其注册到内核.
#+BEGIN_SRC c
static int xxx_i2c_probe(struct platform_device *pdev)
{
        struct i2c_adapter *adap;

        ...
        xxx_adapter_hw_init();
        adap->dev.parent = &pdev->dev;
        adap->dev.of_node = pdev->dev.of_node;

        rc = i2c_add_adapter(adap);
        ...
}
static int xxx_i2c_remove(struct platform_device *pdev)
{
        ...
        xxx_adapter_hw_free();
        i2c_dev_adapter(&dev->adapter);

        return 0;
}
static const struct of_device_id xxx_i2c_of_match[] = {
        {.compatible = "vendor, xxx-i2c",},
        {},
};
MODULE_DEVICE_TABLE(of, xxx_i2c_of_match);

static struct platform_driver xxx_i2c_driver =
{
        .driver = {
                .name = "xxx-i2c",
                .owner = THIS_MODULE,
                .of_match_table = xxx_i2c_of_match,
        },
        .probe = xxx_i2c_probe,
        .remove = xxx_i2c_remove,
};
module_platform_driver(xxx_i2c_driver);
#+END_SRC
*** 设备驱动的编写
**** 数据结构
I2C framework 使用 =struct i2c_client= 抽象 i2c slave device:
#+BEGIN_SRC c
/**
 ,* @brief struct i2c_client - represent an I2C slave device
 ,* @param flags -> I2C_CLIENT_TEN 代表使用10位地址, I2C_CLIENT_PEC 使用SMBus 错误检查
 ,* @param addr -> 设备的地址
 ,* @param name -> 设备名称
 ,* @param afapter -> 挂载的控制器
 ,* @param detected -> 挂接同一总线上的设备链表
 ,*/
struct i2c_client{
        unsigned short flags;
        unsigned short addr;
        char name[I2C_NAME_SIZE];
        struct i2c_adapter *adapter;
        struct device dev;
        int irq;
        struct list_head detected;
#if IS_ENABLE(CONFIG_I2C_SLAVE)
        i2c_slave_cb_t slave_cb;
#endif
};
/**
 ,* @brief struct i2c_driver - represent an I2C device driver
 ,* @param class -> 表示此驱动支持哪种类型的I2C设备
 ,* @param attach_afapter -> (此函数不再使用)
 ,* @param probe -> 绑定设备的回调
 ,* @param remove -> 卸载设备的回调
 ,* @param shutdown -> 关闭设备的回调
 ,* @param alert -> 警告
 ,* @param command -> callback for bus-wide signaling(optional)
 ,* @param id_table -> 列出此驱动支持的I2C设备, 总线驱动函数 i2c_device_match() 中会调用 i2c_match_id()
 ,* 函数匹配用户定义的ID 和 驱动ID
 ,* @param decetct -> 用于检测设备的回调
 ,* @param address_list -> 已经挂载的I2C设备地址.
 ,* @param clients: 链接所有已经挂载的设备
 ,*/
struct i2c_driver{
        unsigned int class;
        int (*attach_adapter)(struct i2c_adapter *) __deprecated;
        int (*probe)(struct i2c_client *, const struct i2c_device_id *);
        int (*remove)(struct i2c_client *);
        void (*shutdown)(struct i2c_client *);
        void (*alert)(struct i2c_client *, unsigned int data);
        int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);
        struct device_driver driver;
        const struct i2c_device_id *id_table;
        int (*detect)(struct i2c_client *, struct i2c_board_info *);
        const unsigned short *address_list;
        struct list_head clients;
};
#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)
#+END_SRC

**** 函数接口
#+BEGIN_SRC c
/**
 ,* @brief 通过设备树获取对应的 client 或者 adapter
 ,* @note 使用此函数后, 必须调用 put_device() 来解除引用计数.
 ,*/
extern struct i2c_client *of_find_i2c_device_by_node(struct device_node *node);
extern struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);

extern int i2c_master_send(const struct i2c_client *client, const char *buf, int count);
extern int i2c_master_recv(const struct i2c_client *client, char *buf, int count);

extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
/// unclocked flavor
extern int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);


#+END_SRC
**** 编写流程
I2C总线上的设备有两种形态, 一种是设备全部使用I2C与系统通信, 一种是设备的I2C仅仅用于一部分, 还有另外一部分接口.

第二种形式的连接, 需要看哪个通信为主就以哪个为主要考虑驱动.

比如第一种形式, 设备树节点就是I2C总线的一个子节点:
#+begin_example
&i2c1{
    clocl-frequency = <100000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c1>;
    status = "okay"
    ....
    pmic: pf0100@08{
          compatible = "fsl, pfuze100";
    };
};
#+end_example

第二种形式, I2C仅仅是它的一个子功能
#+begin_example
&hdmi{
    ddc-i2c-bus = <&i2c2>;
    status = "okay";
};
#+end_example

***** 形式1的编写步骤(drivers/misc/eeprom/at24.c  drivers/regulator/fpuze100-regulator.c)
- 根据设备的硬件连接, 设置其设备树.
#+begin_example
i2c0{
    status = "okay";
    clock-frequency = <400000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c0_default>;

    i2cswitch@74 {
                 compatible = "nxp, pca9548";
                 #address-cells = <1>;
                 #size-cells = <0>;
                 reg = <0x74>;
                 i2c@0{
                    #address-cells = <1>;
                    #size-cells = <0>;
                    reg = <2>;
                    eeprom@<54>{
                        compatible = "at, 24c08";
                        reg = <0x54>;
                    };
                 };
    };
};
#+end_example
- 定义一个 =struct i2c_driver= 变量, 并调用 module_i2c_driver 将其注册到 I2C core 中
该变量包含应该包含的DTS中的 compatible 字段相同的 of_match_table, 以及一个 probe接口.
( =module_i2c_driver= 是一个宏, 自动完成了 =xxx_init, xxx_exit= 函数)
- 在 adapter 注册时, 会自动为它的 slave device 创建 =struct i2c_client= 结构, 并匹配 =struct i2c_driver= 变量, 调用对应的 probe接口.
- i2c_driver 的 probe 接口的输入参数是 =struct i2c_client= 类型指针, 可以调用 =i2c_master_send/i2c_master_recv= 接口进行简单的I2C传输.同时也可以通过该指针获得所属的 i2c_adapter 指针, 然后通过 i2c_transfer 接口进行更为复杂的 read, write 操作.(参考 =drivers/base/regmap/regmap-i2c.c= 中的 regmap_i2c_read 接口).
- 实现I2C设备所对应类型的具体驱动. i2c_device 只是实现设备与总线的挂接, 而如果此设备驱动兼容多种真实设备, 那就需要为对应的设备实现对应的 =read(), write(), ioctl()= 函数.一般来讲, 通过misc框架新建一个字符设备驱动即可.
***** 形态2的编写步骤
** gpio subsystem
*** 直接使用
参考文档 =Documentation/gpio/=.
**** 设备树的设置
当一个驱动中需要使用到GPIO时, 需要在对应 *设备节点里面加入GPIO节点*.

节点的格式为: [function]-gpios = <&[gpio_node_name] [gpio_index] [gpio_initialize]>
- [function] : 用于driver 中对应function 申请此IO
- [gpio_node_name] : 定义 GPIO 节点的名称
- [gpio_index] : 指明需要使用第几个GPIO
- [gpio_initialize]: 指定GPIO的初始状态, *此值需要参考对应控制器设备树文档*.
#+begin_example
foo_device{
    compatible = "acme, foo";
    ...
    leg-gpios = <&gpio 15 GPIO_ACTIVE_HIGH>,
                <&gpio 16 GPIO_ACTIVE_HIGH>,
                <&gpio 17 GPIO_ACTIVE_HIGH>;

    power-gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
};
#+end_example
**** 获取GPIO的操作权限
#+BEGIN_SRC c
struct gpio_desc *red, *green, *blue, *power;

red = gpiod_get_index(dev, "led", 0, GPIOD_OUT_HIGH);
green = gpiod_get_index(dev, "led", 1, GPIOD_OUT_HIGH);
blue = gpiod_get_index(dev, "led", 2, GPIOD_OUT_HIGH);

power = gpiod_get(dev, "power", GPIOD_OUT_HIGH);
#+END_SRC
*** 概览
根据SOC控制GPIO用途, 可以分为3类:
1. pin controller : 此类寄存器用于控制GPIO功能的选择.
  + 配置引脚属于哪种功能: 是普通GPIO还是使用复用功能
  + 配置引脚特性: 是上拉还是下拉
2. GPIO controller : 当 =pin controller= 控制为普通GPIO时, 使用此类寄存器
  + 配置是输入还是输出
  + 如果是输出, 配置输出高还是低
  + 如果是输入, 那么就可以读取电平值
3. interrupt controller: 当GPIO具有中断功能时, 使用此类寄存器
  + 控制中断使能还是失能
  + GPIO的触发方式
  + 中断状态的清除

根据SOC的不同, 控制器以及控制方式不同, 并且芯片外围也可能接上GPIO扩展芯片等等.

为了抽象这些差异, linux kernel 提供了 =GPIO subsystem= , 此系统具有3个软件模块来对应3种控制器分类:
1. pin control subsystem: 驱动 =pin controller= 的软件子系统
2. GPIO subsystem: 驱动 =GPIO controller= 的软件子系统
3. GPIO interrupt chip driver: 此部分作为 =interrupt subsystem= 中的一个底层硬件驱动模块存在.

**** pin control subsystem 
[[pin_control_subsystem.jpg]]

- 内核中的其他驱动,通过调用 =pin control core= 模块的接口就可以控制GPIO功能选择.
- =pin control core= 是硬件无关模块, 它抽象了所有 =pin controller driver= 的不同硬件特性, 统一操作接口
- =pin controller driver= 就是针对不同硬件的驱动.

**** gpio subsystem
[[gpio_subsystem.jpg]]

- 内核中的其他驱动调用 =gpio lib= 提供的接口来操作GPIO
- =gpio lib= 抽象 =gpio controller driver= 的不同硬件特性, 统一操作接口
- =gpio controller driver= 就是针对不同硬件的驱动
*** 分析
**** pin control subsystem 
***** 文件位置
此子系统位于 =linux/drivers/pinctrl= 文件夹下,具有以下源文件:
- core.c / core.h : 核心代码
- pinctrl-utils.c / pinctrl-utils.h : 组合的功能函数 
- pinmux.c / pinmux.h : 端口复用
- pinconf.c / pinconf.h : 配置
- devicetree.c / devicetree.h : 设备树解析
- pinctrl-xxxx.c  : 底层驱动

与之相关的头文件位于 =linux/include/linux/pinctrl=:
- consumer.h : 用于其他驱动调用, 可以设置复用功能,电气特性等
- devinfo.h : struct device 中包含了 =struct dev_pin_info *pins=, 用于表示引脚的初始状态信息.
- machine.h : 与 machine 模块的接口
- pinconf-generic.h : 提供给 pin control driver 
- pinconf.h / pinctrl-state.h / pinmux.h : 提供给pin control driver

***** 整体框架
pin control subsystem 的功能包括:
- 管理系统中 *所有可以控制的pin*, 在系统初始化的时候, 枚举所有可以控制的pin, 并标识这些pin.
- 管理系统中 *所有pin的复用*, 有些pin需要几个组合起来形成一个 =pin group=.
- 管理系统中 *所有pin的特性*, 比如上下拉,驱动能力等.

[[pin_control_and_other.jpg]]

[[pin_control_diagram.jpg]]

上图表示的是各个模块之间的关系.
***** 向其他模块提供的接口
对于其他模块, 调用 =pin control subsystem= 一般具有以下需求:
1. 设置端口基本功能, GPIO的映射功能由 function 和group 绑定.
  + function: 代表复用的功能
  + group : 代表复用所对应的引脚, 一个复用功能可能会对应多组引脚.
2. 设置电气特性
3. 状态转变.当与GPIO连接的设备处于睡眠模式时,此管脚需要处于其他状态.
  + pin control state: 代表设备可能处于非常多的状态中的一个
  + pin control state holder: 管理一个设备的所有 pin control 状态
  + driver 的调用顺序为: 获取 =pin control state holder= -> 设置 =pin control state= -> 释放 =pin control state holder=.

#+BEGIN_SRC c
/**
 ,* @brief per-device pin control state holder
 ,* @param node: global list node
 ,* @param dev:the device using this pin control handle
 ,* @param states:a list of state for this device
 ,* @param state:the current state 
 ,* @param dt_maps:the mapping table chunks dynamically parsed from device tree for this device 
 ,* @param users: reference count
 ,*/
struct pinctrl
{
        struct list_head node;
        struct device *dev;
        struct list_head states;
        struct pinctrl_state *state;
        struct list_head dt_maps;
        struct kref users;
};
/**
 ,* @brief a pinctrl_state for a device
 ,* @param node: list node for struct pinctrl's @states field
 ,* @param name: the name of this state
 ,* @param settings: a list of setting for this state 
 ,*/
struct pinctrl_state
{
        struct list_head node;
        const char *name;
        struct list_head settings;
};
struct pinctrl_setting
{
        struct list_head node;
        enum pinctrl_map_type type;
        struct pinctrl_dev *pctldev;
        const char *dev_name;
        union{
                struct pinctrl_setting_mux mux;
                struct pinctrl_setting_configs configs;
        };
};

struct pinctrl_setting_mux
{
        unsigned group;
        unsigned func;
};
struct pinctrl_setting_configs
{
        unsigned group_or_pin;
        unsigned long *configs;
        unsigned num_configs;
}
#+END_SRC






** 中断与时钟
*** 概念
**** 中断类型
- 根据中断的来源分为内部和外部中断，比如操作系统从用户态切换到内核态需要借助软件中断
- 根据中断是否可以屏蔽分为可屏蔽中断和不可屏蔽中断
- 根据中断入口跳转方法的不同，中断分为向量中断和非向量中断，向量中断由硬件提供中断服务程序入口地址，非向量中断由软件提供中断服务程序入口地址

ARM 多核处理器都是通过GIC（Generic Interrupt Controller）来控制中断:
- 每个处理器都有其私有的中断PPI(Private Peripheral Interrupt)
- 处理器之间，用户态与内核态之间通信及请求是通过软件中断完成SGI(Software Generated Interrupt).
- 多个CPU共享外设中断SPI(Shared Peripheral Interrupt)

linux 中使用函数 =extern int irq_set_affinity(unsigned int irq, const struct cpumask *m);= 来将外设绑定到固定CPU核去

默认情况下，中断都是在CPU0上产生的。
#+BEGIN_SRC c
///将中断irq设定到CPU i 上去
irq_set_affinity(irq, cpumask_of(i));
#+END_SRC
**** 中断处理程序架构
为了满足中断处理时间尽量短的要求，Linux将中断处理程序分为顶半(Top Half)处理和底半(Bottom Half)处理两部分(优秀的 RT-thread 也是这样做的)。
- 顶半部分用于完成尽量少的比较紧急的功能，往往只是简单的读取中断寄存器状态，并在清除中断标志后就将底半处理程序挂到设备的底半执行队列中去。
- 底本部分几乎做了中断处理程序所有的事情， *而且可以被新中断打断*.相对来说处理并不是很紧急且相对比较耗时的工作。

*注意*: 如果整个中断处理的工作本来就很少，那么就完全可以直接在顶半部分完成。

查看 =/proc/interrupts= 文件可以获得系统中中断的统计信息，并能统计出每一个中断号上的中断在每个CPU上发生的次数。
*** 中断编程
**** 申请和释放中断
要先申请中断才能够使用，并且在不使用后需要释放中断。
#+BEGIN_SRC c
typedef int irqreturn_t;
typedef irqreturn_t (*irq_handler_t)(int, void *);
/**
 ,* @brief 申请一个中断
 ,* @param irq: 要申请的硬件中断号
 ,* @param handler: 中断处理的顶半函数
 ,* @param flags: 中断的触发方式及处理方式
 ,*        + IRQF_TRIGGER_RISING
 ,*        + IRQF_TRIGGER_FAILING
 ,*        + IRQF_TRIGGER_HIGH
 ,*        + IRQF_TRIGGER_LOW
 ,*        + IRQF_SHARED : 多个设备共享中断
 ,* @param dev: 要传递给中断服务程序的私有数据,一般为设备的设备结构体地址或NULL
 ,* @retval
 ,*        + 0 成功
 ,*        + -EINVAL : 中断号无效或处理函数指针为NULL
 ,*        + -EBUSY : 中断已经被占用且不能共享
 ,*/
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);

///此函数会在合适的时候自动释放中断资源
int devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);

/**
 ,* @brief 释放中断
 ,*/
void free_irq(unsigned int irq, void *dev_id);
#+END_SRC
**** 使能和屏蔽中断
在申请了中断资源后，便可以使能及失能中断。
#+BEGIN_SRC c

/**
 ,* @brief 使能中断
 ,*/
void enable_irq(int irq);
/**
 ,* @brief 等待目前的中断处理完成后关闭中断
 ,* @note: 不能在中断的顶半部分调用此函数，因为它会一直等待底半部分，而底半还没有执行，就会卡死
 ,*/
void disable_irq(int irq);
/**
 ,* @brief 给中断处理发送消息，处理完成后自动关闭，此函数会立即返回
 ,*/
void disable_irq_nosync(int irq);

//关闭本CPU内的所有中断，并保存当前的中断状态
#define local_irq_save(flags) ...
//根据关闭前的状态恢复中断
#define local_irq_restore(flags) ...

//关闭本CPU内所有中断
void local_irq_disable(void);
//打开本CPU内的所有中断
void local_irq_enable(void);

#+END_SRC
**** 底半处理机制
Linux 实现底半部的机制主要有 tasklet、工作队列、软中断和线程化irq.

- *此处软中断指的是由软件模拟的中断机制，而不是ARM中的由软件触发的硬件中断！*.

软中断和tasklet运行于软中断上下文，仍然属于原子上下文的一种，而工作队列运行于进程上下文。
*因此，在软中断和takelet处理函数中不允许睡眠，而在工作队列处理函数中允许睡眠*.

=local_bh_disable() and local_bh_enable()= 是内核中用于禁止和使能的软中断及tasklet底半部机制的函数。

*注意*: 软中断以及基于软中断的tasklet如果在某段时间大量出现的话,内核会把后续软中断放入 ksoftirqd 内核线程中执行。
***** tasklet
tasklet 的执行上下文是软中断，执行时机通常是顶半部返回的时候。只需要定义 tasklet 及其处理函数，并将两者关联即可。
#+BEGIN_SRC c
/**
 ,* @brief 定义一个tasklet结构 my_tasklet, 与 my_tasklet_func(data) 函数关联
 ,* 传递给 my_tasklet_func 的参数就是 data
 ,*/
void my_tasklet_func(unsigned long);
DECLARE_TASKLET(my_tasklet, my_tasklet_func, data);

//启动底半处理机制，此函数在顶半处理中使用
tasklet_schedule(&my_tasklet);

#+END_SRC
使用tasklet 的整体驱动模板
#+BEGIN_SRC c
void xxx_do_task_let(unsigned long);
DECLARE_TASKLET(xxx_tasklet, xxx_do_task_let, 0);

void xxx_do_task_let(unsigned long)
{
        ...
}
irqreturn_t xxx_interrupt(int irq, void *dev_id)
{
        ...
        tasklet_schedule(&xxx_tasklet);
        ...
        return IRQ_HANDLED;
}
int __init xxx_init(void)
{
        ...
        result = request_irq(xxx_irq, xxx_interrupt, 0, "xxx", NULL);

}

void __exit xxx_exit(void)
{
        ...
        free_irq(xxx_irq, xxx_interrupt);
        ...
}

#+END_SRC
***** 工作队列
工作队列的执行上下文是内核线程，因此 *可以调度和睡眠*.
#+BEGIN_SRC c
/**
 ,* 定义数据结构及操作函数
 ,*/
struct work_struct my_wq;
void my_wq_func(struct work_struct *work);
INIT_WORK(&my_wq, my_wq_func);
//启动
schedule_work(&my_wq);
#+END_SRC
队列处理模板
#+BEGIN_SRC c
struct work_struct xxx_wq;
void xxx_do_work(struct work_struct *work);

void xxx_do_work(struct work_struct *work)
{
        ...
}
irqreturn_t xxx_interrupt(int irq, void *dev_id)
{
        ...
        schdule_work(&xxx_wq);
        ...
        return IRQ_HANDLED;
}
int xxx_init(void)
{
        ...
        result = request_irq(xxx_irq, xxx_interrupt, 0,  "xxx", NULL);
        ...
//与tasklet 不同之处
        INIT_WORK(&xxx_wq, xxx_do_work);
        ...
}
void xxx_exit(void)
{
        ...
        freq_irq(xxx_irq, xxx_interrupt);
        ...
}
#+END_SRC
***** 软中断
软中断的执行时机通常是顶半部分返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。

用 =softirq_action= 结构体表示一个软中断，使用 =open_softirq()= 注册软中断对应的处理函数， =raise_softirq()= 触发一个软中断。




***** threaded_irq
内核中除了可以通过 =request_irq(),devm_request_irq()= 申请中断外，还可以通过下面函数申请：
#+BEGIN_SRC c
/**
 ,* @brief 相比 request_irq() 内核会为相应的中断号分配一个对应的内核线程
 ,* @brief 如果中断处理函数 handler() 返回值是 IRQ_WAKE_THREAD ,内核会调度对应的线程执行 thread_fn 函数
 ,* @note 支持flags 中设置 IRQF_ONESHOT,内核会自动帮助我们在中断上下文中屏蔽对应的中断号，而在内核调度thread_fn 执行后，重新使能该中断号
 ,* 当 handler 为NULL时， 内核默认使用 irq_default_primary_handler() 代替 handler() 并使用 IRQF_ONESHOT
 ,*/
int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn,
                         unsigned long flags, const char *name, void *dev);
int devm_request_threaded_irq(struct device *dev,unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn,unsigned long flags, const char *name, void *dev);
#+END_SRC
**** 中断共享
在多个设备共享一根硬件中断线的情况下，需要使用中断共享的方式：
- 共享中断的多个设备在申请中断的时候，都应该使用 =IRQF_SHARED= 标志，而且一个设备以 =IRQF_SHARED= 申请某中断成功的前提是该中断未被申请或之前申请标志也是 =IRQF_SHARED=
- =request_irq()= 的参数 =void *dev_id= 应该使用当前设备的结构体地址
- 在中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某一个函数返回 IRQ_HANDLED .在中断处理顶半部分中，应该根据硬件寄存器中的信息比对传入的 =dev_id= 是否一致，不一致就返回 =IRQ_NONE=.

#+BEGIN_SRC c
irqreturn_t xxx_interrupt(int irq, void *dev_id)
{
        ...
        int status = read_int_status();// 获取中断源状态
        if(!is_myint(dev_id, status))
                return IRQ_NONE;
        return IRQ_HANDLED;
}
int xxx_init(void)
{
        ...
        result = request_irq(sh_irq, xxx_interrupt, IRQF_SHARED, "xxx", xxx_dev);
        ...
}

void xxx_exit(void)
{
        ...
        free_irq(xxx_irq, xxx_interrupt);
        ..
}
#+END_SRC
*** 内核定时器
软件定时器是基于硬件定时器基础上实现的。

内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部分执行。
#+BEGIN_SRC c
// 一个timer_list 结构体就代表一个软件定时器实体
struct timer_list my_timer;

/**
 ,*初始化定时器
 ,*/
//初始化 timer_list 的 entry 的 next 为NULL， 并给 base 指针赋值
void init_timer(struct timer_list *timer);

//赋值定时器 function,expires,data,base成员
TIMER_INITIALIZER(_function,_expires,_data)

//定义并初始化一个软件定时器
DEFINE_TIMER(_name, _function, _expires, _data)

//初始化定时器并赋值
__setup_timer(_timer, _fn, _data, _flags)

/**
 ,* 添加定时器到链表
 ,*/
void add_timer(struct timer_list *timer);

/**
 ,* 从链表删除一个定时器
 ,*/
int del_timer(struct timer_list *timer);

/**
 ,* 修改定时器的到期值
 ,*/
int mod_timer(struct timer_list *timer, unsigned long expires);

#+END_SRC
#+BEGIN_SRC c
struct xxx_dev{
        struct cdev dev;
        ...
        timer_list xxx_timer;
};
xxx_func1(...)
{
        struct xxx_dev *dev = filp->private_data;
        ...
        init_timer(&dev->xxx_timer);
        dev->xxx_timer.function = &xxx_do_timer;
        dev->xxx_timer.data = (unsigned long)dev;
        dev->xxx_timer.expires = jiffies + delay;
        add_timer(&dev->xxx_timer);
        ...
}
xxx_func2(...)
{
        del_timer(&dev->xxx_timer);
}
static void xxx_do_timer(unsigned long arg)
{
        struct xxx_device *dev = (struct xxx_device *)arg;

        //再次执行定时器
        dev->xxx_timer.expires = jiffies + delay;
        add_timer(&dev->xxx_timer);
}
#+END_SRC
linux 还封装了快捷定时机制，本质是使用工作队列和定时器实现。
#+BEGIN_SRC c
typedef void(*work_func_t)(struct work_struct *work);
/**
 ,* @brief 调度一个delayed_work 在指定的延时后执行,时间到了后 delayed_work 结构中的 work_func_t 成员函数执行
 ,*/
int schedule_delayed_work(struct delayed_work *work, unsigned long delay);

//msecs_to_jiffies 将毫秒转换为jiffies
schedule_delayed_work(&work, msecs_to_jiffies(poll_interval));


//取消delayed_work
int cancel_delayed_work(struct delay_work *work);
int cancel_delayed_work_sync(struct delay_work *work);


#+END_SRC
*** 内核延时
**** 短延时
#+BEGIN_SRC c
/**
 ,* @note: linux在开机时会运行一个循环延时校准，计算出lpj，消耗时间几百毫秒
 ,* 如果在 bootargs 中设置 lpj=xxx,则可以省略这个时间
 ,*/
//忙等待，根据CPU频率进行一定次数的循环
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);

/**
 ,* @note 一般忙等待使用到微秒已经足够，对于毫秒以及以上的延时使用睡眠函数
 ,*/
void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);//可以被打断
void ssleep(unsigned int seconds);
#+END_SRC
**** 长延时
内核中进行延时的一个很直观的方法是比较当前的 jiffies 和目标 jiffies
#+BEGIN_SRC c
// 延时100个jiffies
unsigned long delay = jiffies + 100;
while(time_before(jiffies,delay));

unsigned long delay = jiffies + 2 * Hz;
while(time_before(jiffies, delay));
#+END_SRC
**** 睡着延时
=schedule_timeout()= 可以使当前任务休眠至指定的 jiffies 之后再重新被调度执行而 =msleep() 和 msleep_interruptible()= 都是包含了 =schedule_timeout()= 来实现的
