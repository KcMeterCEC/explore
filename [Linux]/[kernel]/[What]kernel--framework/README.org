* [What] kernel --> framework
参考网站: [[www.wowotech.net][窝窝科技]]

参考书籍: <<Linux设备驱动开发详解>>

[[#使用顺序]]

** 时钟管理子系统(clock)
commom clock framework 是用来管理系统 clock 资源的子系统, 根据职能由 *顶层到底层* 分为3个部分(很多框架的实现层次都是这种方式):
1. 向其他 driver 提供操作 clocks 的通用 API(就类似于I2C,SPI设备使用总线提供的操作函数一样)
2. 实现 clock 控制的通用逻辑, 这部分与硬件无关
3. 将和硬件相关的 clock 控制逻辑封装成操作函数集, 交由底层的 platform 开发者实现, 由通用逻辑调用.

很多芯片都具有时钟树,以满足不同设备的运行速度需求.参考熟悉的 STM32 的系统时钟树可以发现,其组成部分有:
- 外部晶体振荡器
- PLL
- 多路选择器
- 分频器
- 时钟使能

common clock framework 的管理对象就是这些可以调节的各个部分, 在软件中以 =struct clk= 来表示, 主要包括:
- 时钟使能和失能
- 设置时钟频率
- 设置时钟树的连接关系

*** driver 使用通用API(clock consumer)
通用API位于 =include/linux/clk.h= 中.

**** 使用顺序
具体的时钟设备是通过设备树来表示的, 而clock框架通过读取当前设备接点的时钟描述, 而得到对应的具体时钟驱动.

对于使用者来说, 仅仅需要通过在设备节点添加时钟属性, 然后调用clock API即可, 不用关心内部的实现.

一般来说, 在设备树中会有先列出的整个系统时钟名称, 其他节点引用此名称即可:
#+begin_example
slcr: slcr@f8000000 {
  #address-cells = <1>;
  #size-cells = <1>;
  compatible = "xlnx, zynq-slcr", "syscon";
  reg = <0xf8000000 0x1000>;
  ranges;
  clkc: clkc:@100{
    #clock-cells = <1>;
    compatible = "xlnx, ps7-clkc";
    ps-clk-frequency = <33333333>;
    fclk-enable = <0>;
                          //  0       1         2          3
    clocl-output-names = "armpll", "ddrpll", "iopll", "cpu_6or4x",
                          //  4          5        6       7        8
                          "cpu_3or2x","cpu_2x","cpu_1x","ddr2x","ddr3x",
                          //9     10     11     12     13     14
                          "dci","lqspi","smc","pcap","gem0","gem1",
                          //15      16      17      18      19     20
                          "fclk0","fclk1","fclk2","fclk3","can0","can1",
                          //21      22       23     24      25     26
                          "sdio0","sdio1","uart0","uart1","spi0","spi1",
                          //27      28       29            30
                          "dma","usb0_aper","usb1_aper","gem0_aper",
                          //31           32            33
                          "gem1_aper","sdio0_aper","sdio1_aper",
                          //34            35          36          37
                          "spi0_aper","spi1_aper","can0_aper","can1_aper",
                          //38             39         40           41
                          "i2c0_aper","i2c1_aper","uart0_aper","uart1_aper",
                          //  42           43         44        45
                          "gpio_aper","lqspi_aper","smc_aper","swdt",
                          //46          47
                          "dbg_trc","dbg_apb";
     reg = <0x100 0x100>;
  };
};

sdhci0: sdhc@e0100000{
  compatible = "arasan, sdhi-8.9a";
  status = "disabled";
  /// 为下面两个引用时钟定义别名,用于 clk_get() 函数引用
  clock-names = "clk_xin", "clk_ahb";
  clocks = <&clkc 21>, <&clkc 32>;
  interrupt-parent = <&intc>;
  interrupts = <0 24 4>;
  reg = <0xe0100000 0x1000>;
};
#+end_example

**** API
***** 获取 strucl clk 
每个时钟对象都由一个 =struct clk= 结构体来表示, 这些结构体通过链表挂接在一起, 形成和时钟树一样的结构, 所以在操作时钟前, 首先需要通过设备树节点获取时钟.
#+BEGIN_SRC c
/**
 ,* @brief 以 device 指针或 id 字符串(可以看作name, 也就是设备节点中的 clock-names 属性)为参数, 查找clock
 ,* @note dev 和 id 任意一个可以为空, 如果 id 为空,则必须要有 device tree 支持.
 ,* id 可以是一个简单的名称, 也可以是一个预先定义的, 唯一标识(在平台提供的头文件中定义, 如 mach/clk.h);
 ,* @warning 不能在中断上下文中调用
 ,*/
struct clk *clk_get(struct device *dev, const char *id);
/**
 ,* @note 与get的反操作, 和 get 成对使用
 ,*/
void clk_put(struct clk *clk);
/**
 ,* @note 相比 clk_get ,此函数可以自动释放
 ,*/
struct clk *devm_clk_get(struct device *dev, const char *id);
void devm_clk_put(struct device *dev, struct clk *clk);
/**
 ,* @note 相比 clk_get , 使用设备名称代替 device 结构
 ,*/
struct clk *clk_get_sys(const char *dev_id, const char *con_id);
/**
 ,* @note 直接从对应的设备树节点中获取 clk
 ,*/
struct clk *of_clk_get(struct device_node *np, int index);
struct clk *of_clk_get_by_name(struct device_node *np, const char *name);
struct clk *of_clk_get_from_provider(struct of_phandle_args *clkspec);

#+END_SRC
***** 控制 clock
#+BEGIN_SRC c
/**
 ,*@note 启动和停止 clock 前的准备及善后工作, 可能会引起睡眠(等待PLL稳定的时间)
 ,* @warning 不能在中断处理中调用
 ,*/
int clk_prepare(struct clk *clk);
void clk_upprepare(struct clk *clk);

/**
 ,* @note 启动及停止clock,不会引起睡眠
 ,*/
static inline int clk_enable(struct clk *clk);
static inline void clk_disable(struct clk *clk);

/**
 ,* @note 此函数失上面4个函数的组合顺序为 prepare -> enable -> disable -> unprepared
 ,* @warning 这两个函数不能在原子操作中使用, 因为函数可能会引起睡眠
 ,*/
static inline int clk_prepare_enable(struct clk *lck);
static inline void clk_disable_upprepare(struct clk *clk);
/**
 ,* @note clock 频率的的获取和设置.
 ,* 并不一定会设置成功,因为分频比有限
 ,* @warning 为了确保设置成功, 需要先调用 clk_round_rate 获取理想设置值的实际设置值
 ,*/
static inline unsigned long clk_get_rate(struct clk *clk);
static inline int clk_set_rate(struct clk *clk, unsigned long rate);
static inline long clk_round_rate(struct clk *clk, unsigned long rate);

/**
 ,* @note 获取和选择父时钟,形成时钟树
 ,*/
static inline int clk_set_parent(struct clk *clk, struct clk *parent);
static inline struct clk *clk_get_parent(struct clk *clk);

#+END_SRC
***** 其他接口
#+BEGIN_SRC c
/**
 ,* @note 用于注册和注销一个消息,当clock rate 改变时, 就会通知此驱动.
 ,*/
int clk_notifier_register(struct clk *clk, struct notifer_block *nb);
int clk_notifier_unregister(struct clk *clk, struct notifer_block *nb);

/**
 ,* @brief 给 clk 起别名
 ,*/
int clk_add_alias(const char *alias, const char *alias_dev_name, char *id, struct device *dev);
#+END_SRC
**** 使用详解
参考: =Documentation/devicetree/bindings/clock/clock-bindings.txt=
***** 在 device tree 中设置需要使用的 clock
#+begin_example
/**
 ,* @note 此设备使用两个 clock, baud 取自 osc 的 1号通道, register 取自 ref 的 0号通道.
 ,* 用于 clk_get 使用名字来得到时钟结构体
 ,*/
device{
    clocks = <&osc 1>, <&ref 0>;
    clock-names = "baud", "register";
};
#+end_example
***** 系统解析
系统启动后, device tree 代码会解析 clock 有关的关键字, 并将解析后的信息放在 platform_device 相关的字段中.
***** driver 使用
具体的driver可以在probe的时候, 以clock的名称为参数, 调用 clk_get 接口, 获取clock的对象, 然后使用此对象为参数使用上述函数.
#+BEGIN_SRC c
int xxx_probe(struct platform_device *pdev)
{
        struct clk *baud_clk;
        int ret;

        baud_clk = devm_clk_get(&pdev->dev, "baud");
        if(IS_ERR(baud_clk))
        {
                ....
        }
        ret = clk_prepare_enable(baud_clk);
        if(ret)
        {
                ...
        }
}
#+END_SRC
*** 编写 clock 通用逻辑(clock provider)
**** 编写设备树
provider 的设备树有两种写法:
1. 将系统所有的clock抽象为一个虚拟的设备, 用一个节点表示, 称为 =clock controller=.
#+begin_example
clock:clock-controller@0x10030000{
    compatible = "samsung,exynos4210-clock";
    reg = <0x10030000 0x20000>;
    /// 为0时代表只有一个时钟输出, 为1时代表有多个时钟输出
    #clock-cells = <1>;
};

mct@10050000{
    compatible = "samsung, exynos4210-mct";
    ....
    /**
    ,* @note clk_get 方法读取 clocks 属性来得到对应的 struct clk 指针
    ,* 当 provider 节点中的 #clock-cells 属性为0时, 只需要提供一个 clock provider name(称为 phandle);
    ,* 为 1时, 则还需要额外提供一个序号. 可以在头文件中 define 这些序号, 比数字更加易懂.
    ,* clock-names 是为 clocks 中指定的两个时钟设置名称, 这样 clk_get 就可以直接使用此名称.
    ,*/
    clocks = <&clock 3>, <&clock 334>;
    clock-names = "fin_pll", "mct";
#+end_example
2. 将每个clock都分别表示一个节点, 而每一个节点即是 provider 也是 consumer（因为需要连接）
#+begin_example
clocks{
    #address-cells = <1>;
    #size-cells = <1>;
    ranges;
    dummy:dummy{
        #clock-cells = <0>;
        compatible = "fixed-clock";
        clock-frequency = <0>;
    };
    //root clock
    osc24M: osc24M@01c2005{
            #clock-cells = <0>;
            compatible = "allwinner, sun4i-soc-clk";
            reg = <0x01c20050 0x4>;
            clock-frequency = <24000000>;
    };
    //root clock
    osc32k:osc32k{
        #clock-cells = <0>;
        compatible = "fixed-clock";
        clock-frequency = <32768>;
    };
    /**
     ,* @note pll1 是provider 也是 consumer
    ,*/
    pll1:pll1@01c20000{
        #clock-cells = <0>;
        compatible = "allwinner,sun4i-pll1-clk";
        reg = <0x01c20000 0x4>;
        clock2 = <&osc24M>;
    };
    cpu: cpu@01c20054{
         #clock-cells = <0>;
         compatible = "allwinner, sun4i-cpu-clk";
         reg = <0x01c20054 0x04>;
         clocks = <&osc32k>, <&osc24M>,<&pll1>,<&dummy>;
    };
    /**
     ,* @note ahb_gates  是provider 也是 consumer
    ,*/
    ahb_gates:ahb_gates@01c20060{
        #clock-cells = <1>;
        compatible = "allwinner,sun4i-ahb-gates-clk";
        reg = <0x01c20060 0x08>;
        clocks = <&ahb>;
        /**
        ,* @warning: clock-output-names 关键字只是为了方便 clock privider 编程方便, consumer 不可见
        ,*/
        clock-output-names = "ahb_usb0", "ahb_ehci0",
        "ahb_ohci0", "ahb_ehi1"......
    };
};
#+end_example
**** API 
位于 =include/linux/clk_provider.h=
***** struct clk_hw
framework 提供了 struct clk_hw 结构, 用于从 clock　provider 的角度, 描述clock :
#+BEGIN_SRC c
struct clk_hw{
        struct clk　*clk;
        /// 用于描述一个 clock 的静态数据
        const struct clk_init_data *init;
};
/**
 ,* @param name: clock 的名称
 ,* @param ops: 该clock 的操作函数集
 ,* @param parent_names: 该clock所有的parent clock 的名称, 这是一个字符串数组
 ,* @param num_parents: parent 个数
 ,* @param flags : framework 级别的 flags
 ,*/
struct clk_init_data{
        const char  *name;
        const struct clk_ops *ops;
        const char **parent_names;
        u8   num_parents;
        unsigned long flags;
};
/**
 ,* @brief framework flags 可以使用或的关系
 ,*
 ,*/
#define CLK_SET_RATE_GATE                       BIT(0) ///在改变该 clock 的 rate时, 必须关闭
#define CLK_SET_PARENT_GATE                     BIT(1) /// 在改变该 clock 的 parent 时, 必须关闭
#define CLK_SET_RATE_PARENT                     BIT(2) /// 改变该 clock 的rate时, 要将改变传递到上层 parent
#define CLK_IGNORE_UNUSED                       BIT(3) /// 忽略 disable unused 的调用
#define CLK_IS_ROOT                             BIT(4) /// 该clcok 为 root clock, 没有parent
#define CLK_IS_BASIC                            BIT(5) /// 不再使用
#define CLK_GET_RATE_NOCAHE                     BIT(6) /// get rate 时, 不要从缓存中拿, 而是重新计算

struct clk_ops{
        int              (*prepare)(struct clk_hw *hw);
        void             (*unprepare)(struct clk_hw *hw);
        int              (*is_prepared)(struct clk_hw *hw);
        /// 自动清除没有被使用的时钟
        void             (*unprepare_unused)(struct clk_hw *hw);
        int              (*enable)(struct clk_hw *hw);
        void             (*disable)(struct clk_hw *hw);
        int              (*is_enabled)(struct clk_hw *hw);
        /// 自动失能没有被使用的时钟
        void             (*disable_unused)(struct clk_hw *hw);
        /// 重新计算并返回 clock rate
        unsigned long    (*recalc_rate)(struct clk_hw *hw, unsigned long parent_rate);
        long             (*round_rate)(struct clk_hw *hw, unsigned long, unsigned long *);
        int              (*set_parent)(struct clk_hw *hw, u8 index);
        u8               (*get_parent)(struct clk_hw *hw);
        int              (*set_rate)(struct clk_hw *hw, unsigned long, unsigned long);
        /// clock 被 register 时自动被调用
        void             (*init)(struct clk_hw *hw);
};
+END_SRC
***** clk_register
通过 register 将 struct clk_hw 注册到 kernel 中. *clock framework 的核心代码会把它们转换为 struct clk 变量*,
并以 tree 的形式组织起来.
#+BEGIN_SRC c
struct clk *clk_register(struct device *dev, struct clk_hw *hw);
struct clk *devm_clk_register(struct device *dev, struct clk_hw *hw);

void clk_unregister(struct clk *clk);
void devm_clk_unregister(struct device *dev, struct clk *clk);
#+END_SRC 
***** clock 分类及register
根据 clock 的特点, clock framework 将 clock 分为fixed rate, gate, devider, mux, fixed factor, composite.六类.

每一类clock都有相似的功能, 相似的控制方式, 因而可以使用相同的逻辑, 统一处理.
- fixed rate clock
此类 clock 具有固定的频率, 不能开关, 不能调整频率, 不能选择 parent, 不需要提供任何的 =clk_ops= 回调函数, 是最简单的一类 clock.

可以直接通过设备树配置, *clock framework core 直接从设备树中解出 clock 信息, 并自动注册到 kernel, 不需要任何driver支持*.

framework 使用 struct clk_fixed_rate 结构来表示这种 clock, 另外提供了一个接口, 可以直接注册.
#+begin_example
/// provider
ad9361_clkin:ad9361_clock@0{
    #clock-cells = <0>;
    compatible = "fixed-clock";
    clock-frequency = <40000000>;
    clock-output-names = "ad9361_ext_refclk";
};

/// consumer
adc_9361@0{
    #address-cells = <1>;
    #size-cells = <0>;
    compatible = "adi,ad9361";

    clocks = <&ad9361_clkin 0>;
    clock-names = "ad9361_ext_refclk";
};

#+end_example
#+BEGIN_SRC c
/**
 ,* @note 只要在设备树中定义了时钟节点,那么下面这些函数则不用关心
 ,*/
struct clk_fixed_rate{
        struct clk_hw hw;
        unsigned long fixed_rate;
        u8 flags;
};

extern const struct clk_ops clk_fixed_rate_ops;
struct clk *clk_register_fixed_rate(struct device *dev, const char *name,
                                    const char *parent_name, unsigned long flags,
                                    unsigned long fixed_rate);
#+END_SRC
- gate clock
此类 clock 只可开关(使用 enable/disable 函数),使用下面的函数注册:
#+BEGIN_SRC c
/**
 ,* @param name : clock 名称
 ,* @param parent_namei : parent clock 名称, 如果没有则为 NULL
 ,* @param flags : 同上
 ,* @param reg : 控制 clock开关的虚拟地址
 ,* @param bit_idx : 控制bit位(是1 开还是0开).
 ,* @param clk_gate_flags: 当为 CLK_GATE_SET_TO_DISABLE, 表示写1关闭 clock
 ,* @param lock : 如果开关需要互斥, 可以提供一个 spinlock
 ,*/
struct clk *clk_register_gate(struct device *dev, const char *name,
                              const char *parent_name, unsigned long flags,
                              void __iomem *reg, u8_bit_idx,
                              u8 clk_gate_flags, spinlock_t *lock);
#+END_SRC
- divider clock
此类 clock 可以设置分频值(因而会提供 recalc_rate/ set_rate/ round_rate 回调).
#+BEGIN_SRC c
/**
 ,* @param shift : 控制分频比的位在寄存器中的偏移
 ,* @param width : 分频比的位数
 ,* @param clk_divider_flags:
 ,* CLK_DIVIDER_ONE_BASED: 实际 divider 的值就是寄存器的值
 ,* CLK_DIVIDER_POWER_OF_TWO: 实际的 divider 值是寄存器值的2次方
 ,* CLK_DIVIDER_ALLOW_ZERO:  divider 值可以位0
 ,*/
struct clk *clk_register_divider(struct device *dev, const char *name,
                                 const char *parent_name, unsigned long flags,
                                 void __iomem *reg, u8 shift, u8 width,
                                 u8 clk_divider_flags, spinlock_t *lock);

/**
 ,* @brief 用于注册不规则的分频 clock
 ,*/
struct clk *clk_register_divider_table(struct device *dev, const char *name,
                                       const char *parent_name, unsigned long flags,
                                       void __iomem *reg, u8 shift, u8 width,
                                       u8 clk_divider_flags, const struct clk_div_table *table,
                                       spinlock_t *lock);
struct clk_div_table{
        unsigned int val;    /// 寄存器的值
        unsigned int div;   /// 对应的分频值
};
#+END_SRC
- mux clock
这是一个多通道选择的时钟, 所以这类 clock 可以选择多个 parent, 需要 =get_parent, set_parent, recal_rate= 函数支持.
#+BEGIN_SRC c
/**
 ,* @param parent_names :  字符串数组, 描述所有可能的 parent
 ,* @param num_parents : parent 个数
 ,* @param shift, width : 选择 parent 的寄存器的偏移,宽度.默认寄存器值为0对应第一个 parent
 ,* @param clk_mux_flags :
 ,* CLK_MUX_INDEX_ONE: 寄存器值不是从0开始, 而是从1开始
 ,* CLK_MUX_INDEX_BIT :寄存器的值为 2 的幂; 
 ,*/
struct clk *clk_register_mux(struct device *dev, const char *name,
                             const char **parent_names, u8 num_parents, unsigned long flags,
                             void __iomem *reg, u8 shift, u8 width,
                             u8 clk_mux_flags, spinlock_t *lock);

/**
 ,* @brief : 注册 mux 控制不规则的 lock
 ,*/
struct clk *clk_register_mux_table(struct device *dev, const char *name,
                                   const char **parent_names, u8 num_parents, unsigned long flags,
                                   void __iomem *reg, u8 shift, u32　mask,
                                   u8 clk_mux_flags, u32 *table, spinlock_t *lock);
#+END_SRC

- fixed factor clock
此类 clock 具有固定的 factor(即 multiplier 和 divider), 虽然 mult 和 divider 不可变, 但是由于parent可变, 所以也会提供 recalc_rate, set_rate, round_rate 等回调).可以直接在设备树中配置即可, 底层自动使用下面的函数.
#+BEGIN_SRC c
struct clk *clk_register_fix_factor(struct device *dev, const char *name,
                                    const char *parent_name, unsigned long flags,
                                    unsigned int mult, unsigned int div);
#+END_SRC
- composite lock
是 mux,divider,gate 等 clock的组合,所以如下接口注册
#+BEGIN_SRC c
struct clk *clk_register_composite(struct device *dev, const char *name,
                                   const char **parent_names, int num_parents,
                                   struct clk_hw *mux_hw, const struct clk_ops *mux_ops,
                                   struct clk_hw *rate_hw, const struct clk_ops *rate_ops,
                                   struct clk_hw *gae_hw, const struct clk_ops *gate_ops,
                                   unsigned long flags);
#+END_SRC
***** 设备树相关API
provider 需要将clock的对应信息告知 framework 的 OF 模块, 这样才可以帮助将 consumer 的DTS转换为对应的 struct clk结构.
#+BEGIN_SRC c
/**
 ,* @param np : 对应的设备树结点
 ,* @param clk_src_get: 获取 struct clk指针的回调函数
 ,* @param args : 在设备树中获取到的参数 比如: clocks = <&clock 32>, <&clock 45>
 ,* @param data : 保存 struct clk 的指针
 ,* @param data : 
 ,*/
int of_clk_add_provider(struct device_node *np,
                        struct clk *(*clk_src_get)(struct of_phandle_args *args, void *data, void *data);

/**
 ,* @note: 对于所有时钟都以列表方式存在节点中时,clock framework core 提供一个默认的会调用的函数
 ,*
 ,*/
struct clk_onecell_data{
        struct clk **clks;
        unsigned int clk_num;
};
struct clk *of_clk_src_onecell_get(struct of_phandle_args *clkspec, void *data);
#+END_SRC
**** 编写步骤
1. 分析硬件的 clock tree, 按照 framework 中的 clock 的类别, 将它们分类
2. 将 clock_tree 在DTC中描述出来. 
   - 对于 fixed rate clocks. compatible 中固定为 "fixed-clock", 并提供 "clock-frequency" , "clock-out-names" 关键字.之后不需要在 driver 中做任何处理, framework会帮助我们搞定.
   - 对于 fixed factor clock. compatible 为 "fixed-factor-clock", 并提供 "clock-div", "clock-mult", "clock-output-names".然后交给 framework 搞定
3. 对于不能由 framework 处理的 clock, 需要在driver中使用 struct of_device_id 进行匹配, 并在初始化时调用 OF模块,查找所有的 DTS匹配项, 并执行register.
4. 注册 clock 的同时, 将返回 struct clk指针, 保存在一个数组中, 并使用 =of_clk_add_privider= 告知 framework.
*** 编写底层逻辑
**** 分析 struct clk 结构
#+BEGIN_SRC c
/**
 ,* @param parent :该clock当前的parent clock 的 struct clk 指针
 ,* @param parents: 保存所有可能的 parent clock 的 struct clk 指针
 ,* @param rate: 当前 clock rate
 ,* @param new_rate: 新设置的 clock rate
 ,* @param enable_count, prepare_count: 被enable和 prepare 的次数, 用于确保和 disable/unprepare 成对调用
 ,* @param children : children clocks, 以链表的形式组织
 ,* @param child_node: 一个 list node, 自己作为child 时, 挂到 parent 的 children list 时使用
 ,* @param notifier_count: 记录注册到notifier的个数
 ,*/
struct clk{
        const char              *name;
        const struct clk_ops *ops;
        struct clk_hw            *hw;
        struct clk                 *parent;
        const char               **parent_names;
        struct clk                **parents;
        u8                          num_parents;
        unsigned long      rate;
        unsigned long      new_rate;
        unsigned long      flags;
        unsigned int         enable_count;
        unsigned int         prepate_count;
        struct hlist_head  children;
        struct hlist_node  child_node;
        unsigen int           notifier_count;
        #ifdef CONFIG_COMMON_CLK_DEBUG
        struct dentry        *dentry;
        #endif
};
#+END_SRC
**** clock register/unregister
***** clk_register
clk_register 是所有 register 接口的共同实现, 负责将 clock 注册到 kernel, 并返回代表该 clock 的strcut clk 指针.
#+BEGIN_SRC c
struct clk *clk_register(struct device *dev, struct clk_hw *hw)
{
        int i, ret;
        struct clk *clk;
        clk = kzalloc(sizeof(*clk), GPF_KERNEL);
        if(!clk)
        {
                pr_err("%s: could not allocate clk\n", __func__);
                ret = -ENOMEM;
                goto fail_out;
        }
        clk->name = kstrdup(hw->init->name, GFP_KERNEL);
        if(!clk->name)
        {
                pr_err("%s, could not allocate clk->name\n", __func__);
                ret = -ENOMEM;
                goto fail_name;
        }
        clk->ops = hw->init->ops;
        if(dev && dev->driver)
                clk->owner = dev->driver->owner;
        clk->hw = hw;
        clk->flags = hw->init->flags;
        clk->num_parents = hw->init->num_parents;
        hw->clk = clk;

        clk->parent_names = kcalloc(clk->num_parents, sizeof(char *), GFP_KERNEL);

        if(!clk->parent_names)
        {
                pr_err("%s: could not allocate clk->parent_names\n", __func__);
                ret = -ENOMEM;
                goto fail_parent_names;
        }
        for( i = 0; i < clk->num_parents; i++)
        {
                clk->parent_names[i] = kstrdup(hw->init->parent_names[i], GFP_KERNEL);
                if(!clk->parent_names[i])
                {
                        pr_err("%s: could not copy parent_names\n", __func__);
                        ret = -ENOMEM;
                        goto fail_parent_names_copy;
                }
        }

        ret = __clk_init(dev, clk);
        if(!ret)
                return clk;

fail_parent_names_copy:
        while(--i >= 0)
                kfree(clk->parent_names[i]);
        kfree(clk->parent_names);
fail_parent_names:
        kfree(clk->name);
fail_name:
        kfree(clk);
fail_out:
        return ERR_PTR(ret);
             
}
EXPORT_SYMBOL_GPL(clk_register);
#+END_SRC
** I2C子系统
*** 总体概览
Linux 的 I2C 体系结构分为3个组成部分:
- I2C核心
I2C核心提供了I2C总线驱动和设备驱动的注册和注销方法, I2C通信方法, 上层的与具体适配器无关的代码以及探测设备, 检测设备地址的上层代码等.
- I2C总线驱动
所谓的总线驱动也就是I2C控制器的驱动, 与之相关的有 =I2C控制器数据结构i2c_adapter=, =I2C控制器的算法数据结构i2c_algorithm=, =控制I2C控制器产生通信信号的函数=.

经由I2C总线驱动的代码, 我们可以控制I2C控制器以主机的方式产生开始位, 停止位, 读写操作, 以及以从机的方式被读写, 产生ACK, NACK等.

I2C控制器一般是直接挂接在CPU总线上的, 所以其驱动也是 =platform_driver=.
- I2C设备驱动
I2C设备也就是与控制器相连接的设备.与之相关的有 =i2c_driver=, =i2c_client= 数据结构, 以及对应的功能函数.

在Linux系统中, I2C设备及驱动位于 =/sys/bus/i2c/= 文件夹下.

在Linux源码中, i2c驱动目录具有如下结构:
- i2c-core.c / i2c-core.h
实现了I2C的核心功能以及 =/proc/bus/i2c*= 的接口
- i2c-dev.c
实现了I2C控制器设备文件的功能, 每个I2C控制器都被分配一个设备.通过控制器访问设备时的主设备号位89, 次设备号为 0~255.
也就是说, 此文件提供了通用的接口, 应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间和寄存器, 并控制设备的工作方式.

应用程序通过 =i2c-%d= (i2c-0, i2c-1,....)文件名并使用文件操作接口 open(), write(), read(), ioctl(), close() 等来访问这个设备.

*当然,使用此文件就需要在用户代码中设置好设备的操作地址, 具体寄存器操作.虽然说可以省事, 但没有实现很好的分层.*
- busses
此文件夹包含了I2C控制器的驱动
- algos
实现了一些I2C控制器的通信方法.也就是I2C协议包生成的逻辑, 一般都是由硬件来实现.
- i2c.h (include/linux/)
提供对 =i2c_adapter, i2c_algorithm, i2c_driver, i2c_client= 数据结构的定义.

总体的软件拓扑抽象层次如下图所示:
[[./i2c_softTopology.bmp][I2C软件拓扑]]
整个构架的软件层次如下图所示:
[[./i2c_framework.bmp][I2C框架]]

经过I2C framework 的抽象, consumer 可以不用关心I2C总线的技术细节, 只需要通过简单的API, 就可以与 slave devices 进行数据交互.
正常情况下, consumer 是位于内核态的其他driver. 于此同时, I2C framework也通过字符设备向用户空间提供类似的接口, 用户空间程序可以通过该接口访问 slave devices.

I2C core 使用 =i2c_adapter,i2c_algorithm= 抽象I2C控制器的功能, =i2c_driver, i2c_client= 抽象 I2C slave device 的功能.
另外, 基于I2C协议, 通过 smbus 模块实现 SMBus的功能.

[[./i2c_smbus.bmp][i2c & smbus]]

I2C muxes 用于实现I2C BUS的多路复用功能, 实际使用较少.
*** 控制器驱动的编写
**** 数据结构
与控制器驱动密切相关的就是 =i2c_adapter, i2c_algorithm= 结构体, 具体描述一下:
#+BEGIN_SRC c
/**
 ,* @brief struct i2c_msg - an I2C transaction segment beginning with START(用户空间也可以用)
 ,* @brief addr -> 从机地址,支持7位或者10位, 10位时需要使用 I2C_M_TEN标记,以及驱动返回 I2C_FUNC_10BIT_ADDR
 ,* @brief flags -> 标明此次传输标记
 ,* @brief len -> 读取或者写入的字节数
 ,* @brief buf -> 读写缓存
 ,*/
struct i2c_msg{
        __u16 addr;
        __u16 flags;
#define I2C_M_TEN 0x0010 /// this is a ten bit chip address
#define I2C_M_RD 0x0001 /// read data, from slave to master
#define I2C_M_STOP 0x8000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_NOSTART 0x4000 /// if I2C_FUNC_NOSTART
#define I2C_M_REV_DIR_ADDR 0x2000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_IGNORE_NAK 0x1000 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_NO_RD_ACK 0x0800 /// if I2C_FUNC_PROTOCOL_MANGLING
#define I2C_M_RECV_LEN 0x0400 /// length will be first received byte
        __u16 len;
        __u8 *buf;
};
/**
 ,* @brief struct i2c_algorithm - represent I2C transfer method(对应一套通信协议)
 ,* @param master_xfer -> I2C传输函数
 ,* @param smbus_xfer -> smbus传输函数
 ,* @param functionality -> 返回 algorithm/adapter 所支持的功能, I2C_FUNC_XXX
 ,* @param reg_slave / unreg_slave -> 注册及注销从设备
 ,* @note 关于 master_xfer 的错误返回说明文件位于 Documentation/i2c/fault-codes
 ,*/
struct i2c_algorithm{
        int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
        int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr, unsigned short flags,
                          char read_write, u8 command, int size, union i2c_smbus_data *data);
        u32 (*functionality)(struct i2c_adapter *);
#if IS_ENABLED(CONFIG_I2C_SLAVE)
        int (*reg_slave)(struct i2c_client *client);
        int (*unreg_slave)(struct i2c_client *client);
#endif
};
/**
 ,* @brief i2c_adapter is the structure used to identify a physical i2c bus along with
 ,* the access algorithms necessary to access it.(代表控制器)
 ,* @param class -> 此驱动所支持的设备类型(I2C_CLASS_HWMON, I2C_CLASS_DDC....)
 ,* @param timeout -> 当重试超过一定时间(jiffies), 停止重试
 ,* @param retries -> 设定当传输失败时, 重试传输的次数
 ,* @param nr -> 此控制器的ID, 一般由设备树解析.
 ,*/
struct i2c_adapter{
        struct module *owner;
        unsigned int class;
        const struct i2c_algorithm *algo;
        void *algo_data;
        
        struct rt_mutex bus_lock;
        
        int timeout;
        int retries;
        struct device dev;
        
        int nr;
        char name[48];
        struct completion dev_released;
        struct mutex userspace_clients_lock;
        struct list_head userspace_clients;
        
        struct i2c_bus_recovery_info *bus_recovery_info;
        const struct i2c_adapter_quirks *quirks;
};

#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)
#+END_SRC
**** 传输标志
一般情况下, i2c_msg 中的 flag 为0, 也就是按照标准传输方式, 具体如下表(表明了 master_xfer() 的执行流程):

[] 表示从机返回.
| 标记              | 读写 | 协议                                                       |
|-------------------+------+------------------------------------------------------------|
| 0                 | 写   | S Addr_Wr [A] Data [A].....Data [A] P                      |
| 0                 | 读   | S Addr_Rd [A] Data [A].....Data NA P                       |
| 0                 | 混合 | S Addr_Rd [A] [Data] NA S Addr_Wr [A] Data [A] P           |
| I2C_M_IGNORE_NAK  |      | 读取操作时, 忽略 slave 返回的 NA, 把它当作 ACK信号继续读取 |
| I2C_M_NO_RD_ACK   |      | 读取的时候忽略所有的 A 和 NA                               |
| I2C_M_NOSTART     | 混合 | S Addr_Rd [A] [Data] NA +S Addr_Wr [A]+ Data [A] P         |
| I2C_M_REVDIR_ADDR |      | 读写翻转, 读的时候发 Wr 信号, 写的时候发 Rd 信号           |
| I2C_M_STOP        |      | 传输完一个 msg 后发送一个 STOP 信号                        |

对应的 master_xfer() 模板类似于:
#+BEGIN_SRC c
static int i2c_adapter_xxx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
{
        ...
        for(i = 0; i < num; i++)
        {
                i2c_adapter_xxx_start();

                if(msgs[i]->flags & I2C_M_RD)
                {
                        i2c_adapter_xxx_setaddr((msgs[i]->addr << 1) | 1);
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_readbytes(msgs[i]->buf, msgs[i]->len);
                        
                }
                else
                {
                        i2c_adapter_xxx_setaddr((msgs[i]->addr <<1));
                        i2c_adapter_xxx_wait_ack();
                        i2c_adapter_xxx_writegbytes(msgs[i]->buf, msgs[i]->len);
                }
        }
        i2c_adapter_xxx_stop();
}
#+END_SRC
**** 函数接口
控制器驱动可以使用的接口.
#+BEGIN_SRC c
/**
 ,* @brief 将此 adapter 注册进内核, 内核自动分配ID号
 ,*/
extern int i2c_add_adapter(struct i2c_adapter *);
/// 与上面相比, 需要主动提供一个ID号
extern int i2c_add_numbered_adapter(struct i2c_adapter *);
/**
 ,* @brief 将此 adapter 从内核中删除
 ,*/
extern void i2c_del_adapter(struct i2c_adapter *);
/**
 ,* @brief 获取 adapter 所支持的功能
 ,*/
static inline u32 i2c_get_functionality(struct i2c_adapter *adap);
/**
 ,* @brief 检查 adapter 是否具备指定的功能
 ,*/
static inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func);
/**
 ,* @brief 获取 adapter ID
 ,*/
static inline int i2c_adapter_id(struct i2c_adapter *adap);
/**
 ,* @brief 根据 adapter ID 获取 adapter
 ,*/
extern struct i2c_adapter *i2c_get_adapter(int nr);
/// 与上面函数需要成对使用
extern void i2c_put_adapter(struct i2c_adapter *adap);
/**
 ,* @brief 通过 device_node 查找对应的 adapter 结构, 使用完成后需要使用 put_device 函数减去计数
 ,*/
extern struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);

#+END_SRC
***** i2c_add_adapter 流程

- 分配ID
当用户主动分配ID时, 则是执行的以下流程:

i2c_add_numbered_adapter --> __i2c_add_numbered_adapter --> i2c_register_adapter 

当用户选择自动分配ID时, 则使用 =i2c_add_adapter= 函数, 此函数会首先搜寻设备树中的 alias ID, 比如 =i2c0=,
如果没有搜到, 则使用 =idr_alloc= 分配一个ID.
- 创建设备
adapter ID 分配完后, 或执行 =i2c_register_adapter= ,该接口会在 =/sys/devices/xxxxx.i2c/= 中创建该 adapter 的目录(/sys/devices/xxxxx.i2c/i2c-n).
#+BEGIN_SRC c
/**
 ,* @note 经过以下几步, 最终在 /sys/bus/i2c/devices/ 中创建对应的符号链接
 ,*/
dev_set_name(&adap->dev, "i2c-%d", adap->nr);
adap->dev.bus = &i2c_bus_type;
adap->dev.type = &i2c_adapter_type;

/// device_register --> device_add --> bus_add_device --> sysfs_create_link
res = device_register&adap->dev);

#+END_SRC
- I2C slave device 的创建和注册
I2C adapter 注册的时候, 会为它下面所有的 slave device 创建一个 =struce i2c_client= 结构, 并注册到 I2C bus.

i2c_register_adapter --> of_i2c_register_devices --> i2c_new_device 

**** 编写步骤(drivers/i2c/busses/i2c-cadence.c)
编写驱动需要填充 =i2c_adapter= 结构体, 所以顺序如下:
- 在设备树文件中, 提供控制器节点的定义:
#+begin_example
i2c0: i2c@44e0b000{
      compatible = "ti, omap4-i2c";
      #address-cells = <1>;
      #size-cells = <0>;
      ti,hwmods = "i2c1";
      reg = <0x44e0b000 0x1000>;
      interrupt = <70>;
      status = "disabled";
};
#+end_example
- 在 =deiver/i2c/busses= 目录下新建 =i2c-xxx.c= 驱动文件, 并编写 platform driver 的基本结构.
- 定义一个 =struct i2c_algorithm= 结构, 并根据控制器填充回调函数(functionality(), master_xfer())
- 在 platform driver 的 probe 函数中, 分配一个 adapter 结构, 并初始化. 
- 调用 =i2c_add_adapter / i2c_add_numbered_adapter= 结构将其注册到内核.
#+BEGIN_SRC c
static int xxx_i2c_probe(struct platform_device *pdev)
{
        struct i2c_adapter *adap;

        ...
        xxx_adapter_hw_init();
        adap->dev.parent = &pdev->dev;
        adap->dev.of_node = pdev->dev.of_node;

        rc = i2c_add_adapter(adap);
        ...
}
static int xxx_i2c_remove(struct platform_device *pdev)
{
        ...
        xxx_adapter_hw_free();
        i2c_dev_adapter(&dev->adapter);

        return 0;
}
static const struct of_device_id xxx_i2c_of_match[] = {
        {.compatible = "vendor, xxx-i2c",},
        {},
};
MODULE_DEVICE_TABLE(of, xxx_i2c_of_match);

static struct platform_driver xxx_i2c_driver =
{
        .driver = {
                .name = "xxx-i2c",
                .owner = THIS_MODULE,
                .of_match_table = xxx_i2c_of_match,
        },
        .probe = xxx_i2c_probe,
        .remove = xxx_i2c_remove,
};
module_platform_driver(xxx_i2c_driver);
#+END_SRC
*** 设备驱动的编写
**** 数据结构
I2C framework 使用 =struct i2c_client= 抽象 i2c slave device:
#+BEGIN_SRC c
/**
 ,* @brief struct i2c_client - represent an I2C slave device
 ,* @param flags -> I2C_CLIENT_TEN 代表使用10位地址, I2C_CLIENT_PEC 使用SMBus 错误检查
 ,* @param addr -> 设备的地址
 ,* @param name -> 设备名称
 ,* @param afapter -> 挂载的控制器
 ,* @param detected -> 挂接同一总线上的设备链表
 ,*/
struct i2c_client{
        unsigned short flags;
        unsigned short addr;
        char name[I2C_NAME_SIZE];
        struct i2c_adapter *adapter;
        struct device dev;
        int irq;
        struct list_head detected;
#if IS_ENABLE(CONFIG_I2C_SLAVE)
        i2c_slave_cb_t slave_cb;
#endif
};
/**
 ,* @brief struct i2c_driver - represent an I2C device driver
 ,* @param class -> 表示此驱动支持哪种类型的I2C设备
 ,* @param attach_afapter -> (此函数不再使用)
 ,* @param probe -> 绑定设备的回调
 ,* @param remove -> 卸载设备的回调
 ,* @param shutdown -> 关闭设备的回调
 ,* @param alert -> 警告
 ,* @param command -> callback for bus-wide signaling(optional)
 ,* @param id_table -> 列出此驱动支持的I2C设备, 总线驱动函数 i2c_device_match() 中会调用 i2c_match_id()
 ,* 函数匹配用户定义的ID 和 驱动ID
 ,* @param decetct -> 用于检测设备的回调
 ,* @param address_list -> 已经挂载的I2C设备地址.
 ,* @param clients: 链接所有已经挂载的设备
 ,*/
struct i2c_driver{
        unsigned int class;
        int (*attach_adapter)(struct i2c_adapter *) __deprecated;
        int (*probe)(struct i2c_client *, const struct i2c_device_id *);
        int (*remove)(struct i2c_client *);
        void (*shutdown)(struct i2c_client *);
        void (*alert)(struct i2c_client *, unsigned int data);
        int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);
        struct device_driver driver;
        const struct i2c_device_id *id_table;
        int (*detect)(struct i2c_client *, struct i2c_board_info *);
        const unsigned short *address_list;
        struct list_head clients;
};
#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)
#+END_SRC

**** 函数接口
#+BEGIN_SRC c
/**
 ,* @brief 通过设备树获取对应的 client 或者 adapter
 ,* @note 使用此函数后, 必须调用 put_device() 来解除引用计数.
 ,*/
extern struct i2c_client *of_find_i2c_device_by_node(struct device_node *node);
extern struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);

extern int i2c_master_send(const struct i2c_client *client, const char *buf, int count);
extern int i2c_master_recv(const struct i2c_client *client, char *buf, int count);

extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
/// unclocked flavor
extern int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);


#+END_SRC
**** 编写流程
I2C总线上的设备有两种形态, 一种是设备全部使用I2C与系统通信, 一种是设备的I2C仅仅用于一部分, 还有另外一部分接口.

第二种形式的连接, 需要看哪个通信为主就以哪个为主要考虑驱动.

比如第一种形式, 设备树节点就是I2C总线的一个子节点:
#+begin_example
&i2c1{
    clocl-frequency = <100000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c1>;
    status = "okay"
    ....
    pmic: pf0100@08{
          compatible = "fsl, pfuze100";
    };
};
#+end_example

第二种形式, I2C仅仅是它的一个子功能
#+begin_example
&hdmi{
    ddc-i2c-bus = <&i2c2>;
    status = "okay";
};
#+end_example

***** 形式1的编写步骤(drivers/misc/eeprom/at24.c  drivers/regulator/fpuze100-regulator.c)
- 根据设备的硬件连接, 设置其设备树.
#+begin_example
i2c0{
    status = "okay";
    clock-frequency = <400000>;
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_i2c0_default>;

    i2cswitch@74 {
                 compatible = "nxp, pca9548";
                 #address-cells = <1>;
                 #size-cells = <0>;
                 reg = <0x74>;
                 i2c@0{
                    #address-cells = <1>;
                    #size-cells = <0>;
                    reg = <2>;
                    eeprom@<54>{
                        compatible = "at, 24c08";
                        reg = <0x54>;
                    };
                 };
    };
};
#+end_example
- 定义一个 =struct i2c_driver= 变量, 并调用 module_i2c_driver 将其注册到 I2C core 中
该变量包含应该包含的DTS中的 compatible 字段相同的 of_match_table, 以及一个 probe接口.
( =module_i2c_driver= 是一个宏, 自动完成了 =xxx_init, xxx_exit= 函数)
- 在 adapter 注册时, 会自动为它的 slave device 创建 =struct i2c_client= 结构, 并匹配 =struct i2c_driver= 变量, 调用对应的 probe接口.
- i2c_driver 的 probe 接口的输入参数是 =struct i2c_client= 类型指针, 可以调用 =i2c_master_send/i2c_master_recv= 接口进行简单的I2C传输.同时也可以通过该指针获得所属的 i2c_adapter 指针, 然后通过 i2c_transfer 接口进行更为复杂的 read, write 操作.(参考 =drivers/base/regmap/regmap-i2c.c= 中的 regmap_i2c_read 接口).
- 实现I2C设备所对应类型的具体驱动. i2c_device 只是实现设备与总线的挂接, 而如果此设备驱动兼容多种真实设备, 那就需要为对应的设备实现对应的 =read(), write(), ioctl()= 函数.一般来讲, 通过misc框架新建一个字符设备驱动即可.
***** 形态2的编写步骤



