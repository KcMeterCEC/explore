#+TITLE: [What]Linux下进程和线程的调度
#+DATE:  <2018-05-26 六> 
#+TAGS: process
#+LAYOUT: post 
#+CATEGORIES: linux, ps, overview
#+NAME: <linux_ps_schedule.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

整理Linux下的进程和线程的调度。

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT


* 调度的背景
** 目标
*** 吞吐和响应
操作系统的主要目标是要在保持高的吞吐量的同时还要有高的响应速度。
- 吞吐量：整个系统在单位时间内做的有用功越多，吞吐量就越大
  + 进程的切换，代码的局部搬移都属于无用功
- 响应速度：当发生切换请求时，要以尽量快的完成切换，哪怕牺牲其他的任务为代价
  + 这其中就包含了进程环境切换，以及代码局部性处理的搬移

毫无疑问，这两个指标是互相矛盾的，只有选择一个侧重点。

在内核配置的 =Kernel Features -> Preemption Model= 中可以选择调度策略：
- No Forced Preemption(Server): 不能被抢占
- Voluntary Kernel Preemption(Desktop): kernel自愿让出
- Preemptible Kernle(Low-Latency Desktop):kernel可以被抢占(嵌入式系统一般都选择此项)
*** CPU与I/O平衡
进程分为两种类型：
- I/O消耗型：更多的是I/O操作，对CPU的占用率低
  + 在I/O操作时，一般进程会阻塞的等待，CPU会被让出去
- CPU消耗型：更多的操作是在CPU的运算上

当以红蓝图来显示CPU的消耗如下图：
[[./cpu_io.jpg]]

由此可以看出，在调度时，我们应该 *优点调度I/O消耗型* ，以让其尽快响应。
- I/O型的进程消耗时间绝大部分是在I/O设备上，所以其对CPU的性能要求并不高
  + ARM通过big.LITTLE架构来组成4小核和4大核，让小核来做I/O任务，大核做运算任务
    + 虽然小核处理能力弱，但其功耗低。而且从宏观上看其性能依然是8核的性能
* 调度算法
** 概览
*** 优先级
Linux的优先级从0~139，数值越低优先级越高。
- 在内核中，设置的值便与优先级一一对应
- 在用户空间中，设置的值通过公式 =99 - priority= 来计算真实的优先级
  + 所以在用户空间中，设置的值越小优先级反而越低
*** 策略
其中0~99使用RT策略，100~139使用NICE策略。
**** RT策略
RT策略分为 SCHED_FIFO 和 SCHED_RR:
- SCHED_FIFO:霸占CPU，除非自己主动让出
  + 在不同优先级的情况下，高优先级的对象先运行， *并且要等待此对象主动释放CPU，其他对象才能依次运行*
    + 在同优先级下，也是要等待主动释放，所以才称为FIFO(first in first out)策略
- SCHED_RR:高优先级的对象先运行，同等优先级轮转
  + 在不同优先级的情况下，高优先级的对象先运行， *并且要等待此对象主动释放CPU，其他对象才能依次运行*
    + 在同优先级下，对象轮转运行，所以才称为RR(round-robin)策略
      
可以看出，SCHED_FIFO和SCHED_RR在不同优先级的情况下策略是一样的，区别是在同等优先级的情况下。
**** NICE策略
- 不同优先级下，高优先级 *可以抢占低优先级运行* ，但 *高优先级不会霸占CPU，而是会被调度器主动剥夺CPU使用权用于低优先级运行*
  + 虽然是轮转运行，但高优先级可以获得的时间片比低优先级要多
- nice值在 -20 ~ +19 对应优先级的 100 ~ 139
  + nice值越高其优先级越低，运行的时间片越少
  + 默认新建进程的Nice值为0
*** 策略补丁
**** RT门限
根据RT策略来讲如果RT里面的线程没有主动让出CPU，那NICE策略的进程就无法运行。
为此，linux在2.6以后设置了RT门限，以设置RT策略的进程只能在一个周期里运行确定的时间。

在 =/proc/sys/kernel/= 下的 =sched_rt_period_us,sched_rt_runtime_us= 来设置 period和runtime。
- 也就是是在period的时间里，RT进程只能最多运行runtime时间。
- 可以通过命令 =chrt -f -a -p <prio> <pid>= 来改变进程的优先级
**** CFS :完全公平调度(NICE策略优化)
- NICE策略下的进程都具有一个权重
#+BEGIN_SRC c
  /*
   ,* Nice levels are multiplicative, with a gentle 10% change for every
   ,* nice level changed. I.e. when a CPU-bound task goes from nice 0 to
   ,* nice 1, it will get ~10% less CPU time than another CPU-bound task
   ,* that remained on nice 0.
   ,*
   ,* The "10% effect" is relative and cumulative: from _any_ nice level,
   ,* if you go up 1 level, it's -10% CPU usage, if you go down 1 level
   ,* it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.
   ,* If a task goes up by ~10% and another task goes down by ~10% then
   ,* the relative distance between them is ~25%.)
   ,*/
  static const int prio_to_weight[40] = {
   /* -20 */     88761,     71755,     56483,     46273,     36291,
   /* -15 */     29154,     23254,     18705,     14949,     11916,
   /* -10 */      9548,      7620,      6100,      4904,      3906,
   /*  -5 */      3121,      2501,      1991,      1586,      1277,
   /*   0 */      1024,       820,       655,       526,       423,
   /*   5 */       335,       272,       215,       172,       137,
   /*  10 */       110,        87,        70,        56,        45,
   /*  15 */        36,        29,        23,        18,        15,
  };
#+END_SRC
- 虚拟运行时间通过公式计算： vtime = ptime * 1024 / weight (NICE值越大，权重越小，虚拟运行时间越高)
  + ptime : 实际运行时间
  + weight : 权重
  + 1024: 对应NICE为0的权重
- 将此虚拟运行时间挂在一颗红黑树上
- linux首先运行红黑树上值最小的节点，当节点运行其ptime会继续增加
  + 所有随着时间推移，该节点将不会是最小的节点

基于以上这个逻辑， *I/O型的ptime就比较小，所有它就会被优先调度* ，这就满足了优先运行I/O型进程的初衷。
- 可以通过 =renice -n <nice_value> -g <pid>= 来修改进程的nice值
- 可以通过 =nice <nice_value> <process>= 来启动一个进程并设置nice
*** 设置API
| System Call              | Description          |
|--------------------------+----------------------|
| nice()                   | 设置进程的nice值     |
| sched_setscheduler()     | 设置调度策略         |
| sched_getscheduler()     | 获取调度策略         |
| sched_setparam()         | 设置RT策略优先级     |
| sched_getparam()         | 获取RT策略优先级     |
| sched_get_priority_max() | 得到RT策略最高优先级 |
| sched_get_priority_min() | 得到RT策略最低优先级 |
| sched_rr_get_interval()  | 得到RR策略时间片参数 |
| sched_setaffinity()      | 设置进程关系         |
| sched_getaffinity()      | 获取进程关系         |
| sched_yield()            | 主动让出CPU          |

在pthread库支持下，又封装了一次系统调用，通过 =pthread_attr_xxxx= 来实现设置。
