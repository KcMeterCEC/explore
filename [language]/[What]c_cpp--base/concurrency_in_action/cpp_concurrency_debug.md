---
title: C++ concurrency：调试多线程
tags: 
- cpp
categories:
- cpp
- concurrency
date: 2022/5/28
updated: 2022/5/30
layout: true
comments: false
---

多线程的调试并不简单，但也有一些常用的方法可以总结。

<!--more-->

# 多线程常遇到的问题

## 非预期的阻塞

导致非预期的阻塞通常有以下几个原因：
1. 死锁
2. 活锁：与死锁不同的是，死锁通常由互斥量、条件变量造成的线程永久睡眠。活锁是类似自旋锁这样轮询的在获取锁，所以在这个期间 CPU 的占用量会比较高。活锁有可能会一致锁下去，也有可能经过长延迟后又退出了这个状态，继续响应系统。
3. 阻塞的等待 IO 或外部事件：比如一个线程在等 IO 数据，但是产生 IO 数据的那个线程已经退出了。

## 竞态

以下这些不正常的竞态会导致代码 BUG：
1. 数据竞争：常常是由于没有或不正确的设置临界区而导致的
2. 对不变量的破坏：比如 double free，虚悬指针
3. 不正确的使用：比如返回栈上的地址

# 解决多线程问题的通用方法

比起使用 GDB，address sanitizer 这类调试神器，好的编码习惯才应该是在最一开始所需要注意的。

## 代码审核

认真仔细的审核自己的代码，并尝试反问自己为什么这么写？一些意外情况是否有考虑到？

比如在审核多线程代码时，可以考虑：
1. 哪些数据是会被并发修改的？
2. 对共享数据的保护是否正确完整？
3. 在当前时间点上，如果被其他线程抢占了会怎么样？
4. 当前线程到底获取到了哪些互斥量？
5. 当前线程和其他线程在处理数据上是否需要保持一定的顺序？
6. 当前线程的数据完全有可能被其他线程抢占修改，是否能应对这种情况？
7. 既然该数据有可能会被其他线程修改，该如何保证它的正确性？

