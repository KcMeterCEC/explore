#+TITLE: [What] 面向对象设计原则
#+DATE:<2020-10-09 五> 
#+TAGS: c++
#+LAYOUT: post 
#+CATEGORIES: language, c/c++, GoF
#+NAME: <oo_principle.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

学习视频：《c++ 设计模式》

学习书籍：《架构整洁之道》

面向对象是将对象作为一个独立的个体，自己负责自己的部分实现。而框架是以抽象的思维方式完成对这些对象的使用。
在需要新增一个对象时，应该要做到不需要修改框架就可以完成该对象的加入。

以前写代码都还是一个面向过程的思维方式，每次需要新增对象都还需要修改框架的多处代码，在框架中完成对 *每个具体对象* 的分别调用。
很明显这在前期开发、后期维护都需要消耗大量的精力。

在理解面向对象设计原则的基础上来学习设计模式才能够真正理解，而不是仅仅记住那堆代码。
#+BEGIN_HTML
<!--more-->
#+END_HTML 
* 什么是面向对象
#+BEGIN_EXAMPLE
  面向对象编程其实是对程序间接控制权的转移进行了约束。
#+END_EXAMPLE
在 c 时代，要想用 c 来支持多态特性，必须要使用函数指针来完成。这个函数指针的遵守规定的责任在程序员身上，加大了系统出错的概率。
- 使用多态是为了支持依赖反转，以提高系统的灵活性。

但面向对象语言由于有语法的支撑，通过接口来完成多态的特性，责任就到了编译器身上，系统稳定性就高得多。

这就有效的支撑了整个系统的独立部署能力：当某个组件的源代码需要修改时，仅仅需要重新部署该组件，不需要更改其它组件。
* SOLID 原则
SOLID 原则用于指导我们如何将砖块砌成墙与房间。
** 单一职责原则（SRP）
- 一个类应该仅有一个引起它变化的原因
- 变化的方向隐含着类的责任
  
简单来讲就是类的目的要简单明确，职责的简单明确就不会让这个类设计得过于复杂，不能将不同行为者所依赖的代码拼凑到一起。
- 在实现该职责时，每个方法要做到只做一件事
** 开放封闭原则（OCP）
- 对扩展开放，对更改封闭
- 类模块应该是可扩展的，但是不可修改
  
以 c++ 的方式来理解就是：当需要满足新的需求时，仅需要增加新的文件（类）来完成对现有系统的扩展，而原来框架部分是可以不用动的。

要运用好这个原则，就需要同时使用 SRP 和 DIP 原则：
- 根据业务逻辑得出其主体框架
- 运用 SRP 原则自顶向下的设计各个组件
- 根据组件与组件，以及组件与框架之间的关系确定 DIP 应用。
  + 核心就在于：不能让稳定依赖变化，而是让变化依赖稳定
- 组件内部也使用以上原则进行细分
** Liskov 替换原则（LSP）
- 子类必须能够替换它们的基类（IS-A）
- 继承表达类型抽象
  
复合、委托及继承之间的关系要明确，不然本应该用复合来实现的却用了继承这就违反了这一原则。
** 接口隔离原则（ISP）
- 不应该强迫客户程序依赖它们不用的方法
- 接口应该小而完备
  
只暴露必要的接口，降低类之间的耦合。

如果一个类被多个用户使用，但是每个用户仅使用其中一小部分，那么就需要新建类来将接口隔离。
使得每个用户仅看得到自己所使用的部分。
** 依赖倒置原则（DIP）
- 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）

抽象层规定了低层模块应该需要填充的接口，高层模块使用抽象来间接的使用低层模块。

以 c++ 的方式来理解就是：
1. 为低层模块定义一个抽象类，该类提供了一些虚函数需要低层模块来填充。
2. 低层模块继承自抽象类，完成虚函数的重载，并将自己的地址加入抽象类列表。
3. 高层模块通过操作抽象类列表，在多态的支持下，来达到间接使用低层类方法的目的。
   
为了很好的应用 DIP 原则，我们应该牢记以下守则：
- 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类
- 不要在具体实现类上创建衍生类：类的继承是依赖关系最强的方式，应该小心使用
- 不要覆盖（override）包含具体实现的函数
- 应避免在代码中写入与任何具体实现相关的名字，或者是其它容易变动事物的名字
** 其它
*** 优先使用对象组合，而不是类继承
- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
- 继承在某种程序上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
*** 封装变化点
- 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
*** 针对接口编程，而不是针对实现编程
- 不将变量类型声明为某个特定的具体类，而是声明为某个接口
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。
* 组件设计原则
组件构建原则用于指导我们如何将这些房间组合成房子。
** 什么是组件
#+BEGIN_EXAMPLE
  组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署最小的实体。
  设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。
#+END_EXAMPLE
** 组件聚合原则
*** REP：复用/发布等同原则
#+BEGIN_EXAMPLE
  软件复用的最小粒度应等同于其发布的最小粒度。
#+END_EXAMPLE

从软件设计和架构设计的角度来看，REP 原则就是指组件中的类与模块必须是彼此紧密相关的。
也就是说，一个组件不能由一组毫无关联的类和模块组成，它们之间应该由一个共同的主题或者大方向。
*** CCP：共同闭包原则
#+BEGIN_EXAMPLE
  我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，
  而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。
#+END_EXAMPLE

简而言之，就是我们要将所有可能会被一起修改的类集中在一起。

SRP 原则指导把变更原因不同的函数放入不同的类中，而 CCP 原则指导我们将变更原因不同的类放入不同的组件中。
*** CRP：共同复用原则
#+BEGIN_EXAMPLE
  不要强迫一个组件的用户依赖他们不需要的东西。
#+END_EXAMPLE

组件中的所有类是不能被拆分的，即不应该出现别人需要依赖它的某几个类而不需要其它类的情况。
也就是说，不是紧密相连的类不应该被放在同一个组件里。

ISP 原则建立我们不要依赖带有不需要的函数的类，而 CRP 原则则是建议我们不要依赖带有不需要的类的组件。
** 组件耦合原则
*** 无依赖环原则
#+BEGIN_EXAMPLE
  组件依赖关系图中不应该出现环。
#+END_EXAMPLE

使用 UML 图画出各个组件之间的依赖关系，确保不能形成一个环。

所谓不能形成一个环的意思是说：选定图中任意一个组件根据依赖箭头如果可以回到该组件自身，就说明形成了一个环。
要保证无论从图中哪个节点开始，都不能形成一个环！

假设已经形成了依赖环，那么打破环的方法有：
- 应用依赖反转原则（DIP）
- 创建新的组件：将两个组件中互相依赖的类全部放入新组件
*** 自上而下的设计
需要注意的是，组件之间的关系与架构设计初期的功能模块没有太大关系。

组件是在开发过程中被提炼出来并不断迭代的，主要目的还是为了避免稳定部分的频繁变更。

在设计组件的过程中，必然会出现环形依赖。这时应用组件聚合原则来解决这些问题。
*** 稳定依赖原则（SDP）
#+BEGIN_EXAMPLE
  依赖关系必须要指向更稳定的方向。
#+END_EXAMPLE

任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件将会变得非常难以被修改。

带有许多入向依赖关系的组件是非常稳定的，因为它的任何变更都需要应用到所有依赖它的组件上。
- 那么这个被很多组件依赖的组件就需要好好设计，最好不要频繁变更。
  
有下面方法来量化一个组件的稳定性：
- Fan-in：入向依赖，指代了组件外部类依赖于组件内部类的数量
- Fan-out：出向依赖，指代了组件内部类依赖于组件外部类的数量
- I：不稳定性，I = Fan-out / (Fan-in + Fan-out)。
  + I = 0，代表组件不依赖于其它组件，它是一个独立组件，所以它是最稳定的
  + I = 1，代表组件依赖很多其它组件，其它任何一个组件的修改都会影响该组件，所以它是最不稳定的
    
稳定依赖原则（SDP）的要求就是让每个组件的 I 指标都必须大于其所依赖组件的 I 指标。
也就是说，组件结构依赖图中各组件的 I 指标必须要按照其依赖关系方向递减。
*** 稳定抽象原则（SAP）
#+BEGIN_EXAMPLE
  一个组件的抽象化程度应该于其稳定性保持一致。
#+END_EXAMPLE

架构设计和高阶策略应该被放到稳定组件中（I = 0），而不稳定组件（I = 1）中应该只包含那些我们想要快速和方便修改的部分。

这些稳定组件应该符合开闭原则（OCP）：创造一个足够灵活、能够被扩展且不需要修改的抽象类。

将 SAP 于 SDP 两个原则结合起来，就等于组件层次上的 DIP。
- SDP 要求让依赖关系指向更稳定的方向
- SAP 说明稳定性本身就隐含了对抽象化的要求，以依赖关系应该指向更抽象的方向
  
量化一个组件的抽象化程序：
- Nc：组件中类的数量
- Na：组件中抽象类和接口的数量
- A：抽象程度，A = Na / Nc
  + A = 0，代表组件中没有任何抽象类
  + A = 1，代表组件中只有抽象类
    
[[./pic/mainLine.jpg]]

上图将 I 和 A 两个指标画在一个坐标轴来分析，我们应该尽量让一个组件设计得到的值靠近主序列线。

量化离主序列线的距离使用 D 指标：D = | A + I - 1|。
- D = 0，意味着组件是直接位于主序列线上的
- D = 1，意味着组件在距离主序列线最远的位置
  
对于一个良好的系统设计来说，D 指标的平均值和方差都应该接近于 0.
- 方差可以被作为组件的判断标准，来找出系统中那些不合常规的组件。
* 软件架构
** 什么是软件架构
#+BEGIN_EXAMPLE
  软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。

  设计软件架构的目的，就是为了在工作中更好的对这些组件进行研发、部署、运行及维护。

  软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。

  软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。
#+END_EXAMPLE
*** 开发（Development）
架构的作用之一就是要方便其开发团队对它的开发。

对小团队而言，一开始的架构设计会有诸多限制，看起来效率并不高。
但为了该软件项目具备可积累性及长期的生命力，架构设计是必不可少的。
*** 部署（Deployment）
软件架构的目标之一，就是能实现一键式的轻松部署。

*需要注意的是：* 部署是在最开始设计软件架构时就应该考虑好的，如果在项目后期才考虑，那可能会导致一些易于开发、难于部署的系统架构。
*** 运行（Operation）
良好的系统架构应该可以使开发人员对系统的运行过程一目了然。

架构应该将系统中的用例、功能以及该系统的必备行为设置为对开发者可见的一级实体，简化他们对于系统的理解。
*** 维护（Maintenance）
系统维护的主要成本集中在“探秘”和“风险”这两件事上：
- 探秘（spelunking）：对于现有软件系统的挖掘，确定新增功能或被修复问题的最佳位置和最佳方式。
- 风险（risk）：当对架构进行修改时衍生出新的问题

为了尽量降低以上风险，就需要在架构设计时精雕细琢，使用稳定的接口将组件隔离，将未来新功能的添加方式明确出来。
*** 保持可选项
为了让软件保持足够的灵活和便捷性，就需要尽可能长时间地保留尽可能多的可选项。

所有的软件系统都可以降解为策略与细节这两种主要元素：
- 策略：软件中所有业务规则与操作过程
- 细节：实现业务规则的具体细节，比如 I/O 设备、数据库、Web 系统、服务器、框架、交互协议等。

策略与细节应该是脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。
** 独立性
*** 用例
一个设计良好的架构在行为上对系统最重要的作用就是明确和显式的反映系统设计意图的行为，使其在架构层面上可见。
*** 运行
要根据实际的运行场景确定构架的运行模式，是单进程多线程，还是多进程，还是分布式。

为了满足更多的运行模式，那就需要架构能够在组件之间做一些适当的隔离。
*** 开发
构架也要根据组织内沟通结构相匹配，比如由多个不同目标的团队协作开发的系统，必须要分离出多个组件由各个团队独立完成。
*** 部署
一个设计良好的架构通常不会依赖于成堆的脚本与配置文件，也不需要用户手动创建一堆“有严格要求”的目录与文件。

最好有一个带图形的配置工具，可以让用户一键配置并部署。
*** 保留可选项
一个设计良好的架构应该通过保留可选项的方式，让系统在任何情况下都能方便地做出必要的变更。
*** 解耦
解耦的一个区分方法就是看各个部分的变更原因，比如 UI 部分与业务逻辑部分的变更原因是不同的。

解耦的同时，需要考虑运行效率而使用恰当的模式。

按水平分层和用例解耦一个系统有以下分时：
- 源码层次：控制源代码模块之间的依赖关系，避免一个模块的变更而导致其它模块也需要变更或重新编译
  + 这种解耦模式的组件在同一个地址空间运行，通过函数调用来彼此交互。此模式被称为单体结构。
- 部署层次：控制部署单元之间的依赖关系，避免一个模块的变更而导致其它模块的重新构架和部署
  + 这种解耦模式大部分组件在同一个地址空间运行，也有一部分通过进程间通信来彼此交互。
- 服务层次：组件以网络数据包的形式进行通信，组件的变更不会影响其它地方
  + 这种解耦模式在源码层和二进制层也是一个独立的个体。
    
一个设计良好的架构应该能允许一个系统从单体结构开始，以单一文件的形式部署，然后逐渐成长为一组相互独立的
可部署单元，甚至是独立的服务或者微服务。最后还能随着情况的变化，允许系统逐渐退回到单体结构。

并且，一个设计良好的架构在上述过程中还应该能保护系统的大部分源码不受变更影响。
对整个系统来说，解耦模式也应该是一个可选项，在进行大型部署时可以采用一种模式，而在进行小型部署时则可以采用另一种模式。
*** 开发的独立性
只要系统按照其水平分层和用例进行恰当的解耦，整个系统的架构就可以支持多团队开发。
** 策略与层次
本质上，所有的软件系统都是一组策略语句的集合，整体业务策略通常可以被拆解为多组更小的策略语句。

一部分策略语句专门用于描述计算部分的业务逻辑，另一部分策略语句则负责描述计算报告的格式，还有一些用于描述如何校验输入数据的策略。

软件架构需要将变更原因、时间和层次相同的策略分到同一个组件中，并将这些组件组合成为一个有向无环图。

对层次（Level）的划分依据是：一条策略距离系统的输入/输出越远，它所属的层次就越高。而直接管理输入/输出的策略在系统中的层次是最低的。
** 业务逻辑
#+BEGIN_EXAMPLE
  严格地讲，业务逻辑就是程序中那些真正用于赚钱或省钱的业务逻辑与过程。
  更严格地讲，无论这些业务逻辑是在计算机上实现的，还是人工执行的，它们在省钱/赚钱上的作用都是一样的。
#+END_EXAMPLE

业务逻辑应该保持纯净，不要与用户界面或者数据库由任何依赖，因为它是整个系统的核心。业务逻辑应该是系统中最独立、复用性最高的代码。

业务实体实际上就是计算机系统中的一种对象，这种对象包含了一系列用于操作关键数据的业务逻辑。
这些实体对象要么直接包含关键业务数据，要么可以很容易地访问这些数据。业务实体的接口层则是由
那些实现关键业务逻辑、操作关键业务数据的函数组成。
** 尖叫的软件架构
#+BEGIN_EXAMPLE
  一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整地描述用例。

  而且良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架、数据库、服务等其它与环境相关的工具。
#+END_EXAMPLE
** 整洁架构
整洁架构通常具有以下特点：
- 独立于框架：不依赖于某个功能丰富的框架之中的某个函数，框架可以被当成工具来使用，但不需要让系统来适应框架。
- 可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web 服务以及其它的外部元素来进行测试
- 独立于 UI：UI 变更起来很容易，不需要修改其他的系统部分。
- 独立于数据库：业务逻辑与数据库解耦
- 独立于任何外部机制：业务逻辑并不需要知道任何其它外部接口的存在
  
[[./pic/clean_struct.jpg]]

如上图所示，越靠近中心，其越抽象，也就越接近策略。

内层圆中的代码不应该引用外层圆中代码所声明的符号，也不应该使用外层圆中使用的数据格式。
- 业务实体：是整个系统的关键业务逻辑，应该属于系统中最不容易受到外界影响而变动的部分。
- 用例：包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。
- 接口适配器：这通常是一组数据转换器，负责将数据从对用例和业务实体而言最方便操作的格式，转为外部系统最方便操作的格式。
- 框架与驱动程序：包含了所有的实现细节，通常需要编写一些与内层沟通的粘合性代码。
** main 组件
在所有系统中，至少要有一个组件来负责创建、协调、监督其它组件的运转，称之为 Main 组件。

Main 组件的任务是创建所有的工厂类、策略类以及其它的全局设施，并最终将控制权转交给最高抽象层的代码来处理。
- Main 组件是整个系统中细节信息最多的组件。
** 测试边界
测试组件是系统架构中最外圈的程序，它们始终是向内依赖的，而且系统中没有其他组件依赖于它们。

测试组件通常是一个系统中最独立的组件，开发过程中会使能该组件，正常运行时并不需要该组件。

可以在构架中为测试创建一组 API，这组 API 用于扫描系统的所有功能函数。
- 但测试代码的运行需要绕过一些资源，比如数据库，否则这个测试会导致对数据库的摧残。

使用测试 API 的方式可以使得调用 API 的一方变得尤为简单，后期易于维护。
* 实现细节
** 数据库只是实现细节
架构中会设计很多数据结构，这些数据结构是很重要的。
但是数据库仅仅是一款用来存取数据的工具，所以对于系统架构来看，数据库是无关紧要的。
** Web 是实现细节
业务逻辑应该与 UI 解耦，以应对不同时期 UI 的展现形式。

GUI 只是一个实现细节，而 Web 则是 GUI 的一种，所以也是一个实现细节。所以需要将 Web 与核心业务逻辑隔离开来。
** 应用程序框架是实现细节
使用应用程序框架，需要承担以下风险：
- 框架自身的架构设计很多时候并不是特别正确。
  + 如果框架自身违反了依赖关系原则，那在后期的扩展中便可能会遇到一些麻烦
- 随着产品的成熟，产品的功能要求可能超出框架所能提供的范围。
  + 到时候框架反而是产品继续扩展的最大阻碍
- 框架本身可能朝着我们不需要的方向演进。
  + 这可能会违背我们的核心业务逻辑。
    
所以我们应该将框架作为架构最外圈的一个实现细节来使用，不要让它们进入内圈。
