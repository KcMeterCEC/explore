#+TITLE: [What] 代理模式
#+DATE:<2020-11-16 一> 
#+TAGS: c++
#+LAYOUT: post 
#+CATEGORIES: language, c/c++, GoF
#+NAME: <Proxy.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

学习视频：<<c++ 设计模式>>

从封装变化角度对模式分类：
- 组件协作：通过 *晚期绑定* ，来实现框架和应用之间的松耦合
  + Template Method
  + Strategy
  + Observer / Event
- 单一职责
  + Decorator
  + Bridge
- 对象创建
  + Factory Method
  + Abstract Factory
  + Prototype
  + Builder
- 对象性能
  + Singleton
  + Flyweight
- 接口隔离
  + Facade
  + Proxy
  + Mediator
  + Adapter
- 状态变化
  + Memento
  + State
- 数据结构
  + Composite
  + Iterator
  + Chain of Resposibility
- 行为变化
  + Command
  + Visitor
- 领域问题
  + Interpreter

#+BEGIN_HTML
<!--more-->
#+END_HTML
* 问题
#+BEGIN_EXAMPLE
  在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，
  或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。

  如何在不失去透明操作对象的同时来管理/控制这些对象持有的复杂性？增加一层间接层是软件开发中常见的解决方式。
#+END_EXAMPLE
* 解决
#+BEGIN_EXAMPLE
为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。
#+END_EXAMPLE

“增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。
在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的 Proxy 对象便是解决这一问题的常用手段。

具体 proxy 设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制（如 copy-on-write 技术），
有些可能对组件模块提供抽象代理层，在架构层次对对象做 proxy。

Proxy 并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损失一些透明性是可以接受的。

按照 UML 类图的简易逻辑如下：
[[./pic/proxy.jpg]]

