#+TITLE: [What] c++ 顺序容器
#+DATE:<2020-02-13 四> 
#+TAGS: c++
#+LAYOUT: post 
#+CATEGORIES: language, c/c++, primer
#+NAME: <language_cpp_container.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

学习书籍：<<c++ primer 5th>>

学习 c++ 标准库下的顺序容器（sequential container）的操作。
#+BEGIN_HTML
<!--more-->
#+END_HTML 
* 顺序容器
顺序容器提供了快速顺序访问元素的能力，这种顺序不依赖于元素的值，而是与元素加入容器时的位置对应。

但这些顺序容器在以下方面都有不同的性能折中：
- 向容器添加或从容器中删除元素的代价
- 非顺序访问容器中元素的代价

标准库提供了下面这些容器：
| 类名         | 说明                                                                          |
|--------------+-------------------------------------------------------------------------------|
| vector       | 可变大小数组，支持快速随机访问。 *但在尾部之外的位置插入或删除元素可能很慢！* |
| deque        | 双端队列，支持快速随机访问，且在头尾位置插入/删除速度很快                     |
| list         | 双向链表，只支持双向顺序访问，在任何位置插入/删除速度都很快                   |
| forward_list | 单向链表，只支持单向顺序访问，在任何位置插入/删除操作都很快                   |
| array        | 固定大小数组，支持快速随机访问，不能添加或删除元素                            |
| string       | 与 vector 类似，专用户保存字符                                                |

string 和 vector 将元素保存在连续的内存空间中，所以可以通过下标来快速寻址，但如果在中间位置添加或删除元素，则涉及到内存搬移，效率就低下。
- 添加一个元素当遇到需要分配额外空间时，也会由于申请新的空间而变慢

list 和 forward_list 可以很快在任意位置添加和删除元素，但由于内存不连续无法通过下标随机访问，只能遍历。

deque 与 string 和 vector 类似，也支持快速随机访问，并且在头尾添加或删除元素速度很快，但在中间添加或删除元素依然很慢。

array 相比内置数组而言更加安全和容易使用。

顺序容器的选择原则如下：
- 除非有更好的理由选择其他容器，否则应该使用 =vector=
- 如果元素很小且内存空间很敏感，则不要使用 =list= 或 =forward_list=
- 如果程序要求随机访问，应该使用 =vector= 或 =deque=
- 如果程序要求在容器中间插入或删除元素，应该使用 =list= 或 =forward_list=
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，应该使用 =deque=
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，那么
  + 可以考虑先使用 =vector= 在尾部追加数据，然后使用 =sort= 函数来排序，而避免中间插入的低效性
  + 如果必须在中间插入，考虑在输入时使用 =list= ，输入完成后，将 =list= 内容拷贝到 =vector= 以提高访问效率
    
当需要编写 =vector= 和 =list= 的公共操作函数时，可以使用迭代器而不是下标来访问元素。




* 容器库通用操作概览
每个容器都定义在一个头文件中，文件名与类型相同，并且 *容器类均是模板类* 。

既然是模板类，就需要在创建对象时为其指定元素的类型：
#+BEGIN_SRC c++
  list<int> int_list;//元素类型为 int 的 List
  deque<double> dq;//元素类型为 double 的 deque
  vector<vector<string>> lines;//元素类型是 vector<string> 的 vector，其元素是内容为 string 的 vector
#+END_SRC

标准库提供的容器操作如下：
| 操作                                          | 说明                                                                                                                         |
|-----------------------------------------------+------------------------------------------------------------------------------------------------------------------------------|
| *[类型别名]*                                  | 习惯使用类型别名，而不去关注具体的类型，可以让函数处理多种不容类型的容器                                                     |
| iterator                                      | 此容器类型的迭代器类型                                                                                                       |
| const_iterator                                | 此容器类型的只读迭代器类型                                                                                                   |
| size_type                                     | 无符号整型，足够保存此容器类型最大可能容器的大小                                                                             |
| difference_type                               | 带符号整型，足够保存两个迭代器之间的距离                                                                                     |
| value_type                                    | 元素类型                                                                                                                     |
| reference                                     | 元素的左值引用，等同于 =value_type &=                                                                                        |
| const_reference                               | 元素的 const 引用，等同于 =const value_type &=                                                                               |
| *[构造函数]*                                  |                                                                                                                              |
| C<type> c;                                    | 使用默认构造函数，容器内容为空                                                                                               |
| C<type> c1(c2);                               | 当 c2 是对象时，c2 的内容拷贝到 c1 ，构造对象。当 c2 是数值时，创建 c2 个元素的对象                                          |
| C<type> c(b,e)                                | 当为迭代器时，将迭代器 b 和 e 指定的范围内的元素拷贝到 c( *array不支持* )。当 b 为数值, e 为值时，创建 b 个元素值为 e 的对象 |
| c<type> c{a,b,c...}                           | 列表初始化 c                                                                                                                 |
| *[赋值与 swap]*                               |                                                                                                                              |
| c1 = c2;                                      | c1 中的元素替换为 c2 中的元素                                                                                                |
| c = {a,b,c...}                                | c1 中的元素替换为列表中的元素（ *不适用于 array* ）                                                                          |
| a.swap(b)                                     | 交换 a 和 b 的元素                                                                                                           |
| swap(a,b)                                     | 同上                                                                                                                         |
| *[大小]*                                      |                                                                                                                              |
| c.size()                                      | 返回 c 中元素的数目（ *不支持 forware_list* ）                                                                               |
| c.max_size()                                  | 返回 c 可以存放最大元素的数目                                                                                                |
| c.empty()                                     | 当 c 为空返回 true                                                                                                           |
| *[添加/删除元素]（不适用于 array）*           | 在不同容器中，这些操作的接口都不同                                                                                           |
| c.insert(args)                                | 将 args 中的元素拷贝进 c                                                                                                     |
| c.emplace(inits)                              | 使用 inits 构造 c 中的一个元素                                                                                               |
| c.erase(args)                                 | 删除 args 指定的元素                                                                                                         |
| c.clear()                                     | 删除 c 中的所有元素                                                                                                          |
| *[关系运算符]*                                |                                                                                                                              |
| （==,!=）                                     | 所有容器都支持                                                                                                               |
| （<，<=，>，>=）                              | 无序关联容器不支持                                                                                                           |
| *[获取迭代器]*                                |                                                                                                                              |
| c.begin(),c.end()                             | 返回指向 c 的首元素和 *尾元素之后位置* 的迭代器                                                                              |
| c.cbegin(),c.cend()                           | 同上，但此迭代器是只读的                                                                                                     |
| *[反向容器的额外成员]（不支持 forward_list）* |                                                                                                                              |
| reverse_iterator                              | 按逆序寻址元素的迭代器                                                                                                       |
| const_reverse_iterator                        | 按逆序寻址元素的只读迭代器                                                                                                   |
| c.rbegin(),c.rend()                           | 返回指向 c 的尾元素和 *首元素之前位置* 的迭代器                                                                              |
| c.crbegin(),c.crend()                         | 同上，只是返回的迭代器是只读的                                                                                               |

** 迭代器
迭代器允许通过解引用运算符来实现访问容器内容的功能，标准库容器的所有容器都定义了递增运算符，其中 =forward_list= 不支持递减运算符。

迭代器的 =begin()= 和 =end()= 方法表示了容器的范围，它们是左闭合区间：
#+BEGIN_EXAMPLE
  [begin, end)
#+END_EXAMPLE 
- end 与 begin 指向相同的位置，但不能指向 begin 之前的位置
- 如果 begin 与 end 相等，则容器为空
- 如果 begin 与 end 不等，则容器至少包含一个元素，且 begin 指向该范围中的第一个元素
- 可以对 begin 递增若干次，使得 begin == end

