* [What] java --> base

参考网站:[[www.runoob.com/java/java-basic-syntax.html][菜鸟教程]]

- [[#基本格式与类型][基本格式与类型]]
- [[#对象和类][对象和类]]
- [[#基本数据类型][基本数据类型]]
- [[#修饰符][修饰符]]
- [[#运算符][运算符]]
- [[#循环][循环]]
- [[#常用类][常用类]]
- [[#数组][数组]]
- [[#方法][方法]]
- [[#流,文件,IO][流,文件,IO]]
- [[#异常][异常]]
- [[#继承][继承]]
- [[#重写与重载][重写与重载]]
- [[#多态][多态]]
- [[#抽象类][抽象类]]
- [[#接口][接口]]
- [[#包和权限][包和权限]]
- [[#数据结构][数据结构]]
- [[#集合框架][集合框架]]
- [[#泛型][泛型]]
- [[#序列化][序列化]]
- [[#文档注释][文档注释]]
- [[#JNI][JNI]]

** 基本格式与概览
*** 基本格式
**** 基本结构
#+BEGIN_SRC java
/**
 ,* @brief : 最简单的代码
 ,* @note:
 ,* 1. 此文件的名称是: HelloWorld.java, 也就是说类名要和文件名一致
 ,* 2. 类名的首字母需要大写,如果类名由若干单词组成,那么每个单词的首字母应该大 写
 ,* 3. 所有的方法名都应该以小写字母开头,如果含有若干单词,则后面的每个单词首字母大写
 ,* 3. 编译命令： javac HelloWorld.java,用于将源文件编译为class字节码文件
 ,* 4. 运行命令： java HelloWorld,后面跟类名
 ,*/
public class HelloWorld{
        /// java 程序有且仅有一个main方法,所有的java程序由此方法开始执行, args[0]是第一个参数，以此推类
        public static void main(String[] args){
                System.out.println("Hello World");
                System.out.println(args[0]);
        }     
}
#+END_SRC
*** 概览
**** 标识符
标识符与C语言标识符规则一致, 在此基础之上, *JAVA可以以 $ 为开始或作为标识符内部字符*
**** 修饰符
JAVA可以使用修饰符来修饰类中方法和属性:
- 访问控制修饰符: default, public, protected, private
- 非访问控制修饰符: final, abstract, strictfp
**** 变量
- 局部变量
- 类变量(静态变量)
- 成员变量(非静态变量)

**** 枚举
#+BEGIN_SRC java
class FreshJuice{
        enum FreshJuiceSize{SMALL, MEDIUM, LARGE}
        FreshJuiceSize size;
}

public class FreshJuiceTest{
        public static void main(String [] args){
                FreshJuice juice = new FreshJuice();
                juice.size = FreshJuice.FreshJuiceSize.MEDIUM;
        }
}
#+END_SRC

**** 关键字
下表列出了与C语言不同的关键字:
| 关键字       | 描述                                                                       |
|--------------+----------------------------------------------------------------------------|
| abstract     | 抽象方法, 抽象类的修饰符                                                   |
| assert       | 断言条件是否满足                                                           |
| boolean      | 布尔类型                                                                   |
| byte         | 8位有符号数据                                                              |
| catch        | 和try搭配捕捉异常信息                                                      |
| char         | 16位的 Unicode 字符数据类型                                                |
| class        | 定义类                                                                     |
| extends      | 表示一个类是另一个类的子类                                                 |
| final        | 表示一个值在初始化后就不能再改变了,表示方法不能被重写,或者一个类不能有子类 |
| finally      | 无论有没有异常发生都执行代码                                               |
| implements   | 表示一个类实现了接口                                                       |
| import       | 导入类                                                                     |
| instanceof   | 测试一个对象是否是某个类的实例                                             |
| interface    | 接口,一种抽象类型,仅有方法和常量的定义                                     |
| native       | 表示方法用非java代码实现                                                   |
| new          | 分配新类的实例                                                             |
| package      | 一系列相关类组成一个包                                                     |
| private      | 表示私有字段或者方法等,只能从类内部访问                                    |
| protected    | 表示字段只能通过类或者其子类访问子类或者在同一个包内的其他类               |
| public       | 表示共有属性或者方法                                                       |
| strictfp     | 浮点数比较使用严格的规则                                                   |
| super        | 表示基类                                                                   |
| synchronized | 表示同一时间只能由一个线程访问的代码块                                     |
| this         | 表示调用当前实例或者调用另一个构造函数                                     |
| throw        | 抛出异常                                                                   |
| throws       | 定义方法可能抛出的异常                                                     |
| transient    | 修饰不要序列划的字段                                                       |
| try          | 表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码 |
** 对象和类
*** 类中变量
- 局部变量: 在方法内定义的变量,方法结束后变量内存就被销毁了.
- 成员变量: 定义在类中, 在方法之外的变量.成员变量可以被类中方法访问
- 类变量: 类变量也声明在类中,方法之外, *但声明为static类型*.
  + 无论一个类创建了多少个对象, 类只拥有变量的一份拷贝.
  + 类变量一般是用于被声明为常量.
  + 类变量被声明为 =public,static,final= 类型时, 类变量名称一般使用大写字母.否则就与一般变量的命名方式一致.

*** 概览
#+BEGIN_SRC java
/**
 ,* @note
 ,* 1. 一个源文件只能有一个public类
 ,* 2. 一个源文件可以有多个非public类
 ,* 3. 如果一个类定义在某个包中,那么package语句应该在源文件的首行
 ,* 4. 如果源文件包含import语句,那么应该放在package语句和类定义之间.如果没有package语句,那么import语句应该在源文件中最前面.
 ,*/
public class Puppy{
        /// 类变量
        static int allClicks = 0;
        /// 成员变量
        int puppyAge;
        /**
         ,* @note: 每个类都有构造方法,如果没有显式地为类定义构造方法,
         ,* Java 会提供一个默认构造方法.
         ,* 在创建对象的时候,至少要调用一个构造方法, 构造方法名称必须与类同名,一个类可以有多个构造方法
         ,*/
        public Puppy(String name){
                System.out.println("小狗的名字是:" + name);
        }
        public void setAge(int age){
                puppyAge = age;
        }
        public int getAge(){
                System.out.println("小狗的年龄为:" + puppyAge);
                return puppyAge;
        }
        public static void main(String [] args){
                Puppy mypuppy = new Puppy("tommy");
                mypuppy.setAge(2);
                mypuppy.getAge();
                System.out.println("变量值:" + mypuppy.puppyAge);
        }
}
#+END_SRC

** 基本数据类型
*** 内置数据类型
java数据类型与C类似, 但需要注意的是: JAVA数据类型是 *一个对象*,所以它具有自己的方法.
#+BEGIN_SRC java
public class PrimitiveTypeTest{
        public static void main(String[] args){
                System.out.println("byte size:" + Byte.SIZE);
                System.out.println("Byte minimum:" + Byte.MIN_VALUE);
                System.out.println("Byte maximum:" + Byte.MAX_VALUE);
        }
}
#+END_SRC
*** 引用类型
- 引用类型非常类似于 C/C++ 指针, 引用类型指向的变量是引用变量,这些变量在声明时被指定为一个特定的类型,一旦声明后,类型就不能被改变了.
- 对象,数组都是引用数据类型
- 所有引用类型的默认值都是NULL
- 一个引用变量可以用来引用与之兼容的类型
*** 常量
使用 =final= 关键字来修饰常量:
#+BEGIN_SRC java
final double PI = 3.141592653;
#+END_SRC
字符串常量和字符常量都可以包含任何Unicode字符,例如:
#+BEGIN_SRC java
char a = '\u0001';
String a = "\u0001";
#+END_SRC
- 整数的默认类型是 int 
- 浮点必须在数字后跟上 F 或者 f
*** 自动类型转换
不同类型在运算时,会先转换为同一类型,然后才运算.

转换是将低级数据类型转换为高级: byte,short,char -> int -> long -> float -> double

规则如下:
- 不能对 =boolean= 类型进行类型转换
- 不能把对象类型转换为不相关类的对象
- 把容量大的类型转换为容量小的类型时必须使用强制类型转换
- 转换过程中可能导致溢出或损失精度
- 浮点数到整数的转换时通过舍弃小数得到的, 而不是四舍五入
*** 强制类型转换
格式与C一致: (type)value 
- 转换的数据类型必须是兼容的
** 修饰符
修饰符用来定义类,方法或者变量,通常放在语句的最前端:
#+BEGIN_SRC java
public class className{
        private boolean myFlag;
        static final double WEEKS = 9.5;
        protected static final int BOXWIDTH = 42;
        public static void main(String[] args){
                
        }
}
#+END_SRC
*** 访问控制修饰符
| 修饰符    | 当前类 | 同一包内 | 子孙类 | 其他包 |
|-----------+--------+----------+--------+--------|
| public    | Y      | Y        | Y      | Y      |
| protected | Y      | Y        | Y      | N      |
| default   | Y      | Y        | N      | N      |
| private   | Y      | N        | N      | N      |

- 接口里的变量都隐式声明为 =public static final=, 接口里的方法默认情况下权限为 =public=.
- 被声明为 =private= 的方法,变量和构造方法只能被所属类访问, *类和接口不能声明为 private*.
  + private 主要用来隐藏类的实现细节和保护类的数据.
- protected 不能用于类和接口, 方法和成员变量能够声明为 protected,但是接口的成员变量和成员方法不能声明为 protected.
- 父类中声明为 public 的方法在子类中也必须为 public
- 父类中声明为 protected 的方法在子类中要么声明为 protected , 要么为 public, 不能为 private.

*** 非访问修饰符
- static 修饰符, 用来修饰类,方法和类变量
- final 修饰符,用来修饰类,方法和变量,final 修饰的类不能被继承, 修饰的方法不能被继承类重新定义, 修饰的变量为常量,不能被修改.
- abstract 修饰符, 用来创建抽象类和抽象方法.
- synchronized 和 volatile 修饰符, 主要用于线程的编程.
**** static
- static 用于方法外变量时,称为静态变量(类变量).无论一个类实例化多少对象, 它的静态变量只有一份拷贝.
- static 用于方法时, 声明独立于对象的静态方法.静态方法不能使用类的非静态变量,静态方法从参数列表得到数据,然后计算这些数据.
#+BEGIN_SRC java
public class InstanceCounter{
        private static int numInstances = 0;
        protected static int getCount(){
                return numInstances;
        }
        private static void addInstance(){
                numInstances++;
        }
        InstanceCounter(){
                addInstance();
        }
        public static void main(String[] args){
                System.out.println("Starting with " + InstanceCounter.getCount() + " instances");
                for(int i = 0; i < 500; i++)
                {
                        new InstanceCounter();
                }
                System.out.println("Created " + InstanceCounter.getCount() + " instances");
        }
}
#+END_SRC

**** final 
***** 变量
- final 用于变量时能被显式的初始化并且只能被初始化一次.被声明为 =final= 的对象的引用不能指向不同的对象.
但是 final 对象里的数据可以被改变.
- final 修饰符通常和static 修饰符一起使用来创建类常量.

***** 方法
- 类中的 final 方法可以被子类继承, 但是不能被子类修改.
***** 类
- final 类不能被继承.
**** abstract
***** 抽象类
- 抽象类不能用来实例化对象, 声明抽象类的唯一目的式为了将来对该类进行扩充.
- 一个类不能同时被 abstract 和 final 修饰.
- 抽象类可以包含抽象方法和非抽象方法
#+BEGIN_SRC java
abstract class Caravan{
        private double price;
        private String model;
        private String year;
        public abstract void goFast();
}
#+END_SRC
***** 抽象方法
- 抽象方法式一种没有任何实现的方法, 该方法的具体实现由子类提供.
- 抽象方法不能被声明为 =final 和 static=.
- 任何继承抽象类的子类必须实现父类的所有抽象方法, 除非该子类也是抽象类.
- 如果一个类包含若干个抽象方法, 那么该类必须声明为抽象类.抽象类可以不包含抽象方法.
#+BEGIN_SRC java
public abstract class SuperClass{
        abstract void m();
}
class SubClass extends SuperClass{
        void m(){
                ....
        }
}
#+END_SRC
**** synchronized 
- synchronized 声明的方法 *同一时间只能被一个线程访问*.
**** transient
- 序列化的对象包含被 =transient= 修饰的实例变量时, java 虚拟机跳过该特定的变量.该修饰符包含在定义变量的语句中, 用来预处理类和变量的数据类型.
**** volatile
- volatile 修饰的成员变量在每次被线程访问时, 都强制从共享内存中读取该成员变量的值.当成员变量发生变化时, 会强制线程将变化值回写到共享内存.
这样在任何时刻, 两个不同的线程总是看到某个成员变量的同一个值.
** 运算符
绝大部分与C一样, 下面列出新增部分:
| 操作符     | 描述                                                                                            | 例子                                                            |
|------------+-------------------------------------------------------------------------------------------------+-----------------------------------------------------------------|
| >>>        | 按位右补零操作符.左操作数的值按右操作数指定的位数右移,移动得到的空位以零填充                    | A = 60; A >>> 2 得到15, 即 0000 1111                            |
| instanceof | 检查对象是否是一个特定的类型,格式: (Object reference variable)instanceof (class/interface type) | boolean result = a instanceof Car (检查对象是否是 Car 类的实例) |

** 循环
与C一样, 在此基础上, JAVA提供了 *增强for循环, 主要用于数组*.
#+BEGIN_SRC java
for(声明语句 : 表达式)
{
        //代码句子
}
#+END_SRC
- 声明语句: 声明新的局部变量, 该变量的类型必须和数组元素的类型匹配. 其作用域限定在循环语句块, 其值与此时数组元素的值相等.
- 表达式:表达式是要访问的数组名, 或者是返回值位数组的方法.
#+BEGIN_SRC java
public class Test{
        public static void main(String [] args){
                int [] numbers = {10, 20, 30, 40, 50};
                for(int x : numbers){
                        System.out.print(x);
                        System.out.print(",");
                }
                System.out.print("\n");
                String[] names = {"James", "Larry", "Tom", "Lacy"};
                for(String name : names){
                        System.out.print(name);
                        System.out.print(",");
                }
        }
}
#+END_SRC

** 分支
与C一致.
** 常用类
*** Number & Math 
- 所有的包装类(Integer,Long,Byte,Double,Float,Short)都是抽象类 Number 的子类.
#+BEGIN_SRC java
public class Test{
        public static void main(String [] args)
                {
                        Integer x = 5;
                        x = x + 10;
                        System.out.println(x);
                }
}
#+END_SRC

Math 类包含了用于执行基本数学运算的属性和方法, Math 的方法都被定义位 static 形式.
#+BEGIN_SRC java
public class Test{
        public static void main(String [] args)
                {
                        System.out.println("90 度正弦值:" + Math.sin(Math.PI/2));
                        System.out.println("0 度余弦值:" + Math.cos(0));
                        System.out.println("60 度正切值:" + Math.tan(Math.PI/3));
                        System.out.println("1的反正切值:" + Math.atan(1));
                        System.out.println(Math.PI);
                }
}
#+END_SRC
*** Character
Character 类提供了一系列方法来操纵字符.
#+BEGIN_SRC java
Character ch = new Character('a');
#+END_SRC
*** String
String 类用于创建和操作字符串.
- String 类是不可改变的,  *一旦创建了String对象, 那它的值就无法改变了.*
#+BEGIN_SRC java
String greeting = "菜鸟教程"
#+END_SRC
#+BEGIN_SRC java
public class StringDemo{
        public static void main(String []args){
                char[] helloArray = {'r', 'u', 'n', 'o', 'o','b'};
                String helloString = new String(helloArray);
                System.out.println(helloString);
        }
                
}
#+END_SRC
*** StringBuffer
当对字符串进行修改的时候, 需要使用 =StringBuffer= 和 =StringBuilder= 类.

和 =String= 类不同的是, =StringBuffer= 和 =StringBuilder= 类的对象能够被多次修改, 并且不产生新的未使用对象.

=StringBuilder= 和 =StringBuffer= 之间的最大不同在于 =StringBuilder= 的方法不是线程安全的.

=StringBuilder= 相较于 =StringBuffer= 有速度优势, 多数情况下使用 =StringBuilder= 类.
#+BEGIN_SRC java
public class Test{
        public static void main(String []args){
                StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");
                sBuffer.append("www");
                sBuffer.append(".runoob");
                sBuffer.append(".com");
                System.out.println(sBuffer);
        }
}
#+END_SRC

*** Date
java.util 包提供了 Date 类来封装当前日期和时间.

*** 正则表达式
java.util.regex 包主要包括以下三个类:
- Pattern
- Matcher
- PatternSyntaxException
*** scanner
java.util.Scanner 是 java5 的新特征, 通过 Scanner 类来获取用户的输入.
** 数组
*** 声明
#+BEGIN_SRC java
dataType[] arrayRefVar;
dataType arrayRefVar[];

///example:
double[] myList;
double myList[];
#+END_SRC
*** 创建
#+BEGIN_SRC java
dataType[] arrayRefVar = new dataType[arraySize];
dataType[] arrayRefVar = {value0, value1, value2,...};

///example
double[] myList = new double[10];
#+END_SRC

*** 处理
- 使用基本的for循环:
#+BEGIN_SRC java
public class TestArray{
        public static void main(String[] args){
                double[] myList = {1.9, 2.9, 3.4, 3.5};

                for(int i = 0; i < myList.length; i++)
                {
                        System.out.println(myList[i] + " ");
                }
                double total = 0;
                for(int i = 0; i < myList.length; i++)
                {
                        total += myList[i];
                }
                System.out.println("Total is " + total);
                double maximum = myList[0];
                for(int i = 1; i < myList.length; i++)
                {
                        if(myList[i] > maximum){
                                maximum = myList[i];
                        }
                }
                System.out.println("maximum is " + max);
        }
}
#+END_SRC
- 使用高级for循环:
#+BEGIN_SRC java
public class TestArray{
        public static void main(String[] args){
                double[] myList = {1.9, 2.9, 3.4, 3.5};

                for(double element: myList){
                        System.out.println(element);
                }
        }
}
#+END_SRC
- 作为函数的参数:
#+BEGIN_SRC java
public static void printArray(int[] array){
        for(int i = 0; i < array.length; i++){
                System.out.print(array[i] + " ");
        }
}
#+END_SRC
- 作为函数的返回值
#+BEGIN_SRC java
public static int[] reverse(int[] list){
        int[] result = new int[list.length];

        for(int i = 0, j = result.length - 1; i < list.length; i++, j--){
                result[j] = list[i];
        }
        return result;
}
#+END_SRC
- 多维数组
#+BEGIN_SRC java
type arrayName = new type[arraylength1][arraylength2];

//example
int a [][] = new int[2][3];

String s[][] = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good");
s[0][1] = new String("Luck");
s[1][0] = new String("to");
s[1][1] = new String("you");
s[1][2] = new String("!");
#+END_SRC
- java.util.Arrays 类能方便地操作数组, 它所提供的所有方法都是静态的.
  + 给数组赋值: 通过 fill 方法
  + 对数组排序: 通过 sort 方法,按升序
  + 比较数组: 通过 equals 方法比较数组元素值是否相等
  + 查找数组元素: 通过 binarySearch 方法能对排序号的数组进行二分查找法操作
** 方法
java 方法是语句的集合, 它们在一起执行一个功能.
- 方法是解决一类问题的步骤的有序组合
- 方法包含于类和对象中
- 方法在程序中被创建, 在其他地方被引用.
*** 命令规则
- 必须以字母, '_'或'$'开头
- 可以包括数字,但不能以它开头
*** 定义
#+begin_example
修饰符 返回值类型 方法名(参数类型 参数名){
       方法体
       return 返回
}
#+end_example
#+BEGIN_SRC java
public static int age(int birthday){
}
#+END_SRC
*** 调用
java 支持两种调用方法的方式, 根据方法是否返回值来选择.
#+BEGIN_SRC java
public class TestMax{
        public static void main(String[] args){
                int i = 5;
                int j = 2;
                int k = max(i, j);
                System.out.println(i + " and " + j + "compare, the maximum is: " + k);
        }
        public static int max(int num1, int num2){
                int result;
                if(num1 > num2)
                        result = num1;
                else
                        result = num2;

                return result;
        }
}
#+END_SRC
*** 方法的重载
方法具有相同的名字, 但参数不同.

java编译器根据方法签名判断哪个方法应该被调用.
*** 变量作用域
方法内定义的变量被称为局部变量, 局部变量的作用范围从声明开始, 直到包含它的块结束.
*** 构造方法
当一个对象被创建的时候, 构造方法用来初始化该对象.
- 构造方法和它所在类的名字相同, 但 *构造方法没有返回值*.
- java 自动提供了默认的构造方法, 它把所有成员初始化为0.一但定义了自己的构造方法, 默认构造方法就会失败.
#+BEGIN_SRC java
class MyClass{
        int x;
        MyClass(){
                x = 10;
        }
}
#+END_SRC
*** 可变参数
方法的可变参数声明: =typeName... parameterName=.
- 一个方法中只能指定一个可变参数, 它必须是方法的最后一个参数, 任何普通的参数必须载它之前声明
#+BEGIN_SRC java
public class VaragsDemo{
        public static void main(String[] args){
                printMax(34, 3, 3, 2, 56.5);
                printMax(new double[]{1, 2, 3,});
        }
        public static void printMax(double... numbers){
                if(numbers.length == 0){
                        System.out.println("No argument passed");
                        return;
                }
                double result = numbers[0];

                for(int i = 1; i < numbers.length; i++){
                        if(numbers[i] > result){
                                result = numbers[i];
                        }
                }
                System.out.println("The maximum value is " + result);
        }
}
#+END_SRC
*** finalize() 方法
finalize() 方法在对象被垃圾收集器析构(回收)之前调用, 用来清除回收对象.
#+BEGIN_SRC java
protected void finalize(){
        
}
#+END_SRC
#+BEGIN_SRC java
public class FinalizationDemo{
        public static void main(String[] args){
                Cake c1 = new Cake(1);
                Cake c2 = new Cake(2);
                Cake c3 = new Cake(3);
                
                c2 = c3 = null;
                //调用java垃圾收集器
                System.gc();
        }
        class Cake extends Object{
                private int id;
                public Cake(int id){
                        this.id = id;
                        Syste.out.println("Cake Object " + id + "is created");
                }
                protected void finalize() throws java.lang.Throwable{
                        super.finalize();
                        System.out.println("Cake Object " + id + "is disposed");
                }
        }
}
#+END_SRC
** 流,文件,IO
[[./io_stream.jpg]]
java.io 包几乎包含了所有操作输入,输出需要的类, 所有这些流类代表了输入源和输出目标.

一个流可以理解为一个数据的序列, 输入流表示从一个源读取数据, 输出流表示向一个目标写数据.
*** 读取控制台输入
控制台输入由 System.in 完成.

为了获得绑定到控制台的字符流, 可以把 system.in 包装在一个 BufferedReader 对象中来创建一个字符流.
#+BEGIN_SRC java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
#+END_SRC
BufferedReader 对象创建后, 使用 read() 方法从控制台读取一个字符, 或者用 readLine() 方法读取一个字符串.
**** 从控制台读取多字符输入
读取一个字符, 使用 =read()= 方法,每次调用 read 方法它从输入流读取一个字符并把该字符作为整数值返回,当流结束的时候返回 -1, 该方法抛出 IOException:
#+BEGIN_SRC java
int read() throws IOException
#+END_SRC
#+BEGIN_SRC java
import java.io.*;

public class BRRead{
        public static void main(String[] args) throws IOException{
                char c;

                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                System.out.println("input char, enter 'q' to exit.");
                do{
                        c = (char)br.read();
                        System.out.println(c);
                }
                while(c != 'q');
        }
}
#+END_SRC
**** 从控制台读取字符串
从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法.
#+BEGIN_SRC java
import java.io.*;
public class BRReadLines{
        public static void main(String[] args) throws IOException{
                BufferReader br = new BufferReader(new InputStreamReader(System.in));

                String str;
                System.out.println("Enter lines of text.");
                System.out.println("Enter 'end' to quit.");
                do{
                        str = br.readLine();
                        System.out.println(str);
                }
                while(!str.equals("end"));
        }
}
#+END_SRC

*** 控制台输出
- 控制台输出由 print() 和 println() 完成.这些方法都由类 PrintStream 定义, System.out 是该类对象的一个引用
- PrintStream 继承了 OutputStream 类, 并且实现了方法 write(). 这样 write() 也可以用来向控制台写操作.
- PrintStream 定义 write(): =void write(int byteval)=.将 byteval 的低八位写到流中.
- 实际建议使用 =System.out.print(), System.out.println()=.

*** 读写文件
** 异常
异常是程序中的一些错误, 但并不是所有的错误都是异常, 并且错误有时候是可以避免的.

异常发生的原因通常包含以下几大类:
- 用户输入了非法数据
- 要打开的文件不存在
- 网络通信时连接中断或者JVM内存溢出

异常的类型:
- 检查性异常: 最具代表的检查性异常是用户错误或问题引起的异常,这是程序员无法预见的.
- 运行时异常: 运行时异常是可能被程序员避免的异常.
- 错误: 错误不是异常, 而是脱离程序员控制的问题.
*** Exception 类的层次
[[./exception.jpg]]

- 所有的异常类是从 java.lang.Exception 类继承的子类.
- java程序通常不捕获错误
- Error 用来指示运行时环境发生的错误

当程序发生异常时,可以处理或者默认不处理,处理又分为自己主动处理和让别人处理.

java中的 =RunTimeException= (发生以后程序退出) 以及 =Error= 都不处理,用户主要处理的是 =IOException=.

*** 捕获异常
使用 =try/catch= 可以捕获异常, =try/catch= 代码块中的代码称为保护代码:
- catch 语句包含要捕获异常类型的声明.当保护代码块中发生一个异常时, try后面的catch块就会被检查.
如果发生的异常包含在 catch 块中, 异常会被传递到该 catch 块, 这和传递一个参数到方法是一样的.
#+BEGIN_SRC java
try{
        //程序代码
}catch(ExcetptionName e1){
        //Catch 块
}
#+END_SRC
#+BEGIN_SRC java
import java.io.*
public class ExcepTest{
        public static void main(String[] args){
                try{
                        int a[] = new int[2];
                        System.out.println("Access element three:" + a[3]);
                }catch(ArrayIndexOutOfBoundException e){
                        System.out.println("Exception thrown:" + e);
                }
                System.out.println("Out of the block");
        }
}
#+END_SRC
- 一个 try 代码块后面跟随多个 catch 代码块的情况叫多重捕获.
#+BEGIN_SRC java
try{
        file = new FileInputStream(fileName);
        x = (byte)file.read();
}catch(IOException i){
        i.printStackTrace();
        return -1;
}catch(FileNotDoundException f){
        f.printStackTrace();
        return -1;
}
#+END_SRC
*** throws/throw 
如果一个方法没有捕获一个检查性异常,那么该方法必须使用 throws 关键字来声明, 或者使用 throw 关键字抛出异常.
#+BEGIN_SRC java
import java.io.*;
public class className{
                        /// 抛出一个 RemoteException 异常
        public void deposit(double amount) throws RemoteException
                {
                        throw new RemoteException();
                }
}

public class className{
        ///抛出多个异常
        public void withdraw(double amount) throws RemoteException, InsufficientFundsException
                {
                        
                }
}

#+END_SRC
*** finally
用种类创建在 try 代码块后面执行的代码块.无论是否发生异常, *finally代码块中的代码总会被执行*.
#+BEGIN_SRC java
try{
        
}catch(...){
        
}catch(...){
        
}finally{
        
}
#+END_SRC

*** 自定义异常
自定义异常需要注意:
- 所有异常都必须是 Throwable 子类
- 如果希望写一个检查性异常类, 则需要继承 Exception 类
- 如果希望写一个运行时异常, 需要继承 RuntimeException 类.
#+BEGIN_SRC java
class MyException extends Exception{
}
#+END_SRC
#+BEGIN_SRC java
/// InsufficientFundsException.java
import java.io.*;
public class InsufficientFundsException extends Exception
{
        private double amount;
        public InsufficientFundsException(double amount)
                {
                        this.amount = amount;
                }
        public double getAmount()
                {
                        return amount;
                }
}
///CheckingAccount.java
import java.io.*;
public class CheckingAccount
{
        private double balance;
        private int number;
        public CheckingAccount(int number){
                this.number = number;
        }
        public void deposit(double amount)
                {
                        balance += amount;
                }
        public void withdraw(double amount) throws InsufficientFundsException
                {
                        if(amount <= balance)
                        {
                                balance -= amount;
                        }
                        else
                        {
                                double needs = amount - balance;
                                throw new InsufficientFundsException(needs);
                        }
                }
        public double getBalance()
                {
                        return balance;
                }
        public int getNumber()
                {
                        return number;
                }
}
///BankDemo.java
public class BankDemo{
        public static void main(String[] args){
                CheckingAccount c = new CheckingAccount(101);
                System.out.println("Depositing $500.");
                c.deposit(500);
                try{
                        System.out.println("\nWithdrawing $100.");
                        c.withdraw(100);
                        System.out.println("\nWithdrawing $600.");
                        c.withdraw(600);
                }catch(InsufficientFundsException e)
                {
                        System.out.println("Sorry. but you are short $" + e.getAmount());
                        e.printStackTrace();
                }
        }
}
#+END_SRC

*** 通用异常
在java中定义了两种类型的异常和错误.
- JVM(javav虚拟机)异常: 由JVM抛出的异常或错误.
- 程序级异常:由程序或者API程序抛出的异常.
** 继承
- 子类拥有父类 *非private* 的属性和方法
- 子类可以拥有自己的属性和方法
- 子类可以用自己的方式实现父类的方法
- Java的继承是单继承, 这是 java 区别于 C++ 继承的一个特性
- 所有的类都是继承于 =java.lang.Object=,当一个类没有继承关键字时, 则默认继承 object
*** 继承的基本格式
#+BEGIN_SRC java
class ParentClass{
        
}
class ChildClass extends ParentClass{
        
}
#+END_SRC
*** 继承关键字
- extends: 单一继承,一个子类只能拥有一个父类
- implements: 类可以同时继承多个接口
#+BEGIN_SRC java
public interface A{
        public void eat();
        public void sleep();
}
public interface B{
        public void show();
}
public class C implements A,B{
}
#+END_SRC
*** super, this
- super: 实现子类对父类成员的访问,用来引用当前对象的父类.
- this: 指向自己的引用
#+BEGIN_SRC java
class Animal{
        void eat(){
                System.out.println("animal: eat");
        }
}
class Dog extends Animal{
        void eat(){
                System.out.println("dog: eat");
        }
        void eatTest(){
                this.eat();
                super.eat();
        }
}
public class Test{
        public static void main(String[] args){
                Animal a = new Animal();
                a.eat();
                Dog d = new Dog();
                d.eatTest();
        }
}
#+END_SRC
*** final 
- final 关键字声明的类可以把类定义为不能继承的, 即最终类. 或者修饰方法时, 该方法不能被子类重写.
- 当类被修饰为 final 时, 其方法会自动被修饰为 final, *但是实例变量不是fianl*.

*** 构造
- 子类不能继承父类的构造函数, *但是父类的构造函数带有参数时, 子类必须在自己的构造函数中显式的使用 super 关键字调用父类的构造函数以初始化变量*.
- 如果父类是无参数的构造函数, 则子类不需要显式调用父类的构造函数, 此时在创建对象时, 系统会自动调用父类的无参构造函数.
#+BEGIN_SRC java
class SuperClass{
        private int n;
        SuperClass(){
                System.out.println("SuperClass()");
        }
        SuperClass(int n){
                System.out.println("SuperClass(int n)");
                this.n = n;
        }
}
class SubClass extends SuperClass{
        private int n;
        SubClass(){
                super(300);
                System.out.println("SubClass()");
        }
        public SubClass(int n){
                System.out.println("SubClass(int n):" +n);
                this.n = n;
        }
}
public class TestSuperSub{
        public static void main(String[] args){
                SubClass sc = new SubClass();
                SubClass sc2 = new SubClass(200);
        }
}
#+END_SRC

** 重写与重载
*** 重写(Override)
重写的规则如下:
- 返回类型以及参数列表必须完全与被重写的方法相同
- 访问权限不能比父类中被重写的方法和访问权限更低.
- 父类的成员方法只能被它的子类重写
- 声明为 final 的方法不能被重写
- 声明为 static 的方法不能被重写, 但是能够被再次声明
- 子类和父类在同一个包重, 那么子类可以重写父类所有方法, 除了声明为 private 和 final 的方法.
- 子类和父类不在同一个包中, 那么子类只能够重写父类的声明为 public 和 protected 的非final方法
- 重写的方法能够抛出任何非强制异常, 无论被重写的方法是否抛出异常.但是重写的方法不能抛出新的强制性异常, 或者比被重写方法声明的更广泛的强制性异常, 反之则可以.
- 构造方法不能被重写.
- 如果不能继承一个方法, 则不能重写这个方法.
#+BEGIN_SRC java
class Animal{
        public void move(){
                System.out.println("Animals can move");
        }
}
class Dog extends Animal{
        public void move(){
                System.out.println("Dogs can run");
        }
}
public class TestDog{
        public static void main(String[] args){
                Animal a = new Animal();
                Animal b = new Dog();

                a.move();
                b.move();
        }
}
#+END_SRC

子类重写父类的方法时，可以在方法前面加上 @Override 标识，让编译器来检查接口是否正确.
#+BEGIN_SRC java
//假设父类有方法 public String toString(){}方法
//子类如下写
@Override
public String toString()
{
        //这种方式正确
}
//
@Override
public String tostring()
{
        //编译器会报错
}
#+END_SRC
*** 重载(Overload)
重载的规则如下:
- 重载的方法必须改变参数列表
- 重载的方法可以改变返回类型
- 重载的方法可以改变访问修饰符
- 重载的方法可以声明新的或更广的检查异常
- 方法能够载同一个类重或者载一个子类中被重载
- 无法以返回值类型作为重载函数的区分标准
#+BEGIN_SRC java
public class OverLoading{
        public int test(){
                System.out.println("test1");
                return 1;
        }
        public void test(int a){
                System.out.println("test2");
        }
        public String test(int a, String s){
                System.out.println("test3");
                return "returntest3";
        }
        public String test(String s, int a){
                System.out.println("test4");
                return "returntest4";
        }
        public static void main(String[] args){
                Overloading o = new OverLoading();
                System.out.println(o.test());
                o.test(1);
                System.out.println(o.test(1, "test3"));
                System.out.println(o.test("test4", 1));
        }
}
#+END_SRC
** 多态
多态存在的三个必要条件:
- 继承
- 重写
- 父类引用指向子类对象,当使用多态方式调用方法时, 首先检查父类中是否有该方法,没有则编译错误.有则调用子类同名的方法.
#+BEGIN_SRC java
public class Test{
        public static void main(String[] args){
                show(new Cat());
                show(new Dog());

                Animal a = new Cat();
                a.eat();
                Cat c = (Cat)a;
                c.work();
        }
        public static void show(Animal a){
                a.eat();

                if(a instanceof Cat){
                        Cat c = (Cat)a;
                        c.work();
                }else if(a instanceof Dog){
                        Dog c = (Dog)a;
                        c.work();
                }
        }
}
abstract class Animal{
        abstract void eat();
}
class Cat extends Animal{
        public void eat(){
                System.out.println("吃鱼");
        }
        public void work(){
                System.out.println("抓老鼠");
        }
}
class Dog extends Animal{
        public void eat(){
                System.out.println("吃骨头");
        }
        public void work(){
                System.out.println("看家");
        }
}
#+END_SRC

** 抽象类
如果一个类中没有包含足够的信息来描述一个具体的对象, 这样的类就是抽象类.

抽象类除了不能实例化对象之外, 类的其他功能依然存在, 成员变量,方法,访问方式和普通的类一样.

由于抽象类不能实例化对象, 所以抽象类必须被继承才能被使用.一个类只能继承一个抽象类, 而一个类却可以实现多个接口.

使用 =abstract class= 来定义抽象类:
#+BEGIN_SRC java
public abstract class Employee{
        private String name;
        private String address;
        private int number;
        public Employee(String name, String address, int number){
                System.out.println("Constructing an Employee");
                this.name = name;
                this.address = address;
                this.number = number;
        }
        public double computePay(){
                System.out.println("Inside Employee computePay");
                return 0.0;
        }
        public void mailCheck(){
                System.out.println("Mailing a check to " + this.name + " " + this.address);
        }
        public String toString(){
                return name + " " + address + " " + number;
        }
        public String getName(){
                return name;
        }
        public String getAddress(){
                return address;
        }
        public void setAddress(String newAddress){
                address = newAddress;
        }
        public int getNumber(){
                return number;
        }
}
#+END_SRC
*** 抽象方法
抽象方法的具体实现由它的子类确定, 使用 =abstract= 来声明抽象方法, *只包含方法名, 没有方法体*.
- 如果一个类包含抽象方法, 那么该类必须是抽象类.
- 任何子类必须重写父类的抽象方法, 或者声明自身为抽象类.
- 构造方法和类方法(static 修饰)不能声明为抽象方法.
#+BEGIN_SRC java
public abstract class Employee{
        private String name;
        private String address;
        private int number;
        public abstract double computePay();
}
#+END_SRC
** 接口
接口并不是类, 编写接口的方式和类很相似,但类描述对象的属性和方法,接口则包含类要实现的方法.

接口与类的相似点:
- 一个接口可以有多个方法
- 接口文件保存在 .java 结尾的文件中, 文件名和接口名一致
- 接口的字节码文件保存在 .class 结尾的文件中
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中

接口与类的区别:
- 接口不能用于实例化对象
- 接口没有构造方法
- 接口中所有的方法必须是抽象方法
- 接口不能包含成员变了,除了 static 和　final 变量
- 接口不是被类继承了, 而是要被类实现
- 接口支持多继承

接口特性
- 接口中每个方法也是隐式抽象的，接口中的方法会被隐式的指定为　public abstract,所以不用使用 =abstract= 关键字。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为　public static final.
- 接口中的方法式不能在接口中实现的，只能由实现接口的类来实现接口中的方法

抽象类和接口的区别
- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是　public static final 
- 接口中不能含有静态代码块以及静态方法（用　static 修饰的方法），而抽象类是可以有静态代码块和静态方法
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口
*** 接口的声明和实现
声明接口使用以下格式:
#+BEGIN_SRC java
[可见度] interface 接口名称　[extends 其他类名]{
}

public interface NameOfInterface{
        
}
#+END_SRC

实现接口使用以下格式:
#+BEGIN_SRC java
... implements 接口名称[,其他接口1,其他接口2,.....,]
#+END_SRC

重写接口中声明的方法时， 需要注意以下规则：
- 类在实现接口方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常
- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型
- 如果实现接口的类是抽象类，那么就没有必要实现该接口的方法。

在实现接口时，需要注意一些规则：
- 一个类可以同时实现多个接口
- 一个类只能继承一个类， *但是能实现多个接口*.
- 一个接口能继承另一个接口，这和类之间的继承比较相似

#+BEGIN_SRC java
interface Animal{
        public void eat();
        public void travel();
}

public class MammalInt implements Animal{
        public void eat(){
                System.out.println("Mammal eats");
        }
        public void travel(){
                System.out.println("Mammal travels");
        }
        public int noOfLegs(){
                return 0;
        }

        public static void main(String args[]){
                MammalInt m = new MammalInt();
                m.eat();
                m.travel();
        }
}
#+END_SRC

*** 接口的继承
一个接口能继承另一个或多个接口，同样使用 =extends= 关键字
#+BEGIN_SRC java
public interafce Hockey extends Sports,Event
#+END_SRC
#+BEGIN_SRC java
public interafce Sports{
        public void setHomeTeam(String name);
        public void setVisitingTeam(String name);
}
public interface FootBall extends Sports{
        public void homeTeamScored(int points);
        public void visitingTeamScored(int points);
        public void endOfQuarter(int quarter);
}
public interface Hockey extends Sports{
        public void homeGoalScored();
        public void visitingGoalScored();
        public void endOfPeriod(int period);
        public voiid overtimePeriod(int ot);
}
#+END_SRC
*** 标记接口
标记接口是没有任何方法和属性的接口， 它仅仅表明它的类属于一个特定的类型，共其他代码来测试允许做一些事情。
标识接口的作用：给某个对象打一个标记，使对象拥有某个或某些特权。

标记接口的目的：
- 建立一个公共的父接口。使用一个标记接口来建立一组接口的父接口。
- 向一个类添加数据类型
*** 什么时候使用抽象类和接口
- 如果你拥有一些方法并且想让它们中的一些有默认实现，那就使用抽象类
- 如果你想实现多重继承，那就必须使用接口
- 如果基本功能在不断改变，那就需要使用抽象类。 *如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。*
** 包和权限
使用包机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等。

包的作用：
- 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用
- 包同文件夹一样，也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同包中的类名字是可以相同的。当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。
- 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类

规定:
- 如果其他的源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。
- 包声明应该在源文件的第一行， *每个源文件只能有一个包声明* ，这个文件中的每个类型都应用于它。
- 如果一个源文件中没有使用包声明，那么其中的类、函数、枚举、注释等将被放在一个无名包中。
- 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。

语法：
#+BEGIN_SRC java
package pkg1[.pkg2[.pkg3...]];

/**
 ,* @note : 最终文件 Something.java 的保存位置位于 net/java/util/Something.java 
 ,*/
package net.java.util;

public class Something{
        ...
}
#+END_SRC

*** 创建包
#+BEGIN_SRC java
/// Animal.java
package animals;

interface Animal{
        public void eat();
        public void travel();
}
#+END_SRC
#+BEGIN_SRC java
package animals;

public class MammalInt implements Animal{
        public void eat(){
                System.out.println("Mammal eats");
        }
        public void travel(){
                System.out.println("Mammal travels");
        }
        public int noOfLegs(){
                return 0;
        }
        public static void main(String [] args){
                MammalInt m = new MammaInt();

                m.eat();
                m.travel();
        }
}
#+END_SRC
#+BEGIN_SRC java
//将编译的结果打包到 a.b.c.d 文件夹下
//编译时使用命令 javac -d . Pack.java
//执行时使用命令 java a.c.c.d.Pack
//在其他文件中导入类使用 import a.b.c.d.Pack
//其他文件使用类就使用 a.b.c.d.Pack.main(), 若没有重名的类, 也可以直接使用 Pack.main();
import a.b.c.d.Pack;

public class Pack{
        public static void main(String args[])
                {
                        System.out.println("Hello World!");
                }
}
#+END_SRC
*** 使用 import 
使用 =import= 导入包。
#+BEGIN_SRC java
import package1[.package2..].(classname|*);
#+END_SRC
*** package 目录结构
类放在包中会有两种主要的结果：
- 包名成为类名的一部分
- 包名必须与相应的字节码所在的目录结构相吻合。


*** 内部类
内部类就是在类内部再定义一个类,内部类可以访问外部类的私有变量及属性.
#+BEGIN_SRC java
class Outer{
        private int a = 10;
        class Inner{
                public void printInfo()
                        {
                                System.out.println("a = " +a);
                        }
        }
}

public class InnerDemo{
        public static void main(String args[])
                {
                        Outer o  = new Outer();
                        Outer.Inner i = o.new Inner();
                        i.printInfo();
                }
}
#+END_SRC
** 数据结构
java 中的主要数据结构有以下几种：
- 枚举(Enumeration)
- 位集合(BitSet)
- 向量(Vector)
- 栈(Stack)
- 字典(Dictionary)
- 哈希表(Hashtable)
- 属性(Properties)
** 集合框架
** 泛型
** 序列化
** 文档注释
** JNI
*** 实现简单的访问
- 参考链接 [[www.cnblogs.com/Seiyagoo/p/3496834.html][Seiyagoo]]
java通过统一的接口(JNI, Java native interface)来访问 c/c++ 库函数, 按照以下步骤实现通信。
**** 编写并编译 java 文件
#+BEGIN_SRC java
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class J2C
{ 
      ///静态代码块，只执行一次
     static 
     { 
          try{ 
               // 此处即为本地方法所在链接库名，也就是libj2c.so
               System.loadLibrary("j2c");
          } catch(UnsatisfiedLinkError e) 
          { 
               System.err.println( "Cannot load J2C library:\n " + 
               e.toString() ); 
          } 
     }

     //声明的本地方法,也就是c中方法
     public static native int write2proc(int pid);

     public static void main(String[] args){

          //获取本进程(即主线程)的pid
          final RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
          final String info = runtime.getName();
          final int index = info.indexOf("@");


          if (index != -1) {
               final int pid = Integer.parseInt(info.substring(0, index));
               System.out.println(info);
               System.out.println(pid);

               write2proc(pid);
          }


          try{
               Thread.sleep(8000);
          } catch(InterruptedException e){
               e.printStackTrace();
          }
     }
}
#+END_SRC
#+begin_example
javac J2C.java
javah J2C
#+end_example
以上命令会编译并生成头文件J2C.h，C文件中定义的函数要与这个文件中的函数一致。
#+BEGIN_SRC java
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class J2C */

#ifndef _Included_J2C
#define _Included_J2C
#ifdef __cplusplus
extern "C" {
#endif
/*
 ,* Class: J2C
 ,* Method: write2proc
 ,* Signature: (I)I
 ,*/
JNIEXPORT jint JNICALL Java_J2C_write2proc
     (JNIEnv *, jclass, jint);

#ifdef __cplusplus
}
#endif
#endif
#+END_SRC

**** 编写并编译 c 文件
#+BEGIN_SRC c
#include <stdio.h>

#include "J2C.h"

JNIEXPORT int JNICALL Java_J2C_write2proc(JNIEnv * env, jclass arg, jint pid) 
{

     printf("current pid is %d\n", pid);

     return 0;

}
#+END_SRC
- J2C.h 文件中包含了头文件 jni.h，这个就需要告诉jcc此头文件的位置
#+begin_example
 gcc -I/usr/lib/jvm/java-8-openjdk-amd64/include -I/usr/lib/jvm/java-8-openjdk-amd64/include/linux -fPIC -c J2C.c
#+end_example
**** 生成共享库
生成的共享库要与 J2C.java 文件中的名字对应
#+begin_example
 gcc -shared -Wl,-soname,libj2c.so.1 -o libj2c.so.1.0 J2C.o
 cp libj2c.so.1.0 libj2c.so
 export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}
#+end_example
**** 运行
#+begin_example
 java J2C
#+end_example
*** 实现多个函数访问
JNI具有字段描述符，用于表述C代码中的函数接口形式,并且可以灵活命名C中的函数名（保证接口对应）。

可以在C中以一个结构体的方式打包当前所有函数以实现批量的访问。

接口类型对应关系：
| java 类型 | JNI 中的类型 | c/c++ 中对应的类型 | 表示符号 |
|-----------+--------------+--------------------+----------|
| boolean   | jboolean     | unsigned char      | Z        |
| byte      | jbyte        | signed char        | B        |
| char      | jchar        | unsigned short     | C        |
| short     | jshort       | short              | S        |
| int       | jint         | int                | I        |
| long      | jlong        | long               | J        |
| float     | jfloat       | float              | F        |
| double    | jdouble      | double             | D        |
| void      | void         | void               | V        | 

描述一个函数是 =(参数列表)返回类型= 的形式。
示例：
- java 中的函数为 =int m1()= ,此函数无参数，返回值为 int型，对应的描述为 =()I=  
- java 中函数为 =double m2(long l, char c)=, 参数为 long,char, 返回为 double，对应描述为 =(JC)D=

