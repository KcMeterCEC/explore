#+TITLE: zynq hardware -> ttc
#+DATE:  <2018-04-28 Sat> 
#+TAGS: zynq
#+LAYOUT: post 
#+CATEGORIES: processor, zynq, hardware
#+NAME: <processor_zynq_hd_ttc.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

由于xilinx官方提供的TTC的linux驱动并没有提供PWM功能，所以此部分需要自己来实现，当然就要来了解一下硬件咯。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 概览
TTC(Triple Timer Counters, 三重定时器) 具备如下特性：
1. 每个TTC包含3个独立的定时器， *PS端具有两个TTC* ， 所以一共具有6个独立的定时器
2. TTC1可以被配置为安全访问模式或非安全访问模式
3. 每个定时器具有16位分频器和16位的计数器
4. 每个TTC的 *定时器0可以选择* 定时器的输入源和输出源
  - CPU总线时钟
  - PL端时钟
  - 外部输入时钟(通过MIO输入)
5. 每个定时器都有其中断
  - 周期定时触发
  - 计数器匹配触发
  - 计数器溢出触发
  - 定时器事件溢出触发
6. 每个定时器都具有波形输出功能

*需要注意的是：* 定时器0默认的输入时钟和输出方式都是EMIO

[[./ttc_block_diagram.jpg]]

** 分配与计数
- 分频器的值可设范围为 2 ~ 65536
- 计数器可以配置向上计数或向下计数
** 操作模式
- 周期模式：定时器根据设置值周期性的循环计数，都计数值到0时可以产生一次中断，都计数器与匹配值相等时也可以产生一次中断
- 溢出模式：定时器在 0 ~ 0xffff 中循环增加或减小， 当计数值到0或与匹配值相等时都可以产生一次中断
* 使用流程
** 产生PWM
*** 基本流程
当仅仅使用TTC产生PWM而不使用中断时，以下几部分寄存器需要使用：
1. 时钟配置寄存器：配置分频比，时钟输入源
2. 计数器配置寄存器：配置计数模式，方向，匹配值，波形输出
3. 计数值设置寄存器：设置计数值，对比值等

启动流程：
1. 选择输入时钟，设置分频值(slcr.MIO_MUX_SEL 和 Clock Control 寄存器)
2. 如果要设置周期模式则使用 Interval 寄存器
3. 如果要设置匹配值则使用 Match 寄存器
4. 使能波形输出，使能匹配，设置计数方向，设置模式，最后启动计数器(TTC Counter Control 寄存器)

停止流程：
1. 回读 Counter Control 寄存器的值
2. 仅仅修改 DIS 位为1 
3. 回写 Counter Control 寄存器

重新启动流程:
1. 回读 Counter Control 寄存器的值
2. 仅仅修改 RST 位为1
3. 回写 Counter Control 寄存器
*** 编写寄存器以启动PWM
- 基地址寄存器
  + ttc0 : 0xf8001000(以此ttc的clock1为例, 选用内部时钟)
  + ttc1 : 0xf8002000
- 设置对应的 MIO_PIN 寄存器，比如 MIO_PIN_18作为PWM输出
  + 最终为:  MIO_PIN_18 | (6 << 5) = 0x16c1
- 设置 Clock Control ： 选用内部时钟，分频比为 4，并使能分频器
  + 最终为： (0 << 6) | (0 << 5) | (1 << 1) | ( 1 << 0) = 0x03
- 设置 Interval : 设置计数值上限为 65535
  + 最终为： 0xffff
- 设置 Match : 设置占空比为 50%，也就是 32768
  + 最终为：0x8000
- 设置Counter Control : 正极性输出，使能波形输出，使能定时器
  + 最终为：( 1 << 6) | (0 << 5) | ( 0 << 0) = 0x40
  




