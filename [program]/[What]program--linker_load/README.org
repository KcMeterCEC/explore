* 程序员的自我休养 --> 链接装载与库
这是 <<程序员的自我休养 --> 链接装载与库>> 的读书笔记.
*** 目录
[[%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86][预备知识]]
- [[北桥芯片与南桥芯片]]
- [[SMP与多核]]



** <<预备知识>>

*** 北桥芯片与南桥芯片
北桥芯片 (North bridge), 是为了使 CPU,RAM,显卡这种高速设备通信而实现的.而相应的南桥芯片(South bridge)就是为了协调各个低速设备而实现的,最终南桥与北桥通信,实现协调.

*** SMP与多核
对称多处理器 (SMP, Symmetrical Multi-Processing),是说一个计算机主板上具有多个 CPU,可以完全并行的处理任务.比如很多服务器上就具有多个强悍的 CPU.

多核 (MP, Multi-core Processor),是说在一个 CPU 上集成了多个核心, 核心之间共享缓存,比如 zynq 集成了一个双核心的 cortexA9.

*** 接口
一个复杂的软件系统,都是由各个软件层一层层组合起来的.也正是由于分层的特性,使得各个层内部的改变并不会引起其他层的改变.越往上层就越具有移植性.
与硬件息息相关的就是操作系统的,作为操作系统程序员需要考虑驱动的编写和系统底层的移植.

*** 挖掘计算机硬件的潜力
**** 操作系统调度
操作系统接管了所有的硬件资源,并且本身运行在一个受硬件保护的级别.所有的应用程序都以进程 (Process) 的方式运行在比操作系统权限更低的级别,每个进程都有自己独立的地址空间.
使得进程之间的地址空间相互隔离.CPU 由操作系统统一进行分配,每个进程根据优先级的高低都有机会得到 CPU,但是如果运行时间超出了一定的时间,每个进程根据进程优先级的高低都有机会
得到 CPU, 但是如果运行时间超出了一定的时间,操作系统会暂停改进程,将 CPU 资源分配给其他等待运行的进程.这种 CPU 的分配方式即所谓的抢占式 (Preemptive),操作系统可以强制剥夺
CPU 资源并且分配给它认为目前最需要的进程.

**** 设备驱动
操作系统提供了一些统一的接口,设备驱动满足这些接口便可以被系统调用.

**** 内存管理 
通过 MMU(Memory Management Unit) 的 *虚拟内存* *分页* *权限* 等特性,使得用户代码运行空间相对独立并且安全而且效率更高,同时也可以运行更多的进程.

**** 线程
     多个线程通过共享进程空间,以及各个线程的优先级方式使 CPU 的利用率更高.     
** 编译和链接

*** 预处理
在gcc中,内部调用的预处理器叫做 cpp ,将 c 文件预处理为 .i 文件, 将 cpp 文件预处理为.ii文件.
gcc 使用 -E 选项来指明只需要进行预处理. =gcc -E hello.c -o hello.i=,也可以使用 cpp 来完成.
预处理过程主要处理规则如下:
- 将所有的 "#define" 删除,并且展开所有的宏定义,使用的是直接替换原则
- 处理所有的条件预编译指令,比如 "#if" "#elif" "#else" "#endif"等等
- 处理 "#include" 预编译指令,将被包含的文件在此处展开,如果被包含文件也包含了其他文件,那么层层展开
- 删除所有的注释
- 添加行号和文件名标识,比如 =#2 "hello.c" 2= ,以便于编译时产生调试用的行号信息,以及用于编译时产生编译错误或警告时能够显示行号
- 保留所有的 =#pragma= 编译指令,用于后面的编译过程.
通过以上规则,可以知道其中的一个调试方法是查看预编译后的文件,可以避免调一些干扰,也可以看到真实的宏定义结果.

*** 编译
编译的过程就是把预处理完的文件进行一系列的词法分析,语法分析,语义分析以及优化后生成相应的汇编代码文件.
在gcc中,将从预编译到编译使用命令 =gcc -S hello.i -o hello.s=,也可以使用 cc1 来完成预处理和编译.

编译过程一般可以分为6步:扫描,语法分析,语义分析,源代码优化,代码生成,目标代码优化.
**** 扫描器(词法分析)
源代码程序首先被输入到 *扫描器(Scanner)*,扫描器的任务很简单,只是简单的进行词法分析,运用一种类似于 *有限状态机(Finite State Machine)* 可以很轻松的将源代码的 *非空格字符* 序列分割成一系列的 *记号(Token)*.说简单点就是把各个小字符提取成一张表.这一过程和[[https:github.com/KcMeterCEC/tools/tree/master/shell%5D%5D][简易命令行shell]] 的扫描命令内容过程很相似.
词法分析产生的记号一般可以分为如下几类:关键字,标识符,字面量(数字,字符串等)和特殊符号(加号,等号等)在识别记号的同时,扫描器也完成库其他工作,比如将标识符存放到符号表,将数字,字符串常量存放到文字表等.

扫描器的程序工具叫做 *lex*.

**** 语法分析(Grammar Parser)
对扫描器产生的记号进行语法分析,从而 *产生语法树(Syntax Tree)* ,整个分析过程采用了 *上下文无关语法(Context-free Grammar)的分析手段.

语法分析器的工具叫做 yacc(Yet Another Compiler Compiler).

**** 语义分析(Semantic Analyzer)
语法分析仅仅完成了对表达式的语法层面分析,但是它并不了解这个语句是否真正有意义.编译器所能分析的是 *静态语义(Static Semantic)*,是指在编译时可以确定的语义,与之对应的是 *动态语义(Dynaic Semantic)* 就是只有在运行期才能确定的语义.经过语义分析后,语法树的表达式都被标识了类型,如果有些类型需要作隐式转换,语义分析程序会在语法树中插入相应的转换节点.

**** 中间语言生成
*源代码优化器(Source Code Optimizer)* 在源代码级别进行优化,但是由于直接在语法树上做优化比较困难,所以源代码优化器往往将整个语法树转换成 *中间代码(Intermediate Code)*, 它是语法树的顺序表示.中间代码有很多种形式,在不同的编译器中有着不同的形式,比较常见的有: *三地址码(Three-address Code)* 和 *P-代码(P-Code)*.
中间代码使得编译器可以被分为前端和后端,编译器前端负责产生机器无关的中间代码,后端将中间代码转换成目标机器码.这样对于一些跨平台的编译器而言,它们可以针对不同的平台使用同一个前端和不同的后端.

**** 目标代码生成与优化
源代码级优化器产生中间代码标志着下面的过程都属于后端,后端主要包括 *代码生成器(Code Generator)* 和 *目标代码优化器(Target Code Optimizer)*.
代码生成器将中间代码转换为目标机器码,这个过程十分依赖于目标机器.

*** 汇编
将编译后的汇编代码转变为二进制文件,因为汇编都有对应的二进制值,所以汇编器的汇编过程相对于编译器来讲比较简单.
在gcc中,讲汇编文件到二进制文件使用命令 =gcc -c hello.s -o hello.o / gcc -c hello.c -o hello.o=,也可以使用 as  来完成.
经过预编译,编译,汇编之后的 .o 文件被称为 *目标文件*.
*** 链接
    将目标文件与库文件以一定的规则, *确定的地址* 结合,才能形成最后的可执行文件.
** 目标文件解析
*** 目标文件格式
PC 平台流行的 *可执行文件格式(Executable)* 主要是 Windows 下的 PE(Portable Executable) 和 Linux 的 ELF(Executable Linkable Format),
它们都是 COFF(Common file format)格式的变种.目标文件和可执行文件的格式是一样的, *动态链接库(DLL, Dynamic Linking Library)和静态链接库(Static Linking Library)* 
都按照可执行文件格式存储.

| ELF文件类型                      | 说明                                                                                                                                                                                                                          | 实例                        |
|----------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------|
| 可重定位文件(Relocatable File)   | 这类文件包含了代码和数据,可以被用来链接成可执行文件或共享目标文件,静态链接库也可以归为这一类                                                                                                                                  | Linux 的 .o Windows 的 .obj |
| 可执行文件(Executable File)      | 这类文件包含了可以直接执行的程序,它的代表就是ELF可执行文件,一般都没有扩展名                                                                                                                                                   | /bin/bash windows 的 .exe   |
| 共享目标文件(Shared Object File) | 这种文件包含库代码和数据,可以在以下两种情况下使用.一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接,产生新的目标文件.第二种是动态连接器可以将几个这种共享目标文件与可执行文件结合,作为进程影响的一部分来运行 | Linux 的 .so Windows 的 DLL |
| 核心转储文件(Core Dump File)     | 当进程意外中止时,系统可以将进程的地址空间的内容以及终止时的一些其他信息转储到核心转储文件                                                                                                                             | Linux 下的 core dump          |
|                                  |                                                                                                                                                                                                                               |                             |

在linux下可以使用 =file= 命令查看相应的文件格式.

**** ELF 文件结构描述
| ELF Header           |
| .text                |
| .data                |
| .bss                 |
| other sections       |
| section header table |
| String Tables        |
| Symbol Tables        |

***** ELF Header
可以使用命令 =readelf -h hello.o=来查看 ELF 文件.
ELF 的文件头中定义了 *ELF 魔数*, *文件机器字节长度*, *数据存储方式*, *版本*, *运行平台*, *ABI版本*, *ELF重定位类型*, *硬件平台*, *硬件平台版本*, *入口地址*, *程序头入口和长度*, *段表位置*, *长度及段的数量*.

ELF 文件头结构及相关常数被定义在 =/usr/include/elf.h= 文件里, 结构体 =Elf32_Ehdr 或 Elf64_Ehdr= 对应着 readelf 文件输出.

****** 魔数
elf 文件头魔数最开始的 4个字节是所有 ELF 文件都必须相同的表示码,分别为 =0x7f,0x45,0x4c,0x46=,第一个字节对应 ASCII 字符里面的 DEL 控制符, 后面3字节刚好是 ELF 这3个字母的 ASCII 码.这 4 个字节又被称为 ELF 文件的魔数.接下来的字节分别用来标识 ELF 的文件类型, 字节序, 主版本号,后面的9个字节ELF标准没有定义,一般填0,有些平台会使用这9个字节作为扩展标志.
****** e_type 文件类型
linux 通过此值来判断 ELF 的真正文件类型,而不是通过文件的扩展名.
| 常量    | 值 | 含义                        |
| ET_REL  |  1 | 可重定位文件,一般为 .o 文件 |
| ET_EXEC |  2 | 可执行文件                  |
| ET_DYN  |  3 | 共享目标文件,一般为 .so 文件           |

****** e_machine
表示当前 ELF 文件在哪种机器平台下使用 

***** Section Header Table
段表是 ELF 文件中除了文件头以外最重要的结构,它描述了 ELF 的各个段的信息.ELF 文件的段结构就是由段表决定的,编译器,链接器和装载器都是依靠段表来定位和访问各个段的属性.
段表在 ELF 文件中的位置由 ELF 文件头的 =e_shoff= 成员决定.
使用命令 =readelf -S hello.o= 来显示完整的段表.

段表的结构比较简单,它是一个以 =Elf32_Shdr= 结构体为元素的数组,数组元素的个数等于段的个数,每个 =Elf32_Shdr= 结构对应一个段.
所以 =Elf32_Shdr= 又被称为段描述符.ELF 段表的这个数组第一个元素是无效的段描述符,它的类型为"NULL",除此之外每个段描述符都对应一个段. 

*sh_type*(段的类型)
段的名字不能真正的表示段的类型,对于编译器和链接器来说,主要决定段的属性的是段的类型(sh_type)和段的标志位(sh_flags),段的类型相关常量以 SHT_ 开头.
| 常量         | 值 | 含义                              |
|--------------+----+-----------------------------------|
| SHT_NULL     |  0 | 无效段                            |
| SHT_PROGBITS |  1 | 程序段. 代码段,数据段都是这种类型 |
| SHT_SYMTAB   |  2 | 符号表                            |
| SHT_STRTAB   |  3 | 字符串表                          |
| SHT_RELA     |  4 | 重定位表                          |
| SHT_HASH     |  5 | 符号表的哈希表                    |
| SHT_DYNMAIC  |  6 | 动态链接信息                      |
| SHT_NOTE     |  7 | 提示信息                          |
| SHT_NOTEBITS |  8 | 表示该段在文件中没有内容,比如 .bss 段 |
| SHT_REL      |  9 | 重定位信息                            |
| SHT_SHLIB    | 10 | 保留                                  |
| SHT_DNYSYM   | 11 | 动态链接符号表                               |

*sh_flag*(段的标志位)
段的标志位表示该段在进程虚拟地址空间中的属性,比如是否可写,可执行,相关常量以 SHF_ 开头.
| 常量          | 值 | 含义                                               |
|---------------+----+----------------------------------------------------|
| SHF_WRITE     |  1 | 可写                                               |
| SHF_ALLOC     |  2 | 在进程空间中需要分配空间.比如代码段,数据段,.bss 段 |
| SHF_EXECINSTR |  4 | 可执行,一般指代码段                                         |

*sh_link , sh_info*(段的链接信息)

| sh_type               | sh_link                              |                            sh_info |
|-----------------------+--------------------------------------+------------------------------------|
| SHT_DYNAMIC           | 该段所使用的字符串表在段表中的下标   |                                  0 |
| SHT_HASH              | 该段所使用的符号表在段表中的下标     |                                  0 |
| SH_REL , SH_RELA      | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段在段表中的下标 |
| SHT_SYMTAB,SHT_DYNSYM | 操作系统相关的                       |                     操作系统相关的 |
| other                 | SHN_UNDEF                            | 0                                  |
***** Relocation Table(重定位表)
链接器在处理目标文件时,须要对目标文件中某些部位进行重定位,即代码段和数据段中那些绝对地址的引用位置.这些重定位的信息都记录在 ELF 文件的重定位表里面,
对于每个需要重定位的代码段或数据段,都会有一个相应的重定位表.比如 ".rela.text" 就是针对 ".text" 段的重定位表.

***** String Table(字符串表)
代码中的字符串是被集中放到一个表,然后使用字符串在表中的偏移在引用字符串.通过这种方法,在ELF 文件中引用字符串只需给出数字下标即可,不用考虑字符串长度的问题.
一般字符串表在 ELF 文件中也以段的形式保存,常见的段名为 ".strtab" 或 ".shstrtab ".这两个字符串表分别为 *字符串表(String Table)* 和 *段表字符串表(Section Header String Table)*.
字符串表用来保存普通的字符串,段表字符串用来保存段表中用到的字符串.
*** 目标文件分段
目标文件将编译得到的信息以 *节(Section)* 的形式存储,有时候也叫 *段(Segment)*.
程序源代码编译后的机器指令经常被放在 *代码段(Code Section)* 里,代码段常见的名字有".code"或".text".
全局变量和局部静态变量数据放在 *数据段(Data Section)*, 数据段的一般名字都叫".data".
未初始化的全局变量和局部静态变量一般放在一个叫 ".bss"段里,程序运行的时候它们是要占内存空间的,并且可执行文件必须记录所有未初始化的全局和局部静态变量的大小总和.所以 .bss段只是为初始化的全局变量和局部静态变量预留位置而已,它并没有内容,所以它在文件中也不占据空间.

**** 分段的好处
1. 数据和指令分别被映射到两个虚存区域,数据区被设置为可读写,指令区被设置为只读,可以防止程序指令被有意或无意的改写.
2. 由于 CPU 的缓存体系,分段有利于提高程序的局部性,提高缓存的命中率.
3. 当系统中运行着多个该程序的副本时,可以共享代码段而区分数据段,节约内存.
*** 解析目标文件的步骤
1. 将编辑好的 c 文件,使用命令 =gcc -c hello.c=,让编译器只编译不链接,从而生成 .o 文件.
2. 使用 binutils 的工具 objdump 来查看目标文件的内部结构,使用命令 =objdump -h hello.o=.
从输出中可以看出各个段的大小以及位置,以 ELF 文件头为开头然后依次增长.在 linux 下还可以使用 =size hello.o= 来输出代码段,数据段和BSS段的长度.
3. 使用命令 =objdump -s -d hello.o= 来反汇编, 查看实际指令使用地址以及大小.
4. 使用命令 =objdump -x -s -d hello.o= 可以显示包括符号表在内的更加完整的信息.

| 常用的段名         | 说明                                                                                                                                                                   |
| ---------+-------- |                                                                                                                                                                        |
| .text              | 代码段                                                                                                                                                                 |
| .data              | 保存已经初始化了的 *非零* 全局变量和局部静态变量                                                                                                                       |
| .rodata            | 只读数据段,比如字符串常量等等,单独设立 .rodata 段有很多好处,不光在语义上支持了 C++ 的 const关键字,而且操作系统在加载的时候可以将.rodata 段属性映射成只读,保证程序安全. |
| .bss               | 存放未初始化的全局变量和局部静态变量, .bss 段保存数量的值,而不是具体值                                                                                                 |
| .rodata1           | 只读数据与.rodata一样,比如字符串常量,全局 const变量等.                                                                                                                 |
| .comment           | 存放的是编译器版本信息,比如字符串 "GCC:(GUN) 4.2.0"                                                                                                                    |
| .debug             | 调试信息                                                                                                                                                               |
| .dynamic           | 动态链接信息                                                                                                                                                           |
| .hash              | 符号哈希表                                                                                                                                                             |
| .line              | 调试时的行号表,即源代码行号与编译后指令的对应表                                                                                                                        |
| .note              | 额外的编译器信息,比如版本号等等                                                                                                                                        |
| .strtab            | 字符串表,用于存储 ELF 文件中用到的各种字符串                                                                                                                           |
| .symtab            | 符号表                                                                                                                                                                 |
| .plt .got          | 动态链接的跳转表和全局入口表                                                                                                                                           |
| .init .fini        | 程序初始化与终结代码段                                                                                                                                                            |

这些段的名字都是由 "." 作为前缀,表示这些表的名字是系统保留的,应用程序也可以使用一些非系统保留的名字作为段名.比如可以在 ELF 文件中插入一个 music 的段,里面存放了一首 MP3 音乐,当 ELF 文件运行起来以后可以读取这个段播放这首 MP3.但是应用程序自定义的段名不能使用 . 作为前缀,否则容易跟系统保留段名冲突.一个 ELF 文件也可以拥有几个相同段名的段.
*** 自定义段
GCC 提供了一个扩展机制,可以指定变量所处的段:
#+BEGIN_SRC c
/*
  在全局变量或函数前加上 __attribute__((section("name")))
  就可以把相应的变量或函数放到以 "name" 作为段名的段中
 ,*/
__attribute__((section("FOO")))  int global = 42;

__attribute__((section("BAR"))) void foo()
{
}
#+END_SRC
*** 链接的接口--符号
在链接中,目标文件之间的相互拼合实际上是目标文件之间对地址的引用, 即对函数和变量的地址的引用. 在链接中, 我们将函数和变量统称为 *符号(Symbol)*,函数名和变量名就是 *符号名(Symbol Name)*.
