#+TITLE: [What]数据结构与算法 -> 时间与空间复杂度分析
#+DATE:  <2018-09-26 三> 
#+TAGS: 数据结构与算法
#+LAYOUT: post 
#+CATEGORIES: program,数据结构与算法
#+NAME: <program_DS_complexity.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

课程：王争 --> <数据结构与算法之美>

之前看的[[http://kcmetercec.top/categories/book/%25E7%25AE%2597%25E6%25B3%2595%25E5%259B%25BE%25E8%25A7%25A3-%25E5%2585%25A5%25E9%2597%25A8/][图解算法]]也仅仅是对数据结构与算法有了一个大体上的感性认识，现在就需要来深入理解相关概念了。

最为基础和重要的就是分析代码的复杂度，只有能清楚其复杂度才能知道如何根据当前环境而做优化。

[[./ds_complication.jpg]]

#+BEGIN_HTML
<!--more-->
#+END_HTML
* 什么是数据结构与算法
- 数据结构：数据在内存中的组织结构
- 算法：操作内存中数据的方式

这个就和面向对象中的概念一样，使用对象中的方法来对对象中的数据进行操作。

数据结构与算法是不能孤立存在的，不同的数据结构对应不同的算法。

最终目的都是为了得到相同效果的同时，算法执行时间尽量短且代码占用空间尽量的小。
* 时间复杂度的分析方法
在[[http://kcmetercec.top/2018/02/27/book_%25E7%25AE%2597%25E6%25B3%2595%25E5%259B%25BE%25E8%25A7%25A3_chapter1/#orgfbeef3a][入门大O表示法]]中提到过此表示法的要点：
1. 取当前代码的 **最大运行次数**
2. 表示随着输入增加其运行时间的 **趋势(函数曲线)**

基于以上两个要点，就可以得出代码的时间复杂度的分析方法：
1. 分析代码执行逻辑
2. 假设每行 **无函数调用** 的代码执行时间为一个机器周期
3. 依次算出每行代码的执行次数
4. 如果有函数调用则应该将被调用函数的执行次数表示出来
5. 去掉其中的低阶、常量、系数，得出最大的次数即为时间复杂度
#+BEGIN_EXAMPLE
  T(n) = O(f(n))
#+END_EXAMPLE
比如计算以下函数 =f= 的时间复杂度:
#+BEGIN_SRC c
  int val = 0;

  void f(int n)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < n; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100);

    return 0;
  }
#+END_SRC
- 依次计算执行次数为: 2 + 2*n + 2*n^2
- 去掉常量、低阶、系数
- 最终得出其时间复杂度: T(n) = O(n^2)
** 常见的大O运行时间表示
之前也提到过了，现在搬运过来并做扩展。

下面依次按照时间复杂度由低到高排列("log n "都代表"log_{2}n")：
*** O(1): 常量阶
不管数据量多大(代码有多少行)，获得需求数据的时间都相同，也就是说代码中不存在循环、递归这类语句。

比如下面这段代码:
#+BEGIN_SRC c
  int i = 0;
  int a = 8;
#+END_SRC
*** O(log n):对数阶
比如下面这段代码:
#+BEGIN_SRC c
  int i = 1;
  while(i < n)
  {
    i = i * 2;
  }
#+END_SRC
在循环体中的 =i= 的取值都是2的次方: 2^1 2^2 2^3 ..... 2^x = n

取最大次数并转换为对数表示就是: x = log_{2}n

如果将循环体中的2改为3，那么其对数表示就为: x = log_{3}n
- 又可以再次等价于: x = log_{3}2 * log_{2}n , 去掉系数后就还是 log_{2}n

所以这种时间复杂度都统一表示为 =Olog(n)=

比如二分查找法就是这种时间复杂度。
*** O(n) : 线性阶
比如下面这段代码:
#+BEGIN_SRC c
  int f(int n)
  {
    int sum = 0;
    for(int i = 0; i < n; i++)
      {
        sum += i;
      }

    return sum;
  }
#+END_SRC
比如从包含n个元素的列表中，以遍历的方式查找元素，就是这种时间复杂度。

当代码段中有两个位置数据规模时:
#+BEGIN_SRC c
  int f(int n, int m)
  {
    int sum1 = 0;
    for(int i = 0; i < n; i++)
      {
        sum1 += i;
      }

    int sum2 = 0;
    for(int i = 0; i < m; i++)
      {
        sum2 += i;
      }

    return sum1 + sum2;
  }
#+END_SRC
这种情况下由于不知道n和m哪个更大，所以应该表示为 O(n + m)
*** O(n * log n): 线性对数阶
比如下面这段代码:
#+BEGIN_SRC c
  int i = 1;
  int j = 1;

  for(;j < n;j++)
    {
      while(i < n)
        {
          i = i * 2;
        }
    }
#+END_SRC
比如快速排序算法就是这种时间复杂度。
*** O(n^2): 平方阶、O(n^3)立方阶、O(n^k)k次方阶
如下这段代码：
#+BEGIN_SRC c
  int val = 0;

  void f(int n)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < n; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100);

    return 0;
  }
#+END_SRC
当两个循环的数据规模都未知时:
#+BEGIN_SRC c
  int val = 0;

  void f(int n, int m)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < m; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100, 200);

    return 0;
  }
#+END_SRC
应该表示为 O(n * m)
*** O(2^n):指数阶
*** O(n!):阶乘阶
比如旅行商问题。
** 最好、最坏情况时间复杂度
最好情况时间复杂度: 在最理想情况下该段代码执行的时间复杂度

最坏情况时间复杂度: 在最槽糕的情况下该段代码执行的时间复杂度

如下面这段代码:
#+BEGIN_SRC c
  static int find_element(int *buf, int size ,int x)
  {
    int pos = -1;
    for(int i = 0; i < size; i++)
      {
        if(buf[i] == x)
          {
            pos = i;
            break;
          }
      }

    return pos;
  }
#+END_SRC
此函数用于从数组 =buf= 中找到值为 =x= 的元素的索引位置。
- 最好情况时间复杂度：当第一个元素正好匹配 =x= ，那么循环只执行一次，最终整个函数的时间复杂度为 O(1)
- 最坏情况时间复杂度：当数组中没有元素或最后一个元素匹配匹配 =x= ，那么最终整个函数的时间复杂度为 O(n)
** 平均情况时间复杂度
平均情况时间复杂度：平均情况下该段代码的时间复杂度

基于上面的代码：元素匹配对于每个索引的概率都是 1/2n ， 最后还有不匹配数组的概率为 1/2。
将每个元素的概率乘以其执行的次数之和便是平均情况时间复杂度。

[[./average_complexity.jpg]]

最后去掉系数及常量，最终的平均情况时间复杂度也是 O(n)
** 均摊时间复杂度
均摊时间复杂度是平均情况时间复杂度的一个特殊例子：
#+BEGIN_EXAMPLE
  对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高。
  而且这些操作之间存在前后连贯的时序关系，这个时候我们就可以将这一组操作放在一块分析，看是否能
  将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度
  分析的场合，一般均摊时间复杂度就等于最理想情况下的时间复杂度。
#+END_EXAMPLE
如下面这段代码:
#+BEGIN_SRC c++
  // array 表示一个长度为 n 的数组
  // 代码中的 array.length 就等于 n
  int[] array = new int[n];
  int count = 0;
 
  void insert(int val) {
    //当数组满时，将元素求和放入第一个位置，并将新值写入第二个位置
    if (count == array.length) {
      int sum = 0;
      for (int i = 0; i < array.length; ++i) {
        sum = sum + array[i];
      }
      array[0] = sum;
      count = 1;
    }

    array[count] = val;
    ++count;
  }
#+END_SRC
- 最好情况时间复杂度：当写入的元素个数不到数组长度时，复杂度为O(1)
- 最坏情况时间复杂度：当数组满时，需要遍历n次，复杂度为O(n)
- 平均情况时间复杂度：总共有 n + 1总可能，前n总的执行次数为1，最后一个执行次数为n
[[./amortized_complexity.jpg]]

最终的复杂度也是 O(1)
- 均摊时间复杂度：
  + 此函数在绝大部分情况下时间复杂度都是O(1)，只有小概览下才是O(n)
  + 其执行次数都是多次O(1)然后一次O(n)循环往复
基于以上两个特征，将O(n)平摊给多次的O(1)，最终的复杂度就是O(1)

均摊时间复杂度一般都等于最好情况时间复杂度。

* 空间复杂度分析方法
与前面时间复杂度分析方法一样，只是其关系代表的是 **随着输入增加其占用的存储空间的趋势。**

注意：空间复杂度是指除了原本的数据存储空间外，算法运行还需要的 **额外** 的存储空间!

所以其分析的角度由运行次数转变为内存空间的占用数：
1. 依次算出占用内存的大小
2. 如有函数调用则应该将被调用函数占用内存表示出来
3. 去掉其中的低阶、常量、系数，得出最大的内存占用即为空间复杂度
   
空间复杂度一般有: O(1),O(n),O(n^2)

