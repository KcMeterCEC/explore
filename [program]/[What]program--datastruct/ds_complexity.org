#+TITLE: [What]数据结构与算法 -> 时间与空间复杂度分析
#+DATE:  <2018-09-26 三> 
#+TAGS: 数据结构与算法
#+LAYOUT: post 
#+CATEGORIES: program,数据结构与算法
#+NAME: <program_DS_complexity.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

之前看的[[http://kcmetercec.top/categories/book/%25E7%25AE%2597%25E6%25B3%2595%25E5%259B%25BE%25E8%25A7%25A3-%25E5%2585%25A5%25E9%2597%25A8/][图解算法]]也仅仅是对数据结构与算法有了一个大体上的感性认识，现在就需要来深入理解相关概念了。

最为基础和重要的就是分析代码的复杂度，只有能清楚其复杂度才能知道如何根据当前环境而做优化。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 什么是数据结构与算法
- 数据结构：数据在内存中的组织结构
- 算法：操作内存中数据的方式

这个就和面向对象中的概念一样，使用对象中的方法来对对象中的数据进行操作。

数据结构与算法是不能孤立存在的，不同的数据结构对应不同的算法。

最终目的都是为了得到相同效果的同时，算法执行时间尽量短且代码占用空间尽量的小。
* 时间复杂度的分析方法
在[[http://kcmetercec.top/2018/02/27/book_%25E7%25AE%2597%25E6%25B3%2595%25E5%259B%25BE%25E8%25A7%25A3_chapter1/#orgfbeef3a][入门大O表示法]]中提到过此表示法的要点：
1. 取当前代码的 **最大运行次数**
2. 表示随着输入增加其运行时间的 **趋势(函数曲线)**

基于以上两个要点，就可以得出代码的时间复杂度的分析方法：
1. 假设每行 **无函数调用** 的代码执行时间为一个机器周期
2. 依次算出每行代码的执行次数
3. 如果有函数调用则应该将被调用函数的执行次数表示出来
4. 去掉其中的低阶、常量、系数，得出最大的次数即为时间复杂度
#+BEGIN_EXAMPLE
  T(n) = O(f(n))
#+END_EXAMPLE
比如计算以下函数 =f= 的时间复杂度:
#+BEGIN_SRC c
  int val = 0;

  void f(int n)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < n; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100);

    return 0;
  }
#+END_SRC
- 依次计算执行次数为: 2 + 2*n + 2*n^2
- 去掉常量、低阶、系数
- 最终得出其时间复杂度: T(n) = O(n^2)
** 常见的大O运行时间表示
之前也提到过了，现在搬运过来并做扩展。

下面依次按照时间复杂度由低到高排列("log n "都代表"log_{2}n")：
*** O(1): 常量阶
不管数据量多大(代码有多少行)，获得需求数据的时间都相同，也就是说代码中不存在循环、递归这类语句。

比如下面这段代码:
#+BEGIN_SRC c
  int i = 0;
  int a = 8;
#+END_SRC
*** O(log n):对数阶
比如下面这段代码:
#+BEGIN_SRC c
  int i = 1;
  while(i < n)
  {
    i = i * 2;
  }
#+END_SRC
在循环体中的 =i= 的取值都是2的次方: 2^1 2^2 2^3 ..... 2^x = n

取最大次数并转换为对数表示就是: x = log_{2}n

如果将循环体中的2改为3，那么其对数表示就为: x = log_{3}n
- 又可以再次等价于: x = log_{3}2 * log_{2}n , 去掉系数后就还是 log_{2}n

所以这种时间复杂度都统一表示为 =Olog(n)=

比如二分查找法就是这种时间复杂度。
*** O(n) : 线性阶
比如下面这段代码:
#+BEGIN_SRC c
  int f(int n)
  {
    int sum = 0;
    for(int i = 0; i < n; i++)
      {
        sum += i;
      }

    return sum;
  }
#+END_SRC
比如从包含n个元素的列表中，以遍历的方式查找元素，就是这种时间复杂度。

当代码段中有两个位置数据规模时:
#+BEGIN_SRC c
  int f(int n, int m)
  {
    int sum1 = 0;
    for(int i = 0; i < n; i++)
      {
        sum1 += i;
      }

    int sum2 = 0;
    for(int i = 0; i < m; i++)
      {
        sum2 += i;
      }

    return sum1 + sum2;
  }
#+END_SRC
这种情况下由于不知道n和m哪个更大，所以应该表示为 O(n + m)
*** O(n * log n): 线性对数阶
比如下面这段代码:
#+BEGIN_SRC c
  int i = 1;
  int j = 1;

  for(;j < n;j++)
    {
      while(i < n)
        {
          i = i * 2;
        }
    }
#+END_SRC
比如快速排序算法就是这种时间复杂度。
*** O(n^2): 平方阶、O(n^3)立方阶、O(n^k)k次方阶
如下这段代码：
#+BEGIN_SRC c
  int val = 0;

  void f(int n)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < n; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100);

    return 0;
  }
#+END_SRC
当两个循环的数据规模都未知时:
#+BEGIN_SRC c
  int val = 0;

  void f(int n, int m)
  {
    int i = 0; //1
    int j = 0; //1

    for(;i < m; i++) //n
      {
        val += i; //n
        for(;j < n;j++) //n*n
          {
            val += j; //n*n
          }
      }
  }

  int main(int argc, char **argv)
  {
    f(100, 200);

    return 0;
  }
#+END_SRC
应该表示为 O(n * m)
*** O(2^n):指数阶
*** O(n!):阶乘阶
比如旅行商问题。
* 空间复杂度分析方法
与前面时间复杂度分析方法一样，只是其关系代表的是 **随着输入增加其占用的存储空间的趋势。**

所以其分析的角度由运行次数转变为内存空间的占用数：
1. 依次算出占用内存的大小
2. 如有函数调用则应该将被调用函数占用内存表示出来
3. 去掉其中的低阶、常量、系数，得出最大的内存占用即为空间复杂度
   
空间复杂度一般有: O(1),O(n),O(n^2)

