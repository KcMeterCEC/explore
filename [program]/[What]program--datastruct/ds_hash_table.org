#+TITLE: [What]数据结构与算法 -> 散列表
#+DATE:  <2019-01-23 三> 
#+TAGS: 数据结构与算法
#+LAYOUT: post 
#+CATEGORIES: program,数据结构与算法
#+NAMA: <program_DS_hash_table.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

课程：王争 --> <数据结构与算法之美>

散列表(Hash Table)也叫"哈希表"或"Hash 表",用于快速读写数据的内容。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 概念
数组按照下标进行随机访问的时间复杂度是O(1)，数据的内容则是按照编号存储在数组内的。
每个我们需要使用的元素都有一个键值(Key value)，散列表中的散列函数(Hash function)实现将键值转换为数组对应下标（散列值、哈希值、Hash值）的功能。
得到数组下标后便可以进行读写了。

[[./hash_table_overview.jpg]]

** 散列函数
由上面可以看出最为重要的便是散列函数了，散列函数的设计有以下基本要求：
1. 散列函数计算得到的散列值是一个非负整数
  - 数组的下标必须是非负整数
2. 如果 key1 = = key2 ，那么必须要有 hash(key1) == hash(key2)
3. 如果 key1 ! = key2 ，那么必须要有 hash(key1) != hash(key2)
  - 为了避免散列冲突，需要通过其他途径解决

常用的散列冲突解决方法有以下两种:
*** 开放寻址法(open addressing)
开放寻址法的核心思想是：如果出现了散列冲突，就重新探测一个空闲位置将其插入。

当空闲位置不多时，冲突的概览会大大提高，每次探测的时间就越长。

为了尽可能保证散列表的操作效率，需要保证散列表中有一定比例的空闲槽位，称为 *装载因子(load factor)* ：
#+BEGIN_EXAMPLE
  装载因子 = 已存储的元素个数 / 散列表长度
#+END_EXAMPLE

探测算法有以下几种：
**** 1. 线性探测(Linear Probing)
- 插入: 某个数据警告散列函数得出对应散列值后，如果对应的存储位置已经被占用了，那就从当前位置开始依次往后循环查找，以找到空闲位置写入。
- 查找: 通过散列函数得出键值对应的散列值后，比较数组对应位置的元素与要查找的元素是否相等，如果不等则顺序往后查找，如果遍历到数组中的空闲位置，说明要找的元素不在散列表中。
- 删除: 删除操作是将数组对应位置标记为 =deleted= 而不是直接置空，否则在查找数据的时候会由于此次的空白而无法遍历后面的数据导致查找失败

当数组中存储的数据越来越多时，出现冲突的可能性也会越来越大，在以上的增删改查操作时，最坏的时间复杂度为O(n)。
**** 2. 二次探测(Quadratic probing)
线性探测如果遇到冲突后进行探测的步长为1，而二次探测的步长为原来的二次方:
- 线程探测: hash(key) + 0, hash(key) + 1, hash(key) + 2 .....
- 二次探测: hash(key) + 0, hash(key) + 1, hash(key) + 4 .....
**** 3. 双重散列(Double hashing)
使用多个散列函数来寻找空闲位置: hash1(key), hash2(key), hash3(key)...
*** 链表法(chaining)
