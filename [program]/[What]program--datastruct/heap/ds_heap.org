#+TITLE: [What]数据结构与算法 -> 堆
#+DATE:  <2019-04-08 一> 
#+TAGS: 数据结构与算法
#+LAYOUT: post 
#+CATEGORIES: program,数据结构与算法
#+NAME: <program_DS_heap.org>
#+OPTIONS: ^:nil 
#+OPTIONS: ^:{}

课程：王争 --> <数据结构与算法之美>

认识堆这种树。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* 概念
堆其实是一种特殊的树，当树满足以下两点时，它就是一个堆:
- 完全二叉树
- 每个节点的值都必须大于等于或小于等于其左右子节点的值。
  + 每个节点的值都大于等于其左右子节点的值时，称为 =大顶堆= 
  + 每个节点的值都小于等于其左右子节点的值时，称为 =小顶堆= 

[[./heap_overview.jpg]]

* 操作
在进行节点的插入和删除操作时，必然需要保持堆的特性(堆化)，这就涉及到要移动(交换)原来的节点。

倘若使用链式存储，则在节点移动(交换)时需要通过指针搜寻其父或子节点，操作效率不高。

若使用[[http://kcmetercec.top/2019/02/28/program_DS_binary_tree/#orgef9572e][数组存储]]，则可以通过索引直接获取其父或子节点，操作效率较高。
- 并且完全二叉树可以很好的利用数组存储空间，这真是太妙了！
  
** 插入
插入的节点从数组下标1处开始，在插入节点后需要遍历的与其父节点(i/2)进行比较，当不满足大小关系时则进行交换。
** 删除堆顶元素
删除堆顶元素(下标为1的值) 后，如果从堆顶遍历的与左右节点比较后交换，则 *最终可能会破坏完全二叉树* 。

解决办法是: 删除堆顶元素后，将堆 *最后一个元素(数组中的最后下标元素)* 放入堆顶，然后再进行遍历比较交换。
** 堆化的时间复杂度
一个包含n个节点的完全二叉树，树的高度不会超过 log2(n) ，由于其堆化的过程也是顺着节点路径进行比较，
所以一个节点堆化的时间复杂度也是O(logn)， 那么n个节点的时间复杂度就是 O(nlogn).
** 使用堆对数组的元素进行排序
堆对应于以数组方式存储的完全二叉树，所以它可以对数组中的元素先进行建堆，再进行排序。
*** 建堆
当数组中有n个元素(从索引1开始)，那么对于完全二叉树而言，其 1 ~ n/2 索引处为所有的父节点。
在进行堆化时，从 索引 n/2 至 1 处倒叙的方式进行从上往下的堆化。
- 之所以要倒叙，是因为对于每个元素的堆化都需要其下面的元素已经被堆化好了。
*** 排序
1. 将堆顶的元素和数组最后一个元素交换
2. 将除开最后一个元素的数组进行堆化
3. 重复步骤1，直到剩下一个元素。

