* [What] Zynq --> 构架说明


** 片上存储空间 On-Chip Memory(OCM)

片上 RAM 256KB，ROM 128KB，其中 ROM 仅仅用于 BootROM 。

*** 默认 RAM 地址映射

BootROM 为了保证自己的运行空间，将其中的 64KB 设置到高位内存运行。所以 fsbl 仅有192KB 的RAM 运行空间。

![default Addr](./defaultRamAddr.jpg)

如上图所示，最后一段 RAM 地址位于高段内存中，这导致 RAM 不连续，降低了裸机代码调试可用范围。所以，需要设置其地址连续，将其统一设置为高位或者低位(如果要设置为高位，需呀在 vivado 下打开允许高位访问 "PS-PL_Configuration -> General -> Address_Editor -> Allow_access_to_High_OCM ")。如下图所示：

![new Addr](./newRamAddr.jpg)

设置地址映射的关键寄存器如下：

![ocm map](./ocmMap.jpg)

- 0x10 映射地址 : 0x0000_0000 ~ 0x0003_ffff
- 0x18 映射地址 : 0x0000_0000 ~ 0x0002_ffff  0xffff_0000 ~ 0xffff_ffff
- 0x1f 映射地址 : 0xfffc_0000 ~ 0xffff_ffff

*为什么第 5 位要置一，现在还没搞懂*

除此之外，还需要打开 slcr 的访问权限，Xilinx 在 SDK 下提供了操作函数。

![ocm remap](./funcOcm.jpg)

通过修改 XSLCR_OCM_CFG_RESETVAL ，然后**在执行应用代码前**调用此函数即可，对于通过 JATG 下载的代码，需要[修改配置脚本](https://github.com/KcMeterCEC/explore/blob/master/%5BWhat%5D%E5%9F%BA%E7%A1%80%E7%A1%AC%E4%BB%B6--DDR%E7%9F%A5%E8%AF%86/document.md)。

** 中断、异常、模式

*** 概览

ARM 中具有不同的工作模式, 有些模式又称为异常,而中断是属于异常中的两种.
异常具有异常向量表,而具体的中断也具有中断向量表.
而这三者都是与 ARM 内部的 程序状态寄存器CPSR(Current Program Status Register)有关.
[[./arm_cpsr.jpg]]

**** 工作模式
ARM 体系的 CPU 有以下 7 种工作模式.
- 用户模式 (usr): ARM 处理器正常的程序执行状态
- 快速中断模式 (fiq) : 用于高速数据传输或通道处理.
- 中断模式 (irq): 用于通用的中断处理
- 管理模式 (svc): 操作系统使用的保护模式
- 数据访问终止模式 (abt) : 当数据或指令终止时进入该模式,可以用于虚拟存储及存储保护.
- 系统模式(sys): 运行具有特权的操作系统任务
- 未定义指令中止模式 (und):当未定义指令进入该模式,可用于支持硬件协处理器的软件仿真.

工作模式的切换,是通过 CPSR 来完成的. 可以通过软件来进行模式的切换, 或者发生各类中断或异常时 CPU 自动进入相应的模式. 除用户模式外, 其他 6 种工作模式都属于特权模式.
大多数程序运行于用户模式,进入特权模式时为了处理中断,异常,或者访问被保护的系统资源.

另外, ARM 体系的 CPU 有以下两种工作状态.
- ARM 状态: 此时处理器执行32位的字对齐的 ARM 指令.
- Thumb 状态: 此时处理器执行16位的半字对齐的 Thumb 指令.
CPU 默认上电处于 ARM 状态.

各种模式下对应的寄存器如下图, 其中带灰色三角的表示在对应模式下具有副本寄存器.
[[./arm_modeReg.jpg]]

*注意* : 用户模式和系统模式使用同一个寄存器组.

图中 R0 ~ R15 可以直接访问, 这些寄存器除 R15外都是通用寄存器,即它们即可以用于保存数据也可以用于保存地址.另外, R13 ~ R15稍有特殊.
R13 又被称为栈指针寄存器,通常被用于保存栈指针. R14又被称为程序连接寄存器(subroutine Link Register) 或连接寄存器, 当执行 BL 子程序调用指令时, R14 中得到 R15(程序计数器 PC)的备份.
而当发生中断或异常时, 对应模式下的 R14 中保存 R15返回值.
快速中断模式有 7 个备份寄存器 R8 ~ R14 , 这使得进入快速中断模式执行很大部分程序时,如果 R0 ~ R7没有被改变,那就不需要保存任何寄存器,实现快速切换.
每个模式都具有独有的 R13 , R14 ,这样可以令每个模式拥有自己的栈指针寄存器和连接寄存器.

除 CPSR 外, 除 "用户/系统模式" 外的其他模式具有 程序状态保存寄存器 SPSR(Saved Process Status Registers).当切换进入这些工作模式时, 在 SPSR 中保存前一个工作模式的 CPSR 值,
这样当返回前一个工作模式时,可以将 SPSR 的值恢复到 CPSR中.

**** 异常类型
ARM 处理器支持 7 种异常情况：复位、未定义指令、软件中断、指令预取中止、数据中止、中断请求（IRQ）和快速中断请求（FIQ）。

| 异常中断名称                        | 含义                                                                                                                                                                                  |
|-------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 复位（RESET）                       | 当处理器的复位引脚有效时，系统产生复位异常中断，程序跳转到复位异常中断程序处执行。复位异常中断通常用在下面两种情况：1、系统加电时和系统复位时 2、跳转到复位中断向量处执行，称为软复位 |
| 数据访问中止（Data Abort）          | 如果数据访问指令的目标地址不存在，或者该地址不允许当前指令访问，处理器产生数据访问中止异常中断                                                                                        |
| 快速中断请求（FIQ）                 | 当处理器的外部快速中断请求引脚有效，而且 CPSR 寄存器的 F 控制位被清除时，处理器产生外部中断请求异常中断                                                                               |
| 外部中断请求（IRQ）                 | 当处理器的外部中断请求引脚有效，而且 CPSR 寄存器的 I 控制位被清除时，处理器产生外部中断请求异常中断。系统中各外设通常通过该异常中断请求处理器服务                                     |
| 预取指令中止（Prefech Abort）       | 如果处理器预取指令的地址不存在，或者该地址不允许当前指令访问，当该被预取的指令执行时，处理器产生指令预取中止异常中断                                                                  |
| 软件中断（software interrupt SWI）  | 这是一个用户定义的中断指令，可用于用户模式下的程序调用特权操作指令。在实时操作系统中，可以通过该机制实现系统功能调用                                                                  |
| 未定义指令（undefined instruction） | 当 ARM 处理器或者是系统中的写处理器认为当前指令未定义时，产生未定义的指令异常中断，可以通过该异常中断机制仿真浮点向量运算                                                             |

**** 异常类型与工作模式的对比
除开二者所共有的 FIQ , IRQ, ABT(数据终止和指令终止), undefined instruction, 还剩下 复位,软件中断 和 用户模式 , 管理模式, 系统模式.其中用户模式属于正常工作模式,系统模式需要用户手动切换.
复位和软件中断都属于是管理模式.软件中断一般由应用程序自己调用产生,用于用于程序向系统申请访问硬件资源.
**** 工作流程

***** 进入异常
综上所述,当一个异常发生时,将由CPU *强制* 切换进入相应的工作模式,这时 CPU 将 *自动* 完成如下的事情:
1. 在异常工作模式的连接寄存器 R14 中保存前一个工作模式的 *下一条指令*, 也就是返回异常后的下一条指令地址.对于 ARM 状态,这个值是当前 PC 值加 4 或者加 8.(因为 CPU 的流水线而决定的, 也就是在译码和执行的时间, PC 值也在增加)
2. 将 CPSR 的值复制到异常模式的 SPSR.
3. 将 CPSR 的工作模式位设置位当前异常对应的工作模式, 并且禁止所有 IRQ 中断, 当进入 FIQ 快速中断模式时禁止 FIQ 中断..
4. 令 PC 值等于这个异常模式在异常向量表中的地址, 也就是跳转到异常向量表中执行相应指令.

除此之外, *在进入异常后* 还需要软件来 *主动* 完成的事有:
1. 保存当前共用寄存器的值(包括 lr), 到当前模式的栈内存中
2. 进入异常处理函数,进行相应的处理

***** 退出异常
从异常工作模式退出回到之前的工作模式时, 需要软件 *主动* 来完成如下事情:
1. 将栈里保存的值读回给共享寄存器
2. 将连接寄存器的值减去一个适当的值后, 赋值给 PC 寄存器.
3. 将 SPSR 的值赋值给 CPSR

整体流程如下图所示:
[[./arm_isr.jpg]]

**** 异常向量表
在 ARM 体系中通常在存储地址的低端固化了一个32字节的硬件异常向量表，用来指定各异常中断及处理程序的对应关系。
当异常中断发生时，程序计数器 PC 所指的位置对于各种不同的异常中断是不同的，同样，返回地址对于各种不同的异常中断也是不同的。例外的是，复位异常中断处理程序是不需要返回， *因为整个应用系统就是从复位异常中断处理程序处开始执行的* 。

中断向量表指定了各异常中断及处理程序的对应关系，它通常放在存储地址的低端。在 ARM 体系中，异常中断向量表的大小为32字节。其中每个异常中断占据4字节大小，保留了4个字节空间。也就是说，正好有7个中断处理程序地址。

每个异常中断对应的中断向量表的4个字节的空间存放了一个跳转指令或者一个向 PC 寄存器中赋值的数据访问指令。通过这两种指令，程序将跳转到相应的异常中断处理程序处执行。

当几个异常中断同时发生时，就必须按照一定的次序来处理这些异常中断。在 ARM 中通过给各异常中断赋予一定的优先级来实现这种处理次序。当然，有些异常中断是不可能同时发生的，如指令预取中止异常中断和软中断（SWI）异常中断是由同一条指令的执行触发的，
是不可能同时发生的。处理器执行某个特定的异常中断的过程，称为处理器处于特定的中断模式。

| 中断向量地址 | 异常中断类型    | 异常中断模式    | 优先级（6 最低） |
|--------------+-----------------+-----------------+------------------|
|         0x00 | 复位          | 管理模式（SVC） |                1 |
|         0x04 | 未定义指令 | Undef           |                6 |
|         0x08 | 软件中断（SWI） | 管理模式（SVC） |                6 |
|         0x0c | 指令预取中止 | 中止模式    |                5 |
|         0x10 | 数据访问中止 | 中止模式    |                2 |
|         0x14 | 保留          | 未使用       |        未使用 |
|         0x18 | IRQ             | IRQ模式       |                4 |
|         0x1c | FIQ             | FIQ模式       |                3 |

中断向量表可以设置为高地址还是低地址， 在 zynq 中通过设置CP15来实现。

***** 中断处理过程

ARM 处理器响应中断的时候，总是从固定的地址（一般是指中断向量表）开始，而在高级语言环境下开发中断服务程序时，无法控制固定地址开始的跳转流程。
为了使得上层应用程序与硬件中断跳转联系起来，需要编写一段中间的服务程序来进行连接。这样的服务程序常被称为中断解析程序。

每个异常中断对应一个4字节的空间，正好放置一条跳转指令或者向 PC 寄存器赋值的数据访问指令。理论上可以通过这两种指令直接使得程序跳转到对应的中断处理程序中去。但实际上由于函数地址值为未知和其他一些问题，并不这么做。

发生异常后，中断源请求中断，PC 自动跳转到中断向量表中固定地址执行。中断向量表中存放一条跳转指令，跳转到用户自定义地址（解析程序）继续执行。在解析程序中，将会和异常服务程序连接起来。
对于 IRQ 又会有一个中断向量表,对于请求的各种不同的中断.

一般在硬件启动后,会有汇编代码来提前设置好各种模式的栈。

[[./interrupt_IRQ.jpg]]
### 结构

![interrupt diagram](./interrupt_diagram.jpg)

由上图可知中断体系具有如下特点：

1. 每个 CPU 具有自己的私有外设中断 Private Peripheral Interrupt(PPI), 具有5个中断源，包括全局定时器、私有看门狗、私有定时器、PL端的 FIQ/IRQ
2. CPU 共用软件中断生成器 Software Generated Interrupt(SGI), **每个都** 具有16个中断源
3. CPU 共用共享中断 Shared Peripheral Interrupt(SPI),一共具有60个中断源

这些中断都由通用中断控制器（Generic Interrupt Controller,GIC）来实现管理。

![interrupt GIC](./interrupt_gic.jpg)

### 私有中断

| 名字        | PPI#      | 中断 ID   | 类型      | 描述    |
| :----:      | :-----:   | :------: | :------: | :------: |
| 保留      | ---- | 26：16|---|保留|
|全局定时器| 0 | 27 | 上升沿 | 全局定时器|
| nFIQ | 1 | 28 |  低电平（在 PS-PL 接口，**活动高**） | 来自PL的中断信号|
| CPU 私有定时器| 2 | 29 | 上升沿 | 来自  CPU 定时器的中断 |
| AWDT{0, 1} | 3 | 30| 上升沿 | 用于每个 CPU 的私有看门狗定时器|
| nIRQ | 4 | 31 | 低电平（在 PS-PL 接口，**活动高**）|来自PL的中断信号|

### 软件中断

| 名字 | SGI# | 中断 ID | 类型 |
| :----:      | :-----:   | :------: | :------: | :------: |
| 软件 0 | 0 | 0 | 上升沿 |
| 软件 1 | 1 | 1 | 上升沿 |
|  . |  . | . | . |
| 软件 15 | 15 | 15 | 上升沿 |

### 共享外设中断

![interrupt SPI1](./interrupt_spi1.jpg)
![interrupt SPI2](./interrupt_spi2.jpg)

## SD/SDIO 控制器

zynq 具有 **两个独立的** sdio 控制器，可以兼容 sdio 设备，**但不支持 SPI 模式**。 **最多支持4根数据线** ，对于 SD 卡而言，支持 1 数据线和 4 数据线操作。 **控制线也可以扩展到 EMIO** 。兼容SD协议 **SD Host Controller Specificaton Version 2.0 Part A2**，以及 **MMC3.31** 标准,并且具有 SDMA（单次 DMA 传输），AMDA1（最大 4KB DMA 传输），ADMA2（无限 DMA传输）模式。支持 SDHS 和 SDHC 卡。

同样支持 eMMC 设备，**但是并不全部支持**，xilinx官方提供了 [已经经过验证的支持设备](https://www.xilinx.com/support/answers/65463.html)。

### 参数

- 每个控制器具有两个 512 字节的 FIFO
- 最大时钟 50MHZ （25MB/sec）
- 支持 CRC7 和 CRC16 校验

### SDIO 控制器框图

![Block Diagram](./sdio_blockDiagram.jpg)

![System Viewpoint](./sdio_viewpoint.jpg)

SDIO0 和 SDIO1 分别对应中断号 56，79，用于表示传输完成。也可以通过状态寄存器来循环检验传输完成标志位。

控制器使用两个 512 字节的 FIFO 在读或者写时，用于乒乓传输。因为FIFO都是以块来传输的，所以**不会出现FIFO没有被填满的状态**。当 FIFO 的数据没有被完全读取时，控制器会停止时钟传输，这样也**避免了数据丢失的发生**。当不能从设备读取数据时，会发出读取等待事件，**这将会停止时钟**。

当进行写数据流时，发送 WRITE\_DAT\_UNTIL\_STOP(CMD20) 命令，接着写数据，直到 STOP\_TRANSMISSION 事件。

当进行读数据流时，发送 READ\_DAT\_UNTIL\_STOP(CMD11) 命令，接着读数据，直到 STOP\_TRANSMISSION 事件。

在与高速卡通信时，数据的输出发生在时钟的上升沿。在与全速卡通信时，数据的输出发生在时钟的下降沿。

### SDIO 编程模式

#### 传输模式

- 单次传输，在传输之前，指定要传输的数据块。然后传输完成后自动停止。
- 多次传输，在传输之前，指定要传输的数据块。然后传输完成后自动停止或继续多次传输。
- 无限传输，在传输之前，不用指定传输的块数量，对于 SD 卡，使用 CMD12 停止传输，对于 SDIO 设备，使用 CMD52 停止传输。

#### 传输流程

![without DMA](./sdio_withoutDMA.jpg)

1. 设置块大小
2. 设置传输块数量
3. 设置要执行的命令到 argument 寄存器
4. 设置传输模式
5. 写入要发出的命令到 command 寄存器
6. 等待命令完成中断，并清除标志位
7. 判断设备响应
8. 等待数据缓存可用中断
9. 每次循环的且交替的从 FIFO 中读或写数据，每读或写一次 FIFO 都需要确认另外一个 FIFO 操作完成标志。
10. 如果是单次或者多次传输，等待传输中断标志，并清除标志位。如果是无限传输模式，则发送停止传输命令。

![with DMA](./sdio_withDMA.jpg)

1. 设置 DMA 传输缓存的起始地址
2. 设置块大小
3. 设置块数量
4. 设置要执行的命令到 argument 寄存器
5. 设置传输模式
6. 写入要发出的命令到 command 寄存器
7. 等待命令完成中断，并清除标志位
8. 判断设备响应
9. 接下来便是 DMA 自动完成数据搬移操作，无需 CPU 干预
10. 等待传输完成标志，并清除标志位

![use AMDA](./sdio_useAMDA.jpg)

在 使用 DMA 步骤的基础上， AMDA 需要先设置一个描述符表。同时需要将此表的地址给予 System Address register.

#### 停止传输

可以发送同步或者异步停止传输命令，异步传输可以在任意时刻发出，单块传输完成后自动停止。而同步传输需要在单块传输完成后发出。
![synchronous Abort](./sdio_syncAbort.jpg)

### 硬件连接

![controller device](./sdio_connect.jpg)

![controller wp](./sdio_wp.jpg)
** I2C 控制器
zynq 的 PS 端具有两个 I2C 控制器, 支持主从模式, 最大速度可以达到 400Kb/s. 可以设置 7位或者 10位从机地址. 
在主机模式下, 还可以配置为 *监视模式* ,此模式会持续发送信息给从机, 查看从机是否有 ACK 返回. 如果 HOLD 位被设置,
I2C 接口的 SCL 线会被拉低,来支持慢速处理模式.当从机把 SCL 模式拉低的时间过长时, 可以触发超时 (TO)中断.
*** 特征
- 支持16字节 FIFO
- 支持扩展地址,HOLD 模式, TO 模式
- 从机监测模式
- 可编程中断

*** 功能说明
[[./I2C_blockDiagram.jpg]]
[[./I2C_functionDiagram.jpg]]

**** 主机模式
***** 主机写
为了完成主机写, 需要遵从如下步骤:
1. 设置数据速度,以及从机地址模式
2. 在控制寄存器中, 置位 MS, ACKEN, CLR_FIFO 位, 并且清零 RW 位.
3. 如果需要 HOLD 模式,则设置 HOLD位. 否则就向数据寄存器写第一个字节.
4. 向地址寄存器写从机地址, 到这一步就初始化好了 I2C 的发送.
5. 向数据寄存器写入剩下要发送的字节.

当所有的数据都发送成功后, 中断状态寄存器的 COMP 位会被置位. *每当只剩下两个字节在 FIFO中时*, 就会产生一次数据中断.

如果 HOLD 位没有被设置, 那么控制器就会发送一个停止信号以结束传输. 如果 HOLD 位被设置了, 此时 I2C 的 SCL 线就会被拉低. 
此时 COMP 位被置位, 并且 TXDV 位被清零. 在这种情况下, 主机可以进行以下3种处理:
1. 主动清除 HOLD 位, 这会导致 I2C 产生 STOP 信号.
2. 继续向 I2C 总线写数据, I2C 控制器会继续进行通信.
在发送数据期间, 如果从机返回了 NACK 信号, 传输会自动停止, 并且 NACK 位会被置位. 同时, 发送寄存器会指明还有多少剩余字节待发送.
除非最后未发送的字节是 NACK, 否则 TXDV 位会被置位. 这种情况下, 主机必须主动清除 CLR_FIFO 位来清除缓存.

一但 SCL 拉低的时间过长, 则超时溢出中断就会产生, 并且主机可以读出未发送的字节数.
***** 主机读
为了完成读操作, 需要遵从如下步骤:
1. 设置数据速度和从机地址模式
2. 在控制寄存器中, 置位 MS, ACKEN, CLR_FIFO 位, 以及 RW 位.
3. 如果需要 HOLD 模式, 则需要设置 HOLD 位.
4. 向发送寄存器写入需要读取的字节数
5. 写从机地址, 这样就初始化好了 I2C 发送

当接收到一定数据后, 主机会被通知:
1. 当 FIFO 还差一个或完全被填满时, DATA  位会被置位
2. 当FIFO少于两个字节时, COMP 位被置位, 表示接收完成.

在以上两种情况下, RXDV 会被置位.

当接收完需要的字节后, I2C从机接口会自动发出 NACK 信号, 随后会发送 STOP信号.当设置了 HOLD 位时, SCL 信号会被拉低.
在接收数据的任意时刻, 如果接收到了 NACK 信号, 发送便被中止, NACK 位被置位, 已经接收到的字节可以在发送寄存器中读出.

一但 SCL 拉低的时间过长, 则超时溢出中断就会产生, 并且主机可以读出未发送的字节数.

***** 从机监测模式
要使用此模式, 需要设置 :
1. 置位 MS 和 SLVMON 位, 并且清除 RW 位. 
2. 初始化从机监测间隔寄存器.

当主机设置好了从机地址后, 就会主动尝试发送一次地址. 如果从机返回 NACK, 那么主机会没间隔一段时间发送地址. 
主机可以清除 SLVMON 位来停止监测. 当从机返回 ACK以后, 主机会发送一个停止信号, 并且产生 SLV_RDY 中断.



**** I2C 速度
- 在主机模式下, 设置的时钟代表 SCL 时钟.

时钟设置的公式为: 
=I2C_SCL_Clock = CPU_1x_Clock / ((22 * (divisor_a +1) x (divisor_b +1)))=
常用设置如下所示:
[[./I2C_clk.jpg]]
