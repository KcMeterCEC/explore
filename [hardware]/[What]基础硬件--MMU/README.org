#+TITLE: [What] MMU 基本原理
#+DATE: <2018-03-26 Mon> 
#+TAGS: hardware
#+LAYOUT: post
#+CATEGORIES: hardware, basic
#+NAME: <hardware_basic_mmu.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

参考： =嵌入式Linux应用开发完全手册=

对于内存管理知识而言，MMU基本原理是这类知识的基础，需要掌握。
#+BEGIN_HTML
<!--more-->
#+END_HTML
* MMU的作用
内存管理单元(Memory Management Unit)简称MMU，负责将虚拟地址映射到物理地址，并具有内存访问权限检查。

它具有如下好处：
- 让应用程序可以分段加载，这样可以让多个程序（程序之和大于内存）并发地在内存中运行
  + 仅将要运行的部分装入内存，其他部分用到的时候再载入。
  + 当内存不够用时，将暂时不用的部分再重新调出到硬盘
- 应用程序不用关心实际物理内存，相互虚拟地址互不干扰
  + 每个应用程序都可以在逻辑上认为自己独占内存
- 应用程序之间的地址隔离，不能越权访问，很好的保护了程序空间

而对于这些功能的满足都是基于硬件来实现的。
* 地址转换概念
** 相关概念
- 虚拟地址空间： 在使用了MMU之后，应用程序逻辑上可以使用的内存不与实际的物理内存大小相关。
  + 比如在32位的CPU中，逻辑上可以使用 0 ~ 0XFFFFFFFF 的内存空间，这个空间就是 =虚拟地址空间= 
  + 虚拟地址空间对应的地址就是 =虚拟地址(VA, Virtual Address)=
- 物理地址空间：硬件上实实在在存在的内存大小就是物理地址空间
  + 物理地址空间对应的地址就是 =物理地址(PA, Physical Address)=
- 变换后的虚拟地址(MVA, Modified Virtual Address): 在虚拟地址向物理地址转换中间的地址
** 地址转换概念
虽然虚拟地址大于物理地址，但程序总是要在实实在在的物理地址上运行的。于是将虚拟地址空间和物理地址空间划分为
*同样大小* 小空间（也叫段或页），这样虚拟和物理之间建立映射关系。但是由于虚拟地址空间大于物理地址空间，那么
虚拟地址空间分得的页多于物理地址空间，所以就会出现：
- 几个虚拟地址空间映射页到同一个物理地址空间页
  + 多个进程使用内存的内容一致
  + 多个进程分时使用相同的物理内存，物理内存对于不同进程进行置换
- 一些虚拟地址空间页没有映射到物理地址空间页上
  + 当这些虚拟地址空间被访问时，MMU会觉察并通知CPU进行重映射到物理页
** 相互之间的视角
1. CPU能看到的是虚拟地址(VA)
2. cache 和 MMU 看到的是转换后的虚拟地址(MVA)
3. 实际设备看到的是物理地址(PA),VA和VMA对其都不可见
** 为什么需要MVA？
当两个进程所用的虚拟地址空间有重叠时，在切换进程时为了把重叠的VA映射到不同的PA上，就需要重建页表、使无效caches和TLBS等，导致效率低下。

VA到MVA的转换逻辑（硬件自动完成）：
#+begin_example
if(VA < 32M) then
      MVA = VA | (PID << 25) //PID 通过读取CP15的C13获得
else
      MVA = VA
#+end_example
有了这个逻辑，当两个进程的VA重叠时，由于PID不同所以其MVA不会重叠，这样就不用重建页表，提高系统运行效率。
* 地址转换过程
** 转换概览
虚拟地址到物理地址转换的办法：
- 用确定的数学公式进行转换
- 用表格存储虚拟地址对应的物理地址(ARM使用此种方式)
  + 一个条目(Entry)存储了一段虚拟地址对应的物理地址及其访问权限，或下一级页表的地址
  + 许多条目组成了页表(Page table)，页表可能会有多级

ARM CPU 具体转换流程：
1. 根据给定的虚拟地址找到一级页表中的条目
2. 如果此条目是段描述符，则返回物理地址，转换结束
3. 如果此条目是二级页表描述符，继续利用虚拟地址在二级页表中找到下一个条目
4. 如果第二个条目是页描述符，则返回物理地址，转换结束
5. 其他情况出错
[[./mmu_translate.jpg]]

在32位CPU中，虚拟地址空间达到4GB，一级页表使用4096个描述符来分段，每个描述符对应1MB的虚拟空间。
也就是说，一级页表占用 MVA[31:20]地址范围来对应每一个描述符。
- 当使用段描述符时，对应的MVA[19:0]位就是对应物理地址。
- 当使用多级页表的情况下，MVA[19:0]又会从中分配出一段以代表二级页表的偏移。
#+begin_example
也就是说在寻找物理地址的过程中，都是通过一个页表基地址再加上MVA中取出一段作为偏移来层层索引到最终地址的。
#+end_example
** 一级描述符的内容
每个描述符占用32位，分别描述了描述符类型，描述符地址，对应的内存权限等。

一级描述符低两位代表了描述符的类型。
*** 段(Section)描述符
- MVA通过其[31:20]位加上页表基地址首先找到其对应的段描述符，一共有4096个段描述符
- 段描述符其[31:20]为段的基地址，其索引到物理内存以1M为分段的起始地址。 
- 其剩余的[19:0]位对应的就是物理地址在1M空间的偏移，对应MVA[19:0]位(4096*1MB=4GB)。
[[./mmu_section.jpg]]

*** 粗页表(Coarse page table)描述符
- MVA通过其[31:20]位加上页表基地址首先找到其对应的粗页表描述符，一共有4096个粗页表
- 粗页表[31:10]为粗页表基地址，与MVA的[19:12]组合，对应索引到二级页表的基地址
- 每二级页表条目为256个，每个条目就可以表示4KB的物理地址空间,对应MVA[11:0](4096*256*4KB=4GB)
*** 细页表(Fine page table)描述符
- MVA通过其[31:20]位加上页表基地址首先找到其对应的细页表描述符，一共有4096个细页表
- 细页表[31:12]为细页表基地址，与MVA[19:10]组合，对应索引到二级页表的基地址
- 每个二级页表条目为1024个，每个条目可以表示1KB的物理地址空间,对应MVA[9:0](4096*1024*1KB=4GB)
** 二级描述符内容
当一级描述符为粗页表或者为细页表时，就会需要有二级描述符，二级描述符用于描述1MB的空间，二级描述符分为如下几种：
*** 大页描述符
- 大页描述符[31:16]为大页基地址(Large page base address)
- 其[15:0]对应64KB的物理地址空间偏移
- 在粗页表中，二级页表条目只能表示4KB的物理空间，所以有连续16个条目保存同一个大页表描述符
- 在细页表中，二级页表条目只能表示1KB的物理空间，所以有连续64个条目保存同一个大页表描述符
[[./mmu_large_page.jpg]]

*** 小页描述符
- 小页描述符[32:12]为小页基地址(Small page base address)
- 其[11:0]对应4KB的物理地址空间偏移
- 在粗页表中，每个条目正好4KB，则一个条目正好对应一个小页描述符
- 在细页表中，每个条目1KB，则需要4个连续的条目表示同一个小页描述符
[[./mmu_small_page.jpg]]

*** 极小页描述符
- 极小页描述符[31:10]为极小页基地址(Tiny page base address)
- 其[9:0]对应1KB物理地址空间偏移
- 极小页描述符通过细页表一个条目与之一一对应
[[./mmu_tiny_page.jpg]]

* 多进程下的页表
在有操作系统的情况下，都是多个进程并发运行，而不同的进程具有不同的页表。
这些页表都是保存在内存中的，CPU在运行不同的进程时，都会调取对应的 *一级页表基地址* 到MMU的基地址寄存器，
接下来的转换过程便是MMU硬件来自动完成的过程。
* 内存的权限检查
MMU通过读取页描述符中的对应位来确定当前的访问是否具有对应的权限。

内存的访问权限检查可以概括为以下两点：
1. “域”决定是否对某块内存进行权限检查
2. "AP"决定如何对某块内存进行权限检查
* TLB的作用
转译查找缓存(Translation Lookaside Buffers, TLB)就是部分页表的一个快速缓存(类似于cache)，避免每次MMU都要从主存中获取页表内容。

当CPU发出一个虚拟地址时，MMU首先访问TLB，如果TLB中含有对应的描述符，则直接利用此描述符进行转换和权限检查。否则MMU
访问主存中的页表进行转换和权限检查，并将这次获取的描述符放入TLB，以便下次使用。

#+begin_example
使用TLB需要保证TLB与主存的一致性，在启动MMU之前需要使无效整个TLB，启动后再打开此功能。
#+end_example
