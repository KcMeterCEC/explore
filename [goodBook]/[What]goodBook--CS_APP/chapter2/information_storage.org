#+TITLE: [What]Information storage
#+DATE: <2018-06-18 一> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,CS:APP
#+NAME: <book_csapp_chapter_2_1.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

重新认识计算机系统。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 16进制计算
一般在计算机系统中，都是以字节为其基本的操作单位，编译器根据源码中的数据类型来决定其具体的操作方式。

而对编码来说，数据的表示使用16进制比使用2进制或十进制更加有优势，即不像二进制那么冗余，不像10进制那么不容易转为二进制。
** 2的n次方来计算16进制
当一个数等于2的n次方时(n为非负数)，其就相当于将1左移n位，其对应的16进制就是 0x100..,0x200..,0x400..,0x800..

快速计算的公式为: n = i + 4j
- 也就是将2的n次方中的 =n= 使用 =i + 4j= 来拟合。
- 其中 =i= 取值范围为 0~3，分别对应16进制中的 1,2,4,8。
- 最后计算出来的 =j= 就是代表后面跟几个0
#+BEGIN_EXAMPLE
  比如 2048 = 2 ^ 11
  其中 n = 11 = 3 + 4 * 2, i = 3 对应16进制的8，j=2对应后面跟两个0
  最早的16进制就是 0x800
#+END_EXAMPLE
** 10进制转16进制
10进制通过 =循环除以16，并依次取其余数从最低位到最高位来倒序排列= 来转换为16进制。
#+BEGIN_EXAMPLE
  比如一个十进制数为 314156,依次计算如下：
  ->  314156 = 19634 * 16 + 12  (余数12，对应16进制为C)
  ->  19634  = 1227 * 16 + 2    (余数2，对应16进制为2)
  ->  1227   = 76 * 16 + 11     (余数为11，对应16进制为B)
  ->  76     = 4 * 16 + 12      (余数12，对应16进制为C)
  ->  4      = 0 * 16 + 4       (4)

  ==> 最终16进制为 0x4cb2c
#+END_EXAMPLE
而16进制转10进制，则是每一位依次乘以16的(n-1)次方的求和。
* 数据与大小
计算机系统中的字长，也就是一个指针的大小，也决定了其虚拟地址的范围大小。
目前32位与64位机共存，为了使得代码具有移植性，关于整型的操作还是应该使用 =stdint.h= 中的定义。
** 地址与大小端
代码中的对象，在内存中以两个方面来反应：
1. 对象存储的地址
2. 对象的字节序：字节序分为小端模式(低字节在前)和大端模式(高字节在前)
  - 跟多处理器都具有大小端选择控制

字节序的问题在以下几种情况下需要注意：
1. 与其他主机通信
  - 在通过socket通信时，需要调用标准的socket接口以转换统一的字节序
  - 在嵌入式系统上多个不同处理器通信时，需要统一确认大小端
2. 在代码中嵌入汇编时，当需要给某个地址写一个类似整型的多字节对象时，需要注意大小端
   
判断当前系统的大小端使用下面代码即可:
#+BEGIN_SRC c
  #include <stdio.h>
  #include <stdbool.h>
  #include <stdint.h>

  bool is_big_endian(void)
  {
    uint32_t val = 0x12345678;
    char *str = (char *)&val;

    if(*str == 0x12)
      {
        return true;
      }

    return false;
  }


  int main(void)
  {
    printf("your system is %s endian\n", is_big_endian() ? "big" : "little");

    return 0;
  }
#+END_SRC
