#+TITLE: [What]Information storage
#+DATE: <2018-06-18 一> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,CS:APP
#+NAME: <book_csapp_chapter_2_1.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

重新认识计算机系统。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 16进制计算
一般在计算机系统中，都是以字节为其基本的操作单位，编译器根据源码中的数据类型来决定其具体的操作方式。

而对编码来说，数据的表示使用16进制比使用2进制或十进制更加有优势，即不像二进制那么冗余，不像10进制那么不容易转为二进制。
** 2的n次方来计算16进制
当一个数等于2的n次方时(n为非负数)，其就相当于将1左移n位，其对应的16进制就是 0x100..,0x200..,0x400..,0x800..

快速计算的公式为: n = i + 4j
- 也就是将2的n次方中的 =n= 使用 =i + 4j= 来拟合。
- 其中 =i= 取值范围为 0~3，分别对应16进制中的 1,2,4,8。
- 最后计算出来的 =j= 就是代表后面跟几个0
#+BEGIN_EXAMPLE
  比如 2048 = 2 ^ 11
  其中 n = 11 = 3 + 4 * 2, i = 3 对应16进制的8，j=2对应后面跟两个0
  最早的16进制就是 0x800
#+END_EXAMPLE
** 10进制转16进制
10进制通过 =循环除以16，并依次取其余数从最低位到最高位来倒序排列= 来转换为16进制。
#+BEGIN_EXAMPLE
  比如一个十进制数为 314156,依次计算如下：
  ->  314156 = 19634 * 16 + 12  (余数12，对应16进制为C)
  ->  19634  = 1227 * 16 + 2    (余数2，对应16进制为2)
  ->  1227   = 76 * 16 + 11     (余数为11，对应16进制为B)
  ->  76     = 4 * 16 + 12      (余数12，对应16进制为C)
  ->  4      = 0 * 16 + 4       (4)

  ==> 最终16进制为 0x4cb2c
#+END_EXAMPLE
而16进制转10进制，则是每一位依次乘以16的(n-1)次方的求和。
* 数据与大小
计算机系统中的字长，也就是一个指针的大小，也决定了其虚拟地址的范围大小。
目前32位与64位机共存，为了使得代码具有移植性，关于整型的操作还是应该使用 =stdint.h= 中的定义。
** 地址与大小端
代码中的对象，在内存中以两个方面来反应：
1. 对象存储的地址
2. 对象的字节序：字节序分为小端模式(低字节在前)和大端模式(高字节在前)
  - 跟多处理器都具有大小端选择控制

字节序的问题在以下几种情况下需要注意：
1. 与其他主机通信
  - 在通过socket通信时，需要调用标准的socket接口以转换统一的字节序
  - 在嵌入式系统上多个不同处理器通信时，需要统一确认大小端
2. 在代码中嵌入汇编时，当需要给某个地址写一个类似整型的多字节对象时，需要注意大小端
   
判断当前系统的大小端使用下面代码即可:
#+BEGIN_SRC c
  #include <stdio.h>
  #include <stdbool.h>
  #include <stdint.h>

  bool is_big_endian(void)
  {
    uint32_t val = 0x12345678;
    char *str = (char *)&val;

    if(*str == 0x12)
      {
        return true;
      }

    return false;
  }


  int main(void)
  {
    printf("your system is %s endian\n", is_big_endian() ? "big" : "little");

    return 0;
  }
#+END_SRC
** 位运算
c中可用的位运算有: |(或)，&(与)，~(按位取返),!(取返),^(异或,两个数不同的位求或，相同的位置0)

下面的代码可以不需要临时变量temp来实现二者的交换:
#+BEGIN_SRC c
  #include <stdio.h>

  void inplace_swap(int *x, int *y)
  {
    ,*y = *x ^ *y; // *y = a ^ b
    ,*x = *x ^ *y; // *x = a ^ a ^ b = 0 ^ b = b
    ,*y = *x ^ *y; // *y = b ^ a ^ b = 0 ^ a = a
  }

  int main(void)
  {
    int a = 123;
    int b = 456;

    printf("the result swap a = %d, b = %d, ", a, b);
    inplace_swap(&a, &b);
    printf("is a = %d, b = %d\n", a, b);
  }
#+END_SRC
** 逻辑运算
c中支持的逻辑运算就是 &&(与) ,||(或), !(非)。

需要注意的有以下两点:
1. 逻辑运算的返回只有0(false)和1(true)两种结果
2. 逻辑运算中，采用最少判断法则，只要前面的参数足以判断逻辑式的真假，后面的参数就不用判断了
  + 比如 a && 5 / a ，当a为0时，并不会触发除零错误，因为第一个判断就知道此表达式为假了，后面的判断就不会执行了
** 移位操作
基于硬件支持的移位操作是:
- 左移 : 地位补零
- 逻辑右移 : 高位补零
- 算术右移 : 最高位补符号位的值，符号位是0就补0,符号位是1就补1

*在c上实践的结果是:对于正数，其操作与逻辑右移一致。对于负数，高位补1* 。

为什么没有算术左移？

因为负数是以补码的形式表示的，所以逻辑操作的结果就是算术操作的结果。
