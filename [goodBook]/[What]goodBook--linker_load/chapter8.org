#+TITLE: [What]链接、装载与库 --> Linux共享库组织
#+DATE: <2018-12-14 Fri> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,程序员的自我休养
#+NAME: <book_link_chapter_8.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

为了较好的维护共享库，需要将它们按照一定的规则组织起来。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 共享库的版本
** 兼容性问题
c语言的共享库的更新可以被分为兼容更新和不兼容更新，以下这些改变都会导致更新不兼容:
1. 导出函数的行为发生改变：虽然参数接口及返回没有改变，但相对旧版本行为变了很多
2. 导出函数被删除：这对于程序来讲就少了一些符号
3. 导出的数据结构发生变化：这导致对应内存操作不一致
4. 导出的函数的接口或返回值发生变化：这也相当于符号不匹配吧
5. 不同版本的编译器、操作系统、硬件平台等

相对来讲，c++其语法的复杂性使得兼容性更难以保持，很多时候使用c++调用c共享库是个不错的选择。
** 共享库版本命名
linux规定了一套共享库版本命名规则: =libname.so.x.y.z= 
- name : 库名称
- x : 主版本号(Major Version Number)，库的重大升级，可能不会兼容旧库
  + 所以以前的程序需要重新编译链接后才能使用此新库
- y : 次版本号(Minor Version Number), 增加一些新的接口符号且保持原来的接口不变
- z : 发布版本号(Release Version Number), 修正库的错误、性能改进等，不会添加新的接口也不会改变接口。

所以一个库的次版本号和发布版本号升级时，对应的程序是不用重新升级的，直接拿来就能用。而主版本号升级时，最好根据说明修改代码再重新编译链接。
** SO-NAME
由上面可以看出，主版本号决定了库的兼容性，一个程序主模块必须使用对应主版本号一致的共享库。

Linux中使用 =SO-NAME= 来表示共享库的主版本号，通常这是一个指向共享库全名的软链接。(比如共享库为 libfoo.so.2.6.1，对应的SO-NAME就为libfoo.so.2)
- 软链接会指向目录中主版本号相同、次版本号和发布版本号最新的共享库。
  + =ldconfig= 用于自动遍历共享库目录，更新软链接到最新共享库
  
在实际的主模块进行链接和运行时，都是使用以 =SO-NAME= 为名字的软链接。

在实际编译主模块源码时，只需要使用 =-l<name>= 参数，gcc会自动查找最新版本的 <name> 库。
- 查找路径由参数 =-L= 决定
- 当使用 =-static= 参数时，gcc会查找静态库，也就是lib<name>.a

* 符号版本
** 次版本号交会问题(Minor-revision Rendezvous Problem)
当某个程序依赖于较高的次版本号的共享库，而运行于较低此版本号的共享库系统时，就可能产生缺少某些符号的错误。
- 因为次版本号可能会增加一些接口，且它只保证向后兼容性。
** 基于符号的版本机制(Symbol Versioning) 
上面这个问题，使用符号版本机制来解决： 让每个导出和导入的符号都有一个相关联的版本号，它的实际做法类似于名称修饰的方法。
- 在那些新的次版本号中添加的全局符号打上相应的版本标记。
  
加上符号版本机制后，当在编译和链接程序时，链接器会根据当前程序依赖的符号而记录 *它所用到的最低满足要求的符号版本* 。
在程序运行时，动态链接器会通过程序内记录的它所依赖的所有共享库的符号集合版本信息，然后判定当前系统共享库中的符号集合版本是否满足这些被依赖的符号即可。

