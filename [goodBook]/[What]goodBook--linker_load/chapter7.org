#+TITLE: [What]链接、装载与库 --> 动态链接
#+DATE: <2018-11-25 Sun> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,程序员的自我休养
#+NAME: <book_link_chapter_7.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

静态链接使得内存浪费太大并且更新不方便，而动态链接则弥补了这个不足。

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整程序。
而不像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
- linux下为 *动态共享对象(DSO, Dynamic Shared Objects)* , 以 =.so= 为扩展名
- windows下为 *动态链接库(Dynamical Linking Library)*, 以 =.dll= 为扩展名

动态链接的优点如下:
1. 一个动态链接库被多个进程所使用，节省了内存空间
2. 由于多个进程共享同一模块，使得cpu cache命中率很高
3. 动态模块升级时不用更新程序其他部分，使得升级方便
4. 程序在运行时可以动态加载各种程序模块，可以被用于制作插件
5. 只要操作系统提供了相应的接口，模块就可以跨操作系统兼容
  - 如何接口没有管理好，那么兼容性将会是个问题
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 实例感受
测试代码如下:
#+BEGIN_SRC c
  //file program1.c
  #include "lib.h"

  int main()
  {
    foobar(1);

    return 0;
  }
  //file program2.c
  #include "lib.h"

  int main()
  {
    foobar(2);

    return 0;
  }
  //file lib.c
  #include <stdio.h>

  void foobar(int i)
  {
    printf("printing from lib.so %d\n", i);
  }
  //file lib.h
  #ifndef __LIB_H__
  #define __LIB_H__
  extern void foobar(int i);
  #endif
#+END_SRC
编译共享库及执行验证
#+BEGIN_EXAMPLE
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -fPIC -shared -o lib.so lib.c
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -o program1 program1.c ./lib.so
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -o program2 program2.c ./lib.so
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ls
  lib.c  lib.h  lib.so  program1  program1.c  program2  program2.c
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ./program1
  printing from lib.so 1
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ./program2
  printing from lib.so 2
#+END_EXAMPLE
为了能够观察代码在虚拟地址中的映射关系，修改 =lib.c= :
#+BEGIN_SRC c
  #include <stdio.h>
  #include <unistd.h>

  void foobar(int i)
  {
    printf("printing from lib.so %d\n", i);
    printf("sleep\n");
    while(1)
      {
        sleep(1);  
      }
  }
#+END_SRC
可以看到它映射格局如下:
#+BEGIN_EXAMPLE
  cec@virtual:~/learn/c/dynamical$ ./program1&
  [1] 16831
  printing from lib.so 1
  sleep
  cec@virtual:~/learn/c/dynamical$ cat /proc/16831/maps 
  00400000-00401000 r-xp 00000000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  00600000-00601000 r--p 00000000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  00601000-00602000 rw-p 00001000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  0150c000-0152d000 rw-p 00000000 00:00 0                                  [heap]
  7fd652d58000-7fd652f18000 r-xp 00000000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd652f18000-7fd653118000 ---p 001c0000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd653118000-7fd65311c000 r--p 001c0000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd65311c000-7fd65311e000 rw-p 001c4000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd65311e000-7fd653122000 rw-p 00000000 00:00 0 
  7fd653122000-7fd653123000 r-xp 00000000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653123000-7fd653322000 ---p 00001000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653322000-7fd653323000 r--p 00000000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653323000-7fd653324000 rw-p 00001000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653324000-7fd65334a000 r-xp 00000000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd653521000-7fd653524000 rw-p 00000000 00:00 0 
  7fd653548000-7fd653549000 rw-p 00000000 00:00 0 
  7fd653549000-7fd65354a000 r--p 00025000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd65354a000-7fd65354b000 rw-p 00026000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd65354b000-7fd65354c000 rw-p 00000000 00:00 0 
  7ffe3ede1000-7ffe3ee02000 rw-p 00000000 00:00 0                          [stack]
  7ffe3ef2d000-7ffe3ef30000 r--p 00000000 00:00 0                          [vvar]
  7ffe3ef30000-7ffe3ef32000 r-xp 00000000 00:00 0                          [vdso]
  ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
#+END_EXAMPLE
在堆与栈之间，映射了动态链接库 =libc,lib= 以及动态链接器 =ld= 。
- 在运行program1之前，动态链接器先完成链接工作，然后再把控制权交给program1执行.
* 地址无关代码
动态链接库在被装载时其地址是未知的，这是为了避免:
1. 多个动态库的干涉问题
2. 自身以后升级，内部函数和变量地址改变的问题
   
所以使用了 *装载时重定位(Load Time Relocation)* 的方式: 在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。
一旦模块装载地址确定，即目标地址确定，那么系统对程序中所有的绝对地址引用进行重定位。

但这种方式依然有问题: 因为需要重定位，就需要修改动态链接库的代码(也就是地址会改变)。但是动态链接库是需要多个进程共享的，
多个进程拥有独立的数据部分，但代码部分是共享的。这就无法满足此需求。

于是，最终的 *地址无关代码(PIC, Position-independent Code)* 方式就产生了: 把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保存不变。
而数据部分可以在每个进程拥有一个副本。
- 在实现时，数据段中存放指向这些函数的指针数组(全局偏移表，Global Offset Table, GOT)，通过数组来间接找到动态链接库代码的位置。
  
地址无关引用方式如下表:
|          | 指令跳转、调用      | 数据访问      |
|----------+---------------------+---------------|
| 模块内部 | 相对跳转和调用      | 相对地址访问  |
| 模块外部 | 间接跳转和调用(GOT) | 间接访问(GOT) |

* 延迟绑定
动态链接在程序启动时装载一起运行时的GOT定位都会减慢程序的运行速度，为了优化启动速度使用延迟绑定(Lazy Binding)的方式来优化。
- 延迟绑定使用PLT(Procedure Linkage Table)的方式实现

其核心思想就是：当函数被第一次调用到的时候才形式符号绑定、重定位等操作。
- 因为很多函数并不会被使用

PLT在函数第一次被调用后，首先进行符号查找、重定位，然后才会跳转到GOT表。

ELF将GOT拆分成了两个表叫做".got"和".got.plt"，".got"用来保存全局变量引用的地址，".got.plt"用来保存函数引用的地址。

* 动态链接相关结构
动态链接方式的elf文件启动步骤为:
1. 读取可执行文件头部，检查文件合法性，从头部中的"Program Header"中读取每个"Segment"的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置
2. 将动态链接器加载到进程地址空间并将控制权交给动态链接器的入口地址。
3. 动态链接器执行一系列自身初始化操作，根据当前环境参数开始对可执行文件进行动态链接工作，当链接工作完成后将控制权转交到可执行文件的入口地址，程序开始运行
** ".interp"段
=.interp= 段保存一个字符串，指定该可执行文件所需要的动态连接器的路径。
#+BEGIN_EXAMPLE
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ objdump -s program1

  program1:     file format elf64-x86-64

  Contents of section .interp:
   0238 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
   0248 7838362d 36342e73 6f2e3200           x86-64.so.2. 
#+END_EXAMPLE
可以看到在x86-64系统上其为 =/lib64/ld-linux-x86-64.so.2= ,实际上它是一个符号链接，指向当前系统的动态连接器。

这样的好处是：当动态连接器版本有所更新时，不需要重新编译可执行文件，因为符号链接的路径和名称都不会被改变。
** ".dynamic"段(动态链接描述头)
=.dynamic= 段保存了动态连接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、
动态链接重定位表的位置、共享对象初始化代码的地址等。
- =.dynamic= 存在于动态链接文件中，类似于elf文件头，用于描述此文件的概览
#+BEGIN_SRC c
  typedef struct
  {
    Elf64_Sxword	d_tag;			/* Dynamic entry type */
    union
    {
      Elf64_Xword d_val;		/* Integer value */
      Elf64_Addr d_ptr;			/* Address value */
    } d_un;
  } Elf64_Dyn;
#+END_SRC
比较常用的d_tag有下面这些值:
| d_tag类型            | d_un的含义                                         |
|----------------------+----------------------------------------------------|
| DT_SYMTAB            | 动态链接符号表的地址，d_ptr表示".dynsym"的地址     |
| DT_STRTAB            | 动态链接字符串表地址，d_ptr表示".dynstr"的地址     |
| DT_STRSZ             | 动态链接字符串表大小，d_val表示大小                |
| DT_HASH              | 动态链接哈希表地址,d_ptr表示".hash"的地址          |
| DT_SONAME            | 本共享对象的"SO-NAME"                              |
| DT_RPATH             | 动态链接共享对象搜索路径                           |
| DT_INIT              | 初始化代码地址                                     |
| DT_FINIT             | 结束代码地址                                       |
| DT_NEED              | 依赖的共享对象文件,d_ptr表示所依赖的共享对象文件名 |
| DT_REL/DT_RELA       | 动态链接重定位表地址                               |
| DT_RELENT/DT_RELAENT | 动态重读位表入口数量                               |
#+BEGIN_EXAMPLE
  cec@virtual:~/learn/c/dynamical$ readelf -d lib.so 

  Dynamic section at offset 0xe18 contains 24 entries:
    Tag        Type                         Name/Value
   0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
   0x000000000000000c (INIT)               0x5b8
   0x000000000000000d (FINI)               0x76c
   0x0000000000000019 (INIT_ARRAY)         0x200e00
   0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
   0x000000000000001a (FINI_ARRAY)         0x200e08
   0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
   0x000000006ffffef5 (GNU_HASH)           0x1f0
   0x0000000000000005 (STRTAB)             0x3b0
   0x0000000000000006 (SYMTAB)             0x230
   0x000000000000000a (STRSZ)              188 (bytes)
   0x000000000000000b (SYMENT)             24 (bytes)
   0x0000000000000003 (PLTGOT)             0x201000
   0x0000000000000002 (PLTRELSZ)           72 (bytes)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x570
   0x0000000000000007 (RELA)               0x4b0
   0x0000000000000008 (RELASZ)             192 (bytes)
   0x0000000000000009 (RELAENT)            24 (bytes)
   0x000000006ffffffe (VERNEED)            0x490
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x46c
   0x000000006ffffff9 (RELACOUNT)          3
   0x0000000000000000 (NULL)               0x0
#+END_EXAMPLE
** 动态符号表
静态链接中，符号的建立和使用被分别称为定义和引用。
而动态链接中，动态链接库符号被外部使用时称为导出(Export)，对应使用外部符号的部分称为导入(Import).

和静态链接一样，为了表示符号的导入导出关系，elf使用 *动态符号表(Dynamic Symbol Table)* 来保存这些信息，段名 =.dynsym=
- 与符号表(.symtab)不同的是，.dynsym只保存了与动态链接相关的符号。而所有的符号依然保存在 =.symtab= 中。
  
同样的，动态符号表中实际包含的是符号的下标，真正的字符串内存存在于 *动态符号字符串表(.dynstr ,Dynamic String Table)* 中
- 由于动态链接下，需要在运行时查找符号，为了加快符号的查找过程，还需要有辅助的 *符号哈希表(.hash)*.
  
#+BEGIN_EXAMPLE
  cec@virtual:~/learn/c/dynamical$ readelf --dyn-syms  lib.so 

  Symbol table '.dynsym' contains 16 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 00000000000005b8     0 SECTION LOCAL  DEFAULT    9 
       2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
       3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
       4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
       5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
       6: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
       7: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
       8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND sleep@GLIBC_2.2.5 (2)
       9: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)
      10: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT   23 _edata
      11: 0000000000201040     0 NOTYPE  GLOBAL DEFAULT   24 _end
      12: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT   24 __bss_start
      13: 00000000000005b8     0 FUNC    GLOBAL DEFAULT    9 _init
      14: 000000000000076c     0 FUNC    GLOBAL DEFAULT   13 _fini
      15: 0000000000000730    57 FUNC    GLOBAL DEFAULT   12 foobar

  cec@virtual:~/learn/c/dynamical$ readelf -sD  lib.so 

  Symbol table of `.gnu.hash' for image:
    Num Buc:    Value          Size   Type   Bind Vis      Ndx Name
     10   0: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT  23 _edata
     11   0: 0000000000201040     0 NOTYPE  GLOBAL DEFAULT  24 _end
     12   1: 0000000000201038     0 NOTYPE  GLOBAL DEFAULT  24 __bss_start
     13   1: 00000000000005b8     0 FUNC    GLOBAL DEFAULT   9 _init
     14   2: 000000000000076c     0 FUNC    GLOBAL DEFAULT  13 _fini
     15   2: 0000000000000730    57 FUNC    GLOBAL DEFAULT  12 foobar
#+END_EXAMPLE
** 动态链接重定位表
在动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，那么它代码或数据中就会有对于导入符号的引用。
在编译时这些导入符号的地址未知(在静态链接中，这些目标文件中的未知地址最终在链接阶段被修正)，所以就需要在运行时将这些
导入符号的引用修正，也就是重定位。
- 如果一个共享对象不是以PIC模式编译的，那么它的代码段和数据段是需要在装载时重定位的
- 如果一个共享对象是PIC模式编译的，那么它的数据段是需要重定位的
  + 代码段通过GOT变为了相对地址引用，但GOT存在于数据段中，而数据段可能包含绝对地址引用。
    
静态链接的重定位是在静态链接时完成的，目标文件中包含有重定位表(.rel.text, .rel.data)。

动态链接的重定位是在装载时完成的，动态链接文件中的重定位表分别叫做 =.rel.dyn, .rel.plt= 分别对应 =.rel.data, .rel.text= 
- =.rel.dyn= 是对数据引用的修正，修正的位置位于 =.got= 以及数据段
- =.rel.plt= 是对函数引用的修改，修正的位置位于 =.got.plt= 
#+BEGIN_EXAMPLE
  cec@virtual:~/learn/c/dynamical$ readelf -r lib.so

  Relocation section '.rela.dyn' at offset 0x4b0 contains 8 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
  000000200e00  000000000008 R_X86_64_RELATIVE                    700
  000000200e08  000000000008 R_X86_64_RELATIVE                    6c0
  000000201030  000000000008 R_X86_64_RELATIVE                    201030
  000000200fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
  000000200fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
  000000200fe8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 _Jv_RegisterClasses + 0
  000000200ff0  000700000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
  000000200ff8  000900000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0

  Relocation section '.rela.plt' at offset 0x570 contains 3 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
  000000201018  000300000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000201020  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000201028  000800000007 R_X86_64_JUMP_SLO 0000000000000000 sleep@GLIBC_2.2.5 + 0
#+END_EXAMPLE
