#+TITLE: [What]链接、装载与库 --> 动态链接
#+DATE: <2018-11-25 Sun> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,程序员的自我休养
#+NAME: <book_link_chapter_7.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

静态链接使得内存浪费太大并且更新不方便，而动态链接则弥补了这个不足。

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整程序。
而不像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
- linux下为 *动态共享对象(DSO, Dynamic Shared Objects)* , 以 =.so= 为扩展名
- windows下为 *动态链接库(Dynamical Linking Library)*, 以 =.dll= 为扩展名

动态链接的优点如下:
1. 一个动态链接库被多个进程所使用，节省了内存空间
2. 由于多个进程共享同一模块，使得cpu cache命中率很高
3. 动态模块升级时不用更新程序其他部分，使得升级方便
4. 程序在运行时可以动态加载各种程序模块，可以被用于制作插件
5. 只要操作系统提供了相应的接口，模块就可以跨操作系统兼容
  - 如何接口没有管理好，那么兼容性将会是个问题
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 实例感受
测试代码如下:
#+BEGIN_SRC c
  //file program1.c
  #include "lib.h"

  int main()
  {
    foobar(1);

    return 0;
  }
  //file program2.c
  #include "lib.h"

  int main()
  {
    foobar(2);

    return 0;
  }
  //file lib.c
  #include <stdio.h>

  void foobar(int i)
  {
    printf("printing from lib.so %d\n", i);
  }
  //file lib.h
  #ifndef __LIB_H__
  #define __LIB_H__
  extern void foobar(int i);
  #endif
#+END_SRC
编译共享库及执行验证
#+BEGIN_EXAMPLE
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -fPIC -shared -o lib.so lib.c
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -o program1 program1.c ./lib.so
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ gcc -o program2 program2.c ./lib.so
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ls
  lib.c  lib.h  lib.so  program1  program1.c  program2  program2.c
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ./program1
  printing from lib.so 1
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ ./program2
  printing from lib.so 2
#+END_EXAMPLE
为了能够观察代码在虚拟地址中的映射关系，修改 =lib.c= :
#+BEGIN_SRC c
  #include <stdio.h>
  #include <unistd.h>

  void foobar(int i)
  {
    printf("printing from lib.so %d\n", i);
    printf("sleep\n");
    while(1)
      {
        sleep(1);  
      }
  }
#+END_SRC
可以看到它映射格局如下:
#+BEGIN_EXAMPLE
  cec@virtual:~/learn/c/dynamical$ ./program1&
  [1] 16831
  printing from lib.so 1
  sleep
  cec@virtual:~/learn/c/dynamical$ cat /proc/16831/maps 
  00400000-00401000 r-xp 00000000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  00600000-00601000 r--p 00000000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  00601000-00602000 rw-p 00001000 08:01 5778451                            /home/cec/learn/c/dynamical/program1
  0150c000-0152d000 rw-p 00000000 00:00 0                                  [heap]
  7fd652d58000-7fd652f18000 r-xp 00000000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd652f18000-7fd653118000 ---p 001c0000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd653118000-7fd65311c000 r--p 001c0000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd65311c000-7fd65311e000 rw-p 001c4000 08:01 3409179                    /lib/x86_64-linux-gnu/libc-2.23.so
  7fd65311e000-7fd653122000 rw-p 00000000 00:00 0 
  7fd653122000-7fd653123000 r-xp 00000000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653123000-7fd653322000 ---p 00001000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653322000-7fd653323000 r--p 00000000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653323000-7fd653324000 rw-p 00001000 08:01 5769668                    /home/cec/learn/c/dynamical/lib.so
  7fd653324000-7fd65334a000 r-xp 00000000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd653521000-7fd653524000 rw-p 00000000 00:00 0 
  7fd653548000-7fd653549000 rw-p 00000000 00:00 0 
  7fd653549000-7fd65354a000 r--p 00025000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd65354a000-7fd65354b000 rw-p 00026000 08:01 3409177                    /lib/x86_64-linux-gnu/ld-2.23.so
  7fd65354b000-7fd65354c000 rw-p 00000000 00:00 0 
  7ffe3ede1000-7ffe3ee02000 rw-p 00000000 00:00 0                          [stack]
  7ffe3ef2d000-7ffe3ef30000 r--p 00000000 00:00 0                          [vvar]
  7ffe3ef30000-7ffe3ef32000 r-xp 00000000 00:00 0                          [vdso]
  ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
#+END_EXAMPLE
在堆与栈之间，映射了动态链接库 =libc,lib= 以及动态链接器 =ld= 。
- 在运行program1之前，动态链接器先完成链接工作，然后再把控制权交给program1执行.
* 地址无关代码
动态链接库在被装载时其地址是未知的，这是为了避免:
1. 多个动态库的干涉问题
2. 自身以后升级，内部函数和变量地址改变的问题
   
所以使用了 *装载时重定位(Load Time Relocation)* 的方式: 在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。
一旦模块装载地址确定，即目标地址确定，那么系统对程序中所有的绝对地址引用进行重定位。

但这种方式依然有问题: 因为需要重定位，就需要修改动态链接库的代码(也就是地址会改变)。但是动态链接库是需要多个进程共享的，
多个进程拥有独立的数据部分，但代码部分是共享的。这就无法满足此需求。

于是，最终的 *地址无关代码(PIC, Position-independent Code)* 方式就产生了: 把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保存不变。
而数据部分可以在每个进程拥有一个副本。
- 在实现时，数据段中存放指向这些函数的指针数组(全局偏移表，Global Offset Table, GOT)，通过数组来间接找到动态链接库代码的位置。
  
地址无关引用方式如下表:
|          | 指令跳转、调用      | 数据访问      |
|----------+---------------------+---------------|
| 模块内部 | 相对跳转和调用      | 相对地址访问  |
| 模块外部 | 间接跳转和调用(GOT) | 间接访问(GOT) |

* 延迟绑定
动态链接在程序启动时装载一起运行时的GOT定位都会减慢程序的运行速度，为了优化启动速度使用延迟绑定(Lazy Binding)的方式来优化。
- 延迟绑定使用PLT(Procedure Linkage Table)的方式实现

其核心思想就是：当函数被第一次调用到的时候才形式符号绑定、重定位等操作。
- 因为很多函数并不会被使用

PLT在函数第一次被调用后，首先进行符号查找、重定位，然后才会跳转到GOT表。

ELF将GOT拆分成了两个表叫做".got"和".got.plt"，".got"用来保存全局变量引用的地址，".got.plt"用来保存函数引用的地址。

* 动态链接相关结构
动态链接方式的elf文件启动步骤为:
1. 读取可执行文件头部，检查文件合法性，从头部中的"Program Header"中读取每个"Segment"的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置
2. 将动态链接器加载到进程地址空间并将控制权交给动态链接器的入口地址。
3. 动态链接器执行一系列自身初始化操作，根据当前环境参数开始对可执行文件进行动态链接工作，当链接工作完成后将控制权转交到可执行文件的入口地址，程序开始运行
** ".interp"段
=.interp= 段保存一个字符串，指定该可执行文件所需要的动态连接器的路径。
#+BEGIN_EXAMPLE
  cec@ubuntu:~/exercise/linux/linker_loader/dynamical$ objdump -s program1

  program1:     file format elf64-x86-64

  Contents of section .interp:
   0238 2f6c6962 36342f6c 642d6c69 6e75782d  /lib64/ld-linux-
   0248 7838362d 36342e73 6f2e3200           x86-64.so.2. 
#+END_EXAMPLE
可以看到在x86-64系统上其为 =/lib64/ld-linux-x86-64.so.2= ,实际上它是一个符号链接，指向当前系统的动态连接器。

这样的好处是：当动态连接器版本有所更新时，不需要重新编译可执行文件，因为符号链接的路径和名称都不会被改变。
** ".dynamic"段
=.dynamic= 段保存了动态连接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、
动态链接重定位表的位置、共享对象初始化代码的地址等。
#+BEGIN_SRC c
  typedef struct
  {
    Elf64_Sxword	d_tag;			/* Dynamic entry type */
    union
    {
      Elf64_Xword d_val;		/* Integer value */
      Elf64_Addr d_ptr;			/* Address value */
    } d_un;
  } Elf64_Dyn;
#+END_SRC
