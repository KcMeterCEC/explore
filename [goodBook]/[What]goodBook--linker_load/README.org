#+TITLE: [What]预备知识 
#+DATE: <2018-05-31 四> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,程序员的自我休养
#+NAMA: <book_link_chapter_1.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

计算机硬件预备知识。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT


* 程序员的自我休养 --> 链接装载与库
这是 <<程序员的自我休养 --> 链接装载与库>> 的读书笔记.

- [[#预备知识][预备知识]]
- [[#编译和链接][编译和链接]]
- [[#目标文件解析][目标文件解析]]
- [[#静态链接][静态链接]]

** 预备知识
*** 北桥芯片与南桥芯片
北桥芯片 (North bridge), 是为了使 CPU,RAM,显卡这种高速设备通信而实现的.而相应的南桥芯片(South bridge)就是为了协调各个低速设备而实现的,最终南桥与北桥通信,实现协调.

*** SMP与多核
对称多处理器 (SMP, Symmetrical Multi-Processing),是说一个计算机主板上具有多个 CPU,可以完全并行的处理任务.比如很多服务器上就具有多个强悍的 CPU.

多核 (MP, Multi-core Processor),是说在一个 CPU 上集成了多个核心, 核心之间共享缓存,比如 zynq 集成了一个双核心的 cortexA9.

*** 接口
一个复杂的软件系统,都是由各个软件层一层层组合起来的.也正是由于分层的特性,使得各个层内部的改变并不会引起其他层的改变.越往上层就越具有移植性.
与硬件息息相关的就是操作系统的,作为操作系统程序员需要考虑驱动的编写和系统底层的移植.

*** 挖掘计算机硬件的潜力
**** 操作系统调度
操作系统接管了所有的硬件资源,并且本身运行在一个受硬件保护的级别.所有的应用程序都以进程 (Process) 的方式运行在比操作系统权限更低的级别,每个进程都有自己独立的地址空间.
使得进程之间的地址空间相互隔离.CPU 由操作系统统一进行分配,每个进程根据优先级的高低都有机会得到 CPU,但是如果运行时间超出了一定的时间,每个进程根据进程优先级的高低都有机会
得到 CPU, 但是如果运行时间超出了一定的时间,操作系统会暂停改进程,将 CPU 资源分配给其他等待运行的进程.这种 CPU 的分配方式即所谓的抢占式 (Preemptive),操作系统可以强制剥夺
CPU 资源并且分配给它认为目前最需要的进程.

**** 设备驱动
操作系统提供了一些统一的接口,设备驱动满足这些接口便可以被系统调用.

**** 内存管理 
通过 MMU(Memory Management Unit) 的 *虚拟内存* *分页* *权限* 等特性,使得用户代码运行空间相对独立并且安全而且效率更高,同时也可以运行更多的进程.

**** 线程
     多个线程通过共享进程空间,以及各个线程的优先级方式使 CPU 的利用率更高.     
** 编译和链接
*** 预处理
在gcc中,内部调用的预处理器叫做 cpp ,将 c 文件预处理为 .i 文件, 将 cpp 文件预处理为.ii文件.

gcc 使用 -E 选项来指明只需要进行预处理. =gcc -E hello.c -o hello.i=,也可以使用 cpp 来完成.

预处理过程主要处理规则如下:
- 将所有的 "#define" 删除,并且展开所有的宏定义,使用的是直接替换原则
- 处理所有的条件预编译指令,比如 "#if" "#elif" "#else" "#endif"等等
- 处理 "#include" 预编译指令,将被包含的文件在此处展开,如果被包含文件也包含了其他文件,那么层层展开
- 删除所有的注释
- 添加行号和文件名标识,比如 =#2 "hello.c" 2= ,以便于编译时产生调试用的行号信息,以及用于编译时产生编译错误或警告时能够显示行号
- 保留所有的 =#pragma= 编译指令,用于后面的编译过程.
通过以上规则,可以知道其中的一个调试方法是查看预编译后的文件,可以避免掉一些干扰,也可以看到真实的宏定义结果.

*** 编译
编译的过程就是把预处理完的文件进行一系列的词法分析,语法分析,语义分析以及优化后生成相应的汇编代码文件.

在gcc中,将从预编译到编译使用命令 =gcc -S hello.i -o hello.s=,也可以使用 cc1 来完成预处理和编译.

编译过程一般可以分为6步:扫描,语法分析,语义分析,源代码优化,代码生成,目标代码优化.
**** 扫描器(词法分析)
源代码程序首先被输入到 *扫描器(Scanner)*,扫描器的任务很简单,只是简单的进行词法分析,运用一种类似于 *有限状态机(Finite State Machine)* 可以很轻松的将源代码的 *非空格字符* 序列分割成一系列的 *记号(Token)*.说简单点就是把各个小字符提取成一张表.这一过程和[[https:github.com/KcMeterCEC/tools/tree/master/shell%5D%5D][简易命令行shell]] 的扫描命令内容过程很相似.

词法分析产生的记号一般可以分为如下几类:关键字,标识符,字面量(数字,字符串等)和特殊符号(加号,等号等)在识别记号的同时,扫描器也完成库其他工作,比如将标识符存放到符号表,将数字,字符串常量存放到文字表等.

扫描器的程序工具叫做 *lex*.

**** 语法分析(Grammar Parser)
对扫描器产生的记号进行语法分析,从而 *产生语法树(Syntax Tree)* ,整个分析过程采用了 *上下文无关语法(Context-free Grammar)的分析手段.

语法分析器的工具叫做 yacc(Yet Another Compiler Compiler).

**** 语义分析(Semantic Analyzer)
语法分析仅仅完成了对表达式的语法层面分析,但是它并不了解这个语句是否真正有意义.编译器所能分析的是 *静态语义(Static Semantic)*,是指在编译时可以确定的语义,与之对应的是 *动态语义(Dynaic Semantic)* 就是只有在运行期才能确定的语义.经过语义分析后,语法树的表达式都被标识了类型,如果有些类型需要作隐式转换,语义分析程序会在语法树中插入相应的转换节点.

**** 中间语言生成
*源代码优化器(Source Code Optimizer)* 在源代码级别进行优化,但是由于直接在语法树上做优化比较困难,所以源代码优化器往往将整个语法树转换成 *中间代码(Intermediate Code)*, 它是语法树的顺序表示.中间代码有很多种形式,在不同的编译器中有着不同的形式,比较常见的有: *三地址码(Three-address Code)* 和 *P-代码(P-Code)*.
中间代码使得编译器可以被分为前端和后端,编译器前端负责产生机器无关的中间代码,后端将中间代码转换成目标机器码.这样对于一些跨平台的编译器而言,它们可以针对不同的平台使用同一个前端和不同的后端.

**** 目标代码生成与优化
源代码级优化器产生中间代码标志着下面的过程都属于后端,后端主要包括 *代码生成器(Code Generator)* 和 *目标代码优化器(Target Code Optimizer)*.
代码生成器将中间代码转换为目标机器码,这个过程十分依赖于目标机器.

*** 汇编
将编译后的汇编代码转变为二进制文件,因为汇编都有对应的二进制值,所以汇编器的汇编过程相对于编译器来讲比较简单.

在gcc中,将汇编文件到二进制文件使用命令 =gcc -c hello.s -o hello.o / gcc -c hello.c -o hello.o=,也可以使用 as  来完成.

经过预编译,编译,汇编之后的 .o 文件被称为 *目标文件*.
*** 链接
将目标文件与库文件以一定的规则, *确定的地址* 结合,才能形成最后的可执行文件.
** 目标文件解析
*** 目标文件格式
PC 平台流行的 *可执行文件格式(Executable)* 主要是 Windows 下的 PE(Portable Executable) 和 Linux 的 ELF(Executable Linkable Format),
它们都是 COFF(Common file format)格式的变种.目标文件和可执行文件的格式是一样的, *动态链接库(DLL, Dynamic Linking Library)和静态链接库(Static Linking Library)* 
都按照可执行文件格式存储.

| ELF文件类型                      | 说明                                                                                                                                                                                                                          | 实例                        |
|----------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------|
| 可重定位文件(Relocatable File)   | 这类文件包含了代码和数据,可以被用来链接成可执行文件或共享目标文件,静态链接库也可以归为这一类                                                                                                                                  | Linux 的 .o Windows 的 .obj |
| 可执行文件(Executable File)      | 这类文件包含了可以直接执行的程序,它的代表就是ELF可执行文件,一般都没有扩展名                                                                                                                                                   | /bin/bash windows 的 .exe   |
| 共享目标文件(Shared Object File) | 这种文件包含库代码和数据,可以在以下两种情况下使用.一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接,产生新的目标文件.第二种是动态连接器可以将几个这种共享目标文件与可执行文件结合,作为进程影响的一部分来运行 | Linux 的 .so Windows 的 DLL |
| 核心转储文件(Core Dump File)     | 当进程意外中止时,系统可以将进程的地址空间的内容以及终止时的一些其他信息转储到核心转储文件                                                                                                                                     | Linux 下的 core dump        |

在linux下可以使用 =file= 命令查看相应的文件格式.

**** ELF 文件结构描述
| ELF Header           |
| .text                |
| .data                |
| .bss                 |
| other sections       |
| section header table |
| String Tables        |
| Symbol Tables        |

***** ELF Header
可以使用命令 =readelf -h hello.o= 来查看 ELF 文件.

ELF 的文件头中定义了 *ELF 魔数*, *文件机器字节长度*, *数据存储方式*, *版本*, *运行平台*, *ABI版本*, *ELF重定位类型*, *硬件平台*, *硬件平台版本*, *入口地址*, *程序头入口和长度*, *段表位置*, *长度及段的数量*.

ELF 文件头结构及相关常数被定义在 =/usr/include/elf.h= 文件里, 结构体 =Elf32_Ehdr 或 Elf64_Ehdr= 对应着 readelf 文件输出.

****** 魔数
elf 文件头魔数最开始的 4个字节是所有 ELF 文件都必须相同的表示码,分别为 =0x7f,0x45,0x4c,0x46=,第一个字节对应 ASCII 字符里面的 DEL 控制符, 后面3字节刚好是 ELF 这3个字母的 ASCII 码.这 4 个字节又被称为 ELF 文件的魔数.接下来的字节分别用来标识 ELF 的文件类型, 字节序, 主版本号,后面的9个字节ELF标准没有定义,一般填0,有些平台会使用这9个字节作为扩展标志.
****** e_type 文件类型
linux 通过此值来判断 ELF 的真正文件类型,而不是通过文件的扩展名.
| 常量    | 值 | 含义                         |
| ET_REL  |  1 | 可重定位文件,一般为 .o 文件  |
| ET_EXEC |  2 | 可执行文件                   |
| ET_DYN  |  3 | 共享目标文件,一般为 .so 文件 |

****** e_machine
表示当前 ELF 文件在哪种机器平台下使用 

***** Section Header Table
段表是 ELF 文件中除了文件头以外最重要的结构,它描述了 ELF 的各个段的信息.ELF 文件的段结构就是由段表决定的,编译器,链接器和装载器都是依靠段表来定位和访问各个段的属性.
段表在 ELF 文件中的位置由 ELF 文件头的 =e_shoff= 成员决定.

使用命令 =readelf -S hello.o= 来显示完整的段表.

段表的结构比较简单,它是一个以 =Elf32_Shdr= 结构体为元素的数组,数组元素的个数等于段的个数,每个 =Elf32_Shdr= 结构对应一个段.
所以 =Elf32_Shdr= 又被称为段描述符.ELF 段表的这个数组第一个元素是无效的段描述符,它的类型为"NULL",除此之外每个段描述符都对应一个段. 

*sh_type*(段的类型)
段的名字不能真正的表示段的类型,对于编译器和链接器来说,主要决定段的属性的是段的类型(sh_type)和段的标志位(sh_flags),段的类型相关常量以 SHT_ 开头.
| 常量         | 值 | 含义                              |
|--------------+----+-----------------------------------|
| SHT_NULL     |  0 | 无效段                            |
| SHT_PROGBITS |  1 | 程序段. 代码段,数据段都是这种类型 |
| SHT_SYMTAB   |  2 | 符号表                            |
| SHT_STRTAB   |  3 | 字符串表                          |
| SHT_RELA     |  4 | 重定位表                          |
| SHT_HASH     |  5 | 符号表的哈希表                    |
| SHT_DYNMAIC  |  6 | 动态链接信息                      |
| SHT_NOTE     |  7 | 提示信息                          |
| SHT_NOTEBITS |  8 | 表示该段在文件中没有内容,比如 .bss 段 |
| SHT_REL      |  9 | 重定位信息                            |
| SHT_SHLIB    | 10 | 保留                                  |
| SHT_DNYSYM   | 11 | 动态链接符号表                               |

*sh_flag*(段的标志位)
段的标志位表示该段在进程虚拟地址空间中的属性,比如是否可写,可执行,相关常量以 SHF_ 开头.
| 常量          | 值 | 含义                                               |
|---------------+----+----------------------------------------------------|
| SHF_WRITE     |  1 | 可写                                               |
| SHF_ALLOC     |  2 | 在进程空间中需要分配空间.比如代码段,数据段,.bss 段 |
| SHF_EXECINSTR |  4 | 可执行,一般指代码段                                         |

*sh_link , sh_info*(段的链接信息)

| sh_type               | sh_link                              |                            sh_info |
|-----------------------+--------------------------------------+------------------------------------|
| SHT_DYNAMIC           | 该段所使用的字符串表在段表中的下标   |                                  0 |
| SHT_HASH              | 该段所使用的符号表在段表中的下标     |                                  0 |
| SH_REL , SH_RELA      | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段在段表中的下标 |
| SHT_SYMTAB,SHT_DYNSYM | 操作系统相关的                       |                     操作系统相关的 |
| other                 | SHN_UNDEF                            | 0                                  |
***** Relocation Table(重定位表)
链接器在处理目标文件时,须要对目标文件中某些部位进行重定位,即代码段和数据段中那些绝对地址的引用位置.这些重定位的信息都记录在 ELF 文件的重定位表里面,
对于每个需要重定位的代码段或数据段,都会有一个相应的重定位表.比如 ".rela.text" 就是针对 ".text" 段的重定位表.

***** String Table(字符串表)
代码中的字符串是被集中放到一个表,然后使用字符串在表中的偏移在引用字符串.通过这种方法,在ELF 文件中引用字符串只需给出数字下标即可,不用考虑字符串长度的问题.
一般字符串表在 ELF 文件中也以段的形式保存,常见的段名为 ".strtab" 或 ".shstrtab ".这两个字符串表分别为 *字符串表(String Table)* 和 *段表字符串表(Section Header String Table)*.
字符串表用来保存普通的字符串,段表字符串用来保存段表中用到的字符串.
*** 目标文件分段
目标文件将编译得到的信息以 *节(Section)* 的形式存储,有时候也叫 *段(Segment)*.

程序源代码编译后的机器指令经常被放在 *代码段(Code Section)* 里,代码段常见的名字有".code"或".text".
全局变量和局部静态变量数据放在 *数据段(Data Section)*, 数据段的一般名字都叫".data".
未初始化的全局变量和局部静态变量一般放在一个叫 ".bss"段里,程序运行的时候它们是要占内存空间的,并且可执行文件必须记录所有未初始化的全局和局部静态变量的大小总和.所以 .bss段只是为初始化的全局变量和局部静态变量预留位置而已,它并没有内容,所以它在文件中也不占据空间.

*注意:* bss段不占用空间的意思是说不占用磁盘(flash)空间，但是在实际运行时候还是会根据段的大小分配内存空间。

**** 分段的好处
1. 数据和指令分别被映射到两个虚存区域,数据区被设置为可读写,指令区被设置为只读,可以防止程序指令被有意或无意的改写.
2. 由于 CPU 的缓存体系,分段有利于提高程序的局部性,提高缓存的命中率.
3. 当系统中运行着多个该程序的副本时,可以共享代码段而区分数据段,节约内存.
*** 解析目标文件的步骤
- 将编辑好的 c 文件,使用命令 =gcc -c hello.c=,让编译器只编译不链接,从而生成 .o 文件.
- 使用 binutils 的工具 objdump(或 readelf) 来查看目标文件的内部结构,使用命令 =objdump -h hello.o=.
从输出中可以看出各个段的大小以及位置,以 ELF 文件头为开头然后依次增长.在 linux 下还可以使用 =size hello.o= 来输出代码段,数据段和BSS段的长度.
  + size.text = .text + .rodata + .eh_frame 
  
- 使用命令 =objdump -s -d hello.o= 来反汇编, 查看实际指令使用地址以及大小.
- 使用命令 =objdump -x -s -d hello.o= 可以显示包括符号表在内的更加完整的信息.

| 常用的段名  | 说明                                                                                                                                                                   |
|-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| .text       | 代码段                                                                                                                                                                 |
| .data       | 保存已经初始化了的 *非零* 全局变量和局部静态变量                                                                                                                       |
| .rodata     | 只读数据段,比如字符串常量等等,单独设立 .rodata 段有很多好处,不光在语义上支持了 C++ 的 const关键字,而且操作系统在加载的时候可以将.rodata 段属性映射成只读,保证程序安全. |
| .bss        | 存放未初始化的全局变量和局部静态变量, .bss 段保存数量的值,而不是具体值,在最终的链接过程中会分配bss段的空间                                                             |
| .rodata1    | 只读数据与.rodata一样,比如字符串常量,全局 const变量等.                                                                                                                 |
| .comment    | 存放的是编译器版本信息,比如字符串 "GCC:(GUN) 4.2.0"                                                                                                                    |
| .debug      | 调试信息                                                                                                                                                               |
| .dynamic    | 动态链接信息                                                                                                                                                           |
| .hash       | 符号哈希表                                                                                                                                                             |
| .line       | 调试时的行号表,即源代码行号与编译后指令的对应表                                                                                                                        |
| .note       | 额外的编译器信息,比如版本号等等                                                                                                                                        |
| .strtab     | 字符串表,用于存储 ELF 文件中用到的各种字符串                                                                                                                           |
| .symtab     | 符号表                                                                                                                                                                 |
| .plt .got   | 动态链接的跳转表和全局入口表                                                                                                                                           |
| .init .fini | 程序初始化与终结代码段                                                                                                                                                 |

这些段的名字都是由 "." 作为前缀,表示这些表的名字是系统保留的,应用程序也可以使用一些非系统保留的名字作为段名.比如可以在 ELF 文件中插入一个 music 的段,里面存放了一首 MP3 音乐,当 ELF 文件运行起来以后可以读取这个段播放这首 MP3.但是应用程序自定义的段名不能使用 . 作为前缀,否则容易跟系统保留段名冲突.一个 ELF 文件也可以拥有几个相同段名的段.
*** 自定义段
GCC 提供了一个扩展机制,可以指定变量所处的段:
#+BEGIN_SRC c
/*
  在全局变量或函数前加上 __attribute__((section("name")))
  就可以把相应的变量或函数放到以 "name" 作为段名的段中
 ,*/
__attribute__((section("FOO")))  int global = 42;

__attribute__((section("BAR"))) void foo()
{
}
#+END_SRC
*** 链接的接口--符号
在链接中,目标文件之间的相互拼合实际上是目标文件之间对地址的引用, 即对函数和变量的地址的引用. 在链接中, 我们将函数和变量统称为 *符号(Symbol)*,函数名和变量名就是 *符号名(Symbol Name)*.
我们可以将符号看作是链接中的粘合剂,整个链接过程正是基于符号才能够正确完成.链接过程中很关键的一部分就是符号的管理,每一个目标文件都会有一个相应的 *符号表(Symbol Table)*,这个表里面记录了目标
文件中所用到的所有符号.每个定义的符号有一个对应的值,叫做符号值,对于变量合函数来说,符号值就是它们的地址.除了函数和变量之外,还存在其他几种不常用到的符号.将符号表中所有的符号进行分类,它们有可能是下面
这些类型中的一种:
- 定义在本目标文件的全局符号, 可以被其他目标文件引用.比如函数名,全局变量名.
- 在本目标文件中引用的全局符号,却没有定义在本目标文件,这一般叫做 *外部符号(External Symbol)*,也就是符号引用.比如外部函数名,外部变量名.
- 段名,这种符号由编译器产生,它的值就是该段的起始地址.
- 局部符号,这类符号只在编译单元内部可见.比如局部变量,内部静态变量,内部全局变量.调试器可以使用这些符号来分析程序或崩溃时的核心转储文件,
这些局部符号对于链接过程没有作用,连接器往往也忽略它们.
- 行号信息,即目标文件指令与与源代码中代码行的对应关系,它也是可选的.

链接过程中,最需要关心的就是全局符号的相互粘合, 局部符号,段名,行号等都是次要的,它们 *对于其他目标文件来说是不可见的*,在链接过程中也是无关紧要的.
符号表的查看使用命令 =readelf -s hello.o=
**** 符号表的结构
符号表往往是文件中的一个段,段名一般叫".symtab",它是由 =Elf32_Sym=结构组成的数组,每个结构对应一个符号.
对于此结构的部分元素作说明:
***** st_info(符号类型和绑定信息)
低4位表示符号类型(Symbol Type),高4位表示符号绑定信息(Symbol Binding).
*符号绑定信息*
| 宏定义名   | 值 | 说明                              |
|------------+----+-----------------------------------|
| STB_LOCAL  |  0 | 局部符号,对于目标文件的外部不可见 |
| STB_GLOBAL |  1 | 全局符号,外部可见                 |
| STB_WEAK   |  2 | 弱引用                               |
*符号类型*
| 宏定义名    | 值 | 说明                               |
|-------------+----+------------------------------------|
| STT_NOTYPE  |  0 | 未知类型符号                       |
| STT_OBJECT  |  1 | 该符号是个数据对象,比如变量,数组等 |
| STT_FUNC    |  2 | 该符号是个函数或其他可执行代码     |
| STT_SECTION |  3 | 该符号表示一个段,这种符号必须是 STB_LOCAL 的 |
| STT_FILE    |  4 | 该符号表示文件名,一般都是该目标文件所对应的源文件名,它一定是 STB_LOCAL 类型的,并且它的 st_shndx 一定是 SHN_ABS |
***** st_shndx(符号所在段)
如果符号定义在本目标文件中,那么这个成员表示符号所在的段在段表中的下标.但是如果符号不是定义在本目标文件中,或者对于有些特殊符号,如下所示:
| 宏定义名   |     值 | 说明                                                          |
|------------+--------+---------------------------------------------------------------|
| SHN_ABS    | 0xfff1 | 表示该符号包含了一个绝对值,比如表示文件名的符号就属于这种类型 |
| SHN_COMMON | 0xfff2 | 表示该符号是一个 COMMON 块类型的符号,一般来说未初始化的全局符号定义就是这种类型的, |
| SHN_UNDEF  |      0 | 表示该符号未定义,这个符号表示该符号在本目标文件被引用到,但是定义在其他目标文件中   |

***** st_value(符号值)
- 在目标文件中,如果是符号的定义并且该符号不是 "COMMON块"类型的,则表示该符号在段中的偏移.
即符号所对应的函数或变量位于由 =st_shndx= 指定的段,偏移 =st_value= 的位置,
- 在目标文件中,如果符号是 "COMMON块"类型的,则 =st_value= 表示该符号的对齐属性.
- 在可执行文件中,表示符号的虚拟地址.
**** 特殊符号
有些符号并没有在程序中定义,但是在链接脚本中定义了,所以在程序中依然可以使用.
*这些值在最终链接成可执行文件的时候将解析为正确的值*.
- __executable_start 程序的起始地址, *不是入口地址*,是程序最开始的虚拟地址
- __etext or _etext or etext  代码段最末尾的虚拟地址
- _edata or edata 数据段最末尾的虚拟地址
- _end or end 程序虚拟结束地址
**** 符号修饰与函数签名
为了避免用户写的代码中符号与库文件中符号名称有所冲突, UNIX下的 C 预言规定,C 语言源代码文件中的所有全局变量和函数经过编译后,相对应的符号名前加上下划线 "_".
而 fortan 语言的源代码经过编译后的符号名前后都要加上下划线 "_". *在现在* 的 Linux下的 GCC 编译器中,默认情况下已经去掉了C的下划线,但是 Windows 还保持这样的传统.
GCC 编译器可以通过参数选项 =-fleading-underscore= 或 =-fno-leading-underscore= 来打开和关闭是否在 C 语言加下划线.
***** C++ 符号修饰
为了支持 C++ 的特性, 发明了 *符号修饰(Name Decoration)或符号改编(Name Mangling)* 的机制.
函数签名包含了一个函数的信息,包括函数名,它的参数类型,它所在的类和名称空间及其他信息.函数签名用于识别不同的函数,就像签名用于识别不同的人一样,函数的名字只是函数签名的一部分.
在编译器及连接器处理符号时,它们使用某种 *名称修饰* 的方法,使得函数签名对应一个 *修饰后名称(Decorated Name)*.编译器在将 C++ 源代码编译成目标文件时,会将函数和变量的名字
进行修饰,形成符号名,所以不会有重复的名字.
GCC的基本C++名称修饰方法如下:所有的符号都以 "_Z"开头,对于嵌套的名字,后面紧跟 "N",然后是各个名称空间和类的名字,每个名字前是名字字符串的长度,再以 "E" 结尾.
比如 N::C::func 经过修饰后就是 =_ZN1N1C4funcE=. 对于一个函数来说,它的参数列表紧跟在 "E" 后面,对于 int 类型来说, 就是字母"i".所以以整个 N::C::func(int) 函数签名经过
修饰为 =_ZN1N1C4funcEi=.binutils 里面提供了一个叫 "c++filt" 的工具可以用来解析被修饰过的名称,比如 =c++filt _ZN1N1C4funcEi=.
签名和名称修饰机制不光被使用到函数上,C++中的全局变量和静态变量也有同样的机制.对于全局变量来说,它跟函数一样都是一个全局可见的名称,它也遵循上面的名称修饰机制. *值得注意的是*,
变量的类型并没有被加入到修饰后的名称中,所以不论这个变量是整形还是浮点型甚至是一个全局对象,它的名称都是一样的.
名称修饰机制也被用来防止静态变量的名字冲突.
不同的编译器厂商的名称修饰方法可能不同,所以不同的编译器对于同一个函数签名可能对应不同的修饰后名称.
***** extern "C"
c++代码中有可能会引用到 c 语言所提供的库函数,如果以c++的规则来修饰函数,那么到最终的链接过程便无法成功链接到 C的库函数中,导致编译失败.
通过使用 =extern "C"= 关键字用法,提醒编译器以 c 的规则来修饰.同时为了让一个头文件可以同时被 c 和 c++调用,需要使用 =__cplusplus= 宏来区分.
#+BEGIN_SRC C
#ifdef __cplusplus
extern "C" {
#endif
        void *memset(void *, int, size_t);
#ifdef __cplusplus
}
#endif
#+END_SRC
***** 弱符号与强符号
当使用强符号时(Strong Symbol),如果多个目标文件含有相同名字的全局符号定义，那么这些目标文件在链接的时候就会出现符号重复定义的错误。

对于c/c++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量未弱符号，也可以通过gcc =__attribute__((weak))= 来定义一个强符号为若符号。
#+BEGIN_SRC c
//既不是强符号，也不是弱符号，因为它是外部变量引用
extern int ext;

//弱符号
int weak;
//强符号
int strong = 1;
//弱符号
__attribute__((weak)) weak2 = 2;

//强符号
int main()
{
        return 0;
}
#+END_SRC
链接器按照下面的规则处理与选择被多次定义的全局符号：
- 不允许强符号被多次定义，否则报错
- 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号
- 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。

对外部目标文件的引用在目标文件链接时，如果没有找到符号定义，链接器就会报错，这种被称为 *强引用(Strong Reference)*.

在处理 *弱引用(Weak Reference)* 时，如果符号没有被定义则不会报错，将其值默认为0。

在gcc中使用 =__attribute__((weakref))= 来声明对一个外部函数的引用为弱引用。
#+BEGIN_SRC c
__attribute__((weakref)) void foo();

int main()
{
        if(foo) foo();
}
#+END_SRC



**** 调试信息
调试信息包含了源代码与目标代码之间的关系，比如行数，函数，变量的一一对应关系。

在GCC编译时加上 -g 参数就会增加调试信息到目标文件中。目标代码会生成很多 debug 段。

在linux中，使用 strip 命令去掉目标代码的调试信息：
#+begin_example
strip foo
#+end_example
** 静态链接
*** 空间与地址分配
**** 链接文件的分配策略
***** 按序叠加
简单粗暴的将各个目标文件的各个段按照顺序依次放入最终链接的文件。

此方法最大的缺点是会产生很多的零散段，各个文件的段有一定的地址和空间对齐要求，这会导致文件空间过大。会造成内存空间大量的内部碎片。
***** 相似段合并
将文件中相似的段组合在一起排列。这种链接方法更为合理，一般都采用两步链接的方法(Two-pass Linking).
- 第一步空间与地址分配：扫描所有的输入目标文件，获得它们各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。
合并所有输入目标文件，计算出输出文件中各个合并后的长度与位置，并建立映射关系。
- 第二步符号解析与重定位： 使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

*** 符号解析与重定位
**** 重定位
在完成空间和地址的分配步骤后，链接器就进入了符号解析与重定位的步骤。

为了能够让链接器知道哪些地址需要重定位，在目标文件中就会有一个重定位表。
对于每个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是一个ELF文件中的一个段，
所以重定位表也叫作重定位段。

比如代码段 ".text" 如有被重定位的地方，那么会有一个相对应的叫 ".rel.txt" 的段保存了代码段的重定位表。

使用命令 =objdump -r hello.o= 来查看重定位表。

每一个要被重定位的地方叫一个 *重定位入口(Relocation Entry)*.
**** 符号解析
重定位过程中也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定义的入口都是对一个符号的引用，
当链接器需要对某个符号的引用进行重定位时，它就需要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。

当链接器没有找到需要被重定位符号的对应绝对符号时，就会报错 =undefined reference to `***`=.

使用命令 =readelf -s hello.o= 来查看符号表
**** 指令修正方式
被重定位的地址修正具有绝对地址修正和相对地址修正：
- 绝对地址修正后的地址为该符号的实际地址
- 相对地址修正为符号距离被修正位置的地址差

*** COMMON 块
当编译器将一个编译单元编译成目标文件的时候，如果该编译单元包含了弱符号（未初始化的全局变量就是典型的弱符号），那么该弱符号最终所占用空间的大小在此是未知的，
因为有可能其他编译单元中该符号所占用的空间比本编译单元该符号所占的空间要大。所以编译器此时无法为该弱符号在BSS段分配空间，因为所需要空间的大小未知。但是链接器
在链接过程中可以确定弱符号的大小，因为当链接器读取所有输入目标文件后，任何一个弱符号的最终大小都可以确定了，所以它可以在最终输出文件的BSS段为其分配空间。
*所以总体来看，未初始化全局变量最终还是被放在BSS段的。*

GCC 的 =-fno-common= 允许我们把所有未初始化的全局变量不以 COMMON 块的形式处理，或者使用 =__attribute__= 扩展
#+BEGIN_SRC c
int global __attribute__((nocommon));
#+END_SRC

*** 节省输出文件的大小
GCC编译器中提供了编译选项 =-ffunction-sections= 和 =-fdata-sections= ，作用是将每个函数或变量分别保持到独立的段中，
这样链接器在链接时只将最终代码用到的函数和数据链接进输出文件中去，减小输出文件的大小。但由于编译的分段操作和链接的查询操作，
使得最终生成输出文件的时间会比普通方式增加不少。
*** 静态库链接
静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。

在linux中通过使用 =ar= 程序将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了 libc.a 这种静态库。

- 使用 =ar -t libc.a= 来查看 libc.a 库中包含了哪些目标文件。
- 使用 =objdump= 或 =readelf= 加上 =grep= 就能够找到调用的函数属于库中的哪个目标文件。
*** 链接过程控制
对于一些特殊需求的情况下（比如嵌入式），需要指定链接地址以控制代码的运行过程。
**** 链接控制脚本
链接器有如下三种方法来控制链接过程：
- 使用命令行来给链接器指定参数。（比如使用 ld -o）
- 将链接指令存放在目标文件里面，编译器经常会通过这种方法向链接器传递指令
- 使用链接控制脚本（最为灵活而强大）。

当不指定链接脚本时，ld 使用默认脚本，使用命令 =ld -verbose= 打印出默认的链接脚本。
**** ld 链接脚本语法简介
链接脚本由一系列语句组成，语句分为两种，一种是 *命令语句* ，另外一种是 *赋值语句* 。
链接脚本语法与 C 语言有如下相似之处：
- 语句之间使用分号 ";" 作为分割符。
  + 命令语句可以使用换行来结束该语句
  + 赋值语句必须以 ";" 结束。
- 脚本语言可以使用C语言类似的表达式和运算操作符。比如 "+,-,*,/,+=,-=,*=,&,|,>>,<<"
- 注释和字符引用。 使用 =/**/= 作为注释。脚本文件中使用到的文件名、格式名、段名等凡是包含 ";"或其他的分隔符的，都要使用双引号将该名字全称引用起来，如果文件名包含引号则无法处理。

| 常用的命令语句       | 说明                                               |
|----------------------+----------------------------------------------------|
| ENTRY(symbol)        | 指定 symbol 的值为入口地址。                       |
| STARTUP(filename)    | 将文件 filename 作为链接过程中的第一个输入文件     |
| SEARCH_DIR(path)     | 将路径　path 加入到链接器的库查找目录              |
| INPUT(file,file,...) | 将指定文件作为链接过程中的输入文件                 |
| INCLUDE filename     | 将指定文件包含进本链接脚本，类似于　#include       |
| PROVIDE(symbol)      | 在链接脚本中定义某个符号。该符号可以在程序中被引用 |

***** SECTIONS 命令
#+begin_example
SECTIONS
{
  ...
  /*
  符合　contents 中的规则的输入文件段将合并到输出文件段 secname 中

　注意：secname 后面要跟空格。　
  ,*/
  secname : {contents}
  ...
}
#+end_example
contents 中可以包含若干个条件，每个条件之间以空格隔开，如果输入段符合这些条件中的任意一个即表示这个输入段符合　contents 规则。

条件写法为： =filename(sections)=
- file1.o(.data) 表示file1.o文件中名为　.data 的段符合条件
- file1.o(.data .rodata) 或　file1.o(.data, .rodata) 表示file1.o文件中的　.data或.rodata段符合条件
- file1.o 如果直接指定文件名而省略后面的小括号和段名，则代表所有段都符合条件
- *(.data) 所有文件中的　.data 段符合条件
- [a-z]*(.text*[A-Z]) 所有输入文件中以小写字母a到z开头的文件中的所有段名以.text开头，并且以A到Z结尾的段，符合条件。

