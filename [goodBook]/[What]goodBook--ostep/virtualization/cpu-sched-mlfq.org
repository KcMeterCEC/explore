#+TITLE: [What]Scheduling:The Multi-Level Feedback Queue
#+DATE: <2019-08-12 一> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,ostep
#+NAME: <book_ostep_cpu-sched-mlfq.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

理解调度策略中的 *多级反馈队列（Multi-level Feedback Queue, MLFQ）* 。

MLFQ 的目的就是要尽量实现很短的轮转时间和响应时间。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 基础规则
MLFQ 具有多个独立的队列，每个队列代表着不同的优先级。

任务根据不同的优先级而被放入不同的队列：
- 高优先级队列中的任务先运行
- 相同优先级的任务采用 round-robin 策略分时轮询调度
  
MLFQ 自动的为任务分配优先级（根据任务的行为而预测）：
- 当一个任务是 IO 密集型（占用的 CPU 时间少）时， 会提高其优先级
  + 因为这样可以提高任务的响应速度，用户体验好
- 当一个任务是 CPU 密集型（占用的 CPU 时间多）时， 会降低其优先级
  + 因为 IO 密集型占用 CPU 时间少，所以要让它先执行，更多的时间会留给 CPU 密集型。
    
** 优先级更改细则
*** 普通策略
- 当任务被创建时，它被默认放置在最高优先级队列，此时最高优先级队列使用 RR 策略轮询调度
- 当一个任务完整的使用了调度的时间片，那么降低其优先级
  + 这意味着被调度过程中没有进行 IO 操作，属于 CPU 密集型且执行时间较长
- 当一个任务在时间片耗尽之前就主动放弃了 CPU，那么保持其优先级
  + 属于 IO 密集型或任务本身执行时间就短

此调度策略具有一下不足：
1. 如果当前有很多的 IO 密集型任务，那么就需要轮询调度它们，这样低优先级的 IO 密集型任务便会被饿死（starve）
2. 如果某个 IO 密集型任务做的 IO 时间很短，而占用了 99% 的时间片时间。按照当前策略也不会降低其优先级，
最终的结果就是此任务占用了绝大部分 CPU 时间，低优先级任务每次运行时间极短。
3. 某些任务很可能会根据当前运行状态的不同，时而是 CPU 密集型，时而是 IO 密集型。那么当它是 IO 密集型时，
这部分的响应时间就极长（因为当它为 CPU 密集型时其优先级已经被降低了）

