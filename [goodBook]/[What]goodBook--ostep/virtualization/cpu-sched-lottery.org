#+TITLE: [What]Scheduling: Proportional Share
#+DATE: <2019-08-20 二> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,ostep
#+NAME: <book_ostep_cpu-sched-lottery.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

学习比例分配调度器，其核心思想是：保证每一个任务获得 *确定比例* 的 CPU 使用时间。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* tickets 表示一个任务所占用的 CPU 百分比
比例分配调度器随机的切换多个任务，在全局上来看让其符合其所要求的百分比。
- 这种方式使得调度器的实现相对轻量级

比例分配调度器具有如下特点：
- 比例分配调度器可以站在更为宏观的角度来分配各个任务占用 CPU 的百分比，看到这里感觉和 Linux 下的 cgroup 很像。
#+BEGIN_EXAMPLE
  比如有用户 A 和 B，比例分配调度器为他们各分配了 100 个 ticket。

  在用户 A 内部使用了 1000 个 ticket，它为其任务 A1 和 A2 各分配 500 个 ticket。
  在用户 B 内部使用了 10 个 ticket，且只有一个任务。

  最终，比例分配调度器会给任务 A1 和 A2 各 50 个 ticket，给任务 B 100 个 ticket，
  所以 B 任务占用的 CPU 资源更多。
#+END_EXAMPLE
- 比例分配调度器可以将一个任务的 tickets 传送给另一个任务，这在 C/S 架构下很有作用。
#+BEGIN_EXAMPLE
  比如客户端向服务端发送了一个请求，客户端希望服务端可以尽快的处理完此请求。

  那么客户端可以将它所拥有的 tickets 发送给服务端，服务端便可以获得更多的 CPU 资源而完成得更快。

  当服务端完成此请求以后，再将客户端的 tickets 归还。
#+END_EXAMPLE
- 每个任务都可以动态的调整其 tickets
#+BEGIN_EXAMPLE
  当一个 group 的多个任务协调工作时，其中一个任务需要短暂的占用更多的 CPU 资源，
  那么它可以主动提升其 tickets。
#+END_EXAMPLE
* 执行过程
比例分配调度器的调度算法极为简单：
1. 将任务都挂在一个链表中，每个任务都有其对应的 ticket，这些任务的 ticket 求和得 A
2. 使用随机数发生器使得其产生一个在 A 内的值
3. 使用计数器从 0 开始依次与每个任务相加，当计数器的值大于随机数时，便调用当前任务
#+BEGIN_SRC c
  // counter: used to track if we’ve found the winner yet
  int counter = 0;

  // winner: use some call to a random number generator to
  // get a value, between 0 and the total # of tickets
  int winner = getrandom(0, totaltickets);

  // current: use this to walk through the list of jobs
  node_t *current = head;
  while (current) {
    counter = counter + current->tickets;
    if (counter > winner)
      break; // found the winner
    current = current->next;
   }
  // ’current’ is the winner: schedule it...
#+END_SRC

为了提高调度器的效率，可以根据任务的 ticket 进行排序，ticket 值大的在前面，这是为了使计数器循环尽量少的次数。

* 另一种思路
按照前面的调度策略，在短时间内实际上是无法达到每个任务所要求的比例的，
为此先驱们使用 stride 和 pass 来共同决定一个任务什么时候该被运行，以求达到公平。
- stride : 每个任务执行的计数步进
- pass : 每个任务独有的总的运行计数

其调度原则是：调度 pass 值最小的那个任务
- 因为这以为着那个任务被分配的时间太少了
#+BEGIN_SRC c
  curr = remove_min(queue); // pick client with min pass
  schedule(curr); // run for quantum
  curr->pass += curr->stride; // update pass using stride
  insert(queue, curr); // return curr to queue
#+END_SRC

假设任务 A、B、C 的 ticket 依次为 100,50,250，以 10000 除以这些值得出它们的 stride 依次为：
100、200、40。

这样可以画出一个调度表：
| Pass(A) (stride = 100) | Pass(B)(stride = 200) | Pass(C)(stide = 40) | 当前运行 |
|------------------------+-----------------------+---------------------+----------|
|                      0 |                     0 |                   0 | A        |
|                    100 |                     0 |                   0 | B        |
|                    100 |                   200 |                   0 | C        |
|                    100 |                   200 |                  40 | C        |
|                    100 |                   200 |                  80 | C        |
|                    100 |                   200 |                 120 | A        |
|                    200 |                   200 |                 120 | C        |
|                    200 |                   200 |                 160 | C        |
|                    200 |                   200 |                 200 | ...      |

可以看到 A、B、C 的运行次数依次为 2、1、5,这已经很接近之前分配的 ticket 值了。

*需要注意的是：* 虽然这种调度策略看上去很公平，但如果中途插进来一个新任务，那么它的 pass 值为 0,
它会占用 CPU 很长时间。

所以综合来看，还是随机数的调度策略更为合理，因为它比较的是增量而不是绝对量。
* Linux 中的 CFS 调度器
Linux 下的 CFS（Completely Fair Scheduler，完全公平调度器）在[[http://kcmetercec.top/2018/05/26/linux_ps_schedule/#org384066f][进程课程]]中有所了解，具有极高的切换效率且满足 IO 密集和 CPU 密集型的协调。

Linux 使用虚拟时间（virtual runtime，vruntime）来表示一个任务所占有的 CPU 资源：
- 当任务在运行时，它的 vruntime 就会累加
- 调度器调度 vruntime 最小的那一个任务
