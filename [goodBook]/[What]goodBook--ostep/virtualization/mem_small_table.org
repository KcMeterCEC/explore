#+TITLE: [What]Paging:Smaller Tables
#+DATE: <2020-03-18 三> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,ostep
#+NAME: <book_ostep_vm-smaller_tables.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

当只有一级页表时，页表本身所占用的空间就会很大，而多级页表可以解决这个问题。
#+BEGIN_EXAMPLE
  假设页块大小为 4KB，那么对于 32 位系统来说，一个进程需要映射到 1048576 个页块。

  一个页表项为 4 字节，那么一个进程的页表就是 4*1048576 = 4MB。

  假设一个系统中运行了 1000 个进程，那么页表总共就要占用 4000 MB，这显然是无法使用的。
#+END_EXAMPLE

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* 简易办法：使用大页
如果我们简单粗暴的将页块大小规定为 16 KB，那么对应的页块数量就只有原来的四分之一，最终一个进程的页表就只有 1MB 大小。

但是这样会造成内存的浪费，因为即使每次仅申请几个字节，操作系统也会分配一个页块。
* 进阶方案：页和段
一个进程的虚拟地址空间会映射到整个 32 位地址空间，然而实际上真正映射到物理地址的页表项很少。
也就是说绝大多数的页表项都处于 invalid 的状态，那么这些页表项本身浪费了很多物理内存空间。

所以我们可以先将虚拟地址分为多个段，然后再段内进行页表映射，而段外的部分就全部是 invalid 的状态，并且不会占用更多的物理内存空间。

[[./mempic/smalltb/seg_page.jpg]]

如上图所示，该进程总共只使用了 4 页，而其它页表项所占用的内存就全部浪费了。
所以可以将 code,heap,stack 分为 3 个段，就可以节约其他页表项所占用的内存了。

为了达到此目的，需要具备以下两个条件：
1. 每个段都具有其对应的段基地址，其实也就是这个段中起始页的基地址
2. 对应每个段需要有个限制寄存器，以表明该段的范围是多大，也就是这个段中终止页的地址

为了表示 3 个段，就需要 2 位来存储，然后是该段内的页块偏移，最后是页内偏移。
那么对于一个 32 位地址空间来说，其虚拟地址划分如下：
[[./mempic/smalltb/seg_page_vir_addr.jpg]]

通过虚拟地址得到页表项的逻辑如下：
#+BEGIN_EXAMPLE
  SN           = (VirtualAddress & SEG_MASK) >> SN_SHIFT
  VPN          = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
  AddressOfPTE = Base[SN] + (VPN*sizeof(PTE))
#+END_EXAMPLE

这种方式虽然看上去节约了不少内存，但是依然具有下面这个问题：
- 硬件复杂：原来仅需要 1 个页表基地址寄存器就能搞定的事，现在需要多个段基地址寄存器和范围限制寄存器
- 依然会有内存浪费：当一个段中所申请的页是随机分布时，依然在该段中会有很多页表项用不上
* 多级页表
多级页表是将页表结构由原来的一层分多多层，从最开始的大页查找到小页。

这里的关键点在于：如果一段内存没有被映射，那么大页里面就设置为 invalid，而后其下级的小页就不需要占据物理内存空间了。
 
[[./mempic/smalltb/pagetlb_overview.jpg]]
