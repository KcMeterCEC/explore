#+TITLE: [What]Complete Virtual Memory Systems
#+DATE: <2020-04-03 五> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,ostep
#+NAME: <book_ostep_vm-complete-system.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

现在再来以全局的方式看虚拟内存空间。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* VAX/VMS 的虚拟内存
** 内存管理的硬件
*** 虚拟内存与物理内存的关系
VAX-11 架构使用 32 位虚拟地址空间，页大小为 512 字节，也就是说地址的低 9 位是页内偏移。

23 位中的高两位用于将地址空间平均分为 4 段，用于表示每一段中是否有驻留内存，这是一种节省页表项占用空间的策略。
*** 虚拟内存的划分
VAX 将虚拟内存划分为两半：
- 第一半是进程空间（process space），当然每一个进程的这部分内容是不一样的，这部分又分为两半
  + 低半用于存放只读的用户代码和堆，堆是向下增长的。
  + 高半是用于存放栈，栈是向上增长的
- 第二半是系统空间，存放系统的代码和数据，这部分对于各个进程是共享的
*** VMS 的处理
由于硬件页大小仅仅 512 字节，假设只有一级页表的话，每个进程对应的页表项需要 32MB，这实在是太大了。

VMS 对此使用了以下两种方式：
- 将用户空间分为两段，每段单独使用一个页表。硬件提供了页表基地址和页表的大小，那么在栈和堆中没有被用到的部分就不用为它分配页表项了，也就节约了内存。
- 将用户空间的两段页表存放于内核空间中，当页表过大时，内核将其置换到硬盘以保证足够的物理内存空间。

由于用户空间的页表存放在内核空间中，虚拟地址到物理地址的转换变得更为繁琐：
- 当用户空间（虚拟地址）发起内存访问时，MMU 首先需要获取内核空间的页表基地址（物理地址）
- 根据内核页表基地址（物理地址）和用户空间的页表存放地址（虚拟地址），得到用户空间页表基地址（物理地址）
- 再根据用户空间页表基地址（物理地址）和用户空间的访问地址（虚拟地址）得到这段物理地址
- 根据得到的物理地址进行访问
  
也就是说上面这种转换比平常的转换多了一级转换：从内核页表得到用户页表的基地址
*** 真实的地址空间





