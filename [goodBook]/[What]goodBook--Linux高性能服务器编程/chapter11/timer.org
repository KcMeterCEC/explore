#+TITLE: [What]Linux 定时器
#+DATE: <2019-12-10 二> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,Linux高性能服务器编程
#+NAME: <book_linux_server_chapter_11.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

在用户空间很少用定时器，再来加深一下理解。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
Linux 提供了 3 种定时方法：
1. socket 选项 SO_RECVTIMEO 和 SO_SNDTIMEO
2. SIGALRM 信号
3. I/O 复用系统调用的超时参数
* socket 选项 SO_RECVTIMEO 和 SO_SNDTIMEO
SO_RECVTIMEO 和 SO_SNDTIMEO 分别对应设置接收和发送超时。

| 系统调用 | 有效选项    | 系统调用超时后的行为                        |
|----------+-------------+---------------------------------------------|
| send     | SO_SNDTIMEO | 返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK |
| sendmsg  | SO_SNDTIMEO | 返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK |
| recv     | SO_RCVTIMEO | 返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK |
| recvmsg  | SO_RCVTIMEO | 返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK |
| accept   | SO_RCVTIMEO | 返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK |
| connect  | SO_SNDTIMEO | 返回 -1，errno 的值为 EINPROGRESS           |

如下所示为 socket 使用 =connect= 超时后的效果：
#+BEGIN_SRC c
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <stdlib.h>
  #include <assert.h>
  #include <stdio.h>
  #include <errno.h>
  #include <fcntl.h>
  #include <unistd.h>
  #include <string.h>

  int main(int argc, char *argv[])
  {
      int ret = 0;
      if(argc != 3)
      {
          printf("usage: %s <ip> <port>\n", argv[0]);

          return -1;
      }

      const char *ip = argv[1];
      int port = atoi(argv[2]);

      struct sockaddr_in address;

      memset(&address, 0, sizeof(address));
      address.sin_family = AF_INET;
      inet_pton(AF_INET, ip, &address.sin_addr);
      address.sin_port = htons(port);

      int sock_fd = socket(address.sin_family, SOCK_STREAM, 0);
      assert(sock_fd > 0);

      struct timeval timeout;

      timeout.tv_sec = 5;
      timeout.tv_usec = 0;
      socklen_t len = sizeof(timeout);

      ret = setsockopt(sock_fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, len);
      assert(ret == 0);

      ret = connect(sock_fd, (struct sockaddr *)&address, sizeof(address));
      if(ret == -1)
      {
          if(errno == EINPROGRESS)
          {
              printf("connecting timeout\n");
              return -1;
          }
          perror("connect failed:");

          return -1;
      }

      return 0;
  }
#+END_SRC
* sigalrm 信号
* I/O 复用系统调用的超时参数
* 高性能定时器
