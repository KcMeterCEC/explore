#+TITLE: [What]Linux 网络编程基础 API
#+DATE: <2019-11-06 三> 
#+TAGS: CS
#+LAYOUT: post
#+CATEGORIES: book,Linux高性能服务器编程
#+NAME: <book_linux_server_chapter_5.org>
#+OPTIONS: ^:nil
#+OPTIONS: ^:{}

APUE 对网络编程 API 都有详细的解释，现在再来回顾一下。
#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT
* socket 地址
** 主机字节序和网络字节序
根据数据存储顺序分为大端字节序（ big endian）和小端字节序（little endian），下面代码可以判断字节序。
#+BEGIN_SRC c
  #include <stdio.h>

  int main(int argc, char *argv[])
  {
    int num = 0x12345678;
    char *byte = (char *)&num;

    if(*byte == 0x78)
      {
        printf("It's little endian\n");
      }
    else
      {
        printf("It's big endian\n");
      }

    return 0;
  }
#+END_SRC

为了计算机通信数据正确，那必然要约定一致的字节序：
- 主机字节序：目前大多 CPU 使用小端字节序，所以又被称为主机字节序
- 网络字节序：网络通信规定为大端字节序，也就是说发送和接收方都需要以大端字节序发送和接收
  
*注意：* 即使同一台机器上运行的由不同语言编写的进程，也有可能是不同字节序，所以需要有良好的编程习惯。
- JAVA 虚拟机统一采用大端字节序
  
Linux 提供了如下函数完成主机字节序和网络字节序的转换：
#+BEGIN_SRC c
  #include <arpa/inet.h>

  //host to network long
  uint32_t htonl(uint32_t hostlong);

  uint16_t htons(uint16_t hostshort);

  uint32_t ntohl(uint32_t netlong);

  uint16_t ntohs(uint16_t netshort);
#+END_SRC
使用以上函数的场景有：
1. 设置 IP 地址时，使用 32 位转换
2. 设置端口号时，使用 16 位转换
3. 发送格式化数据时，使用对应转换
** 通用 socket 地址
=sockaddr= 表示 socket 地址：
#+BEGIN_SRC c
  #include <sys/socket.h>

  typedef unsigned short int sa_family_t;

  struct sockaddr {
    sa_family_t sa_family;
    char        sa_data[14];
  }
#+END_SRC   
=sa_family= 表示地址族，这个与协议族有对应关系：
| 协议族   | 地址族   | 描述              | sa_data 含义                                       |
|----------+----------+-------------------+----------------------------------------------------|
| PF_UNIX  | AF_UNIX  | UNIX 本地域协议族 | 文件路径名，最长 108 字节                          |
| PF_INET  | AF_INET  | TCP/IPv4 协议族   | 16 位端口号和 32 位地址                            |
| PF_INET6 | AF_INET6 | TCP/IPV6 协议族   | 16 位端口号，32 位流标识，128 位地址，32 位范围 ID |

#+BEGIN_SRC c
  /* Protocol families.  */
  #define PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
  #define PF_UNIX		PF_LOCAL /* POSIX name for PF_LOCAL.  */
  #define PF_INET		2	/* IP protocol family.  */
  #define PF_INET6	10	/* IP version 6.  */

  /* Address families.  */
  #define AF_UNIX		PF_UNIX
  #define AF_INET		PF_INET
  #define AF_INET6	PF_INET6
#+END_SRC

从上面定义可以看出它们的值是一样的，只是为了更好编码规范，需要根据当前对象使用对应的宏。

仅仅用 =sockaddr= 中的 =sa_data= 并不能完全容量多种协议族的地址值，Linux 为此定义了 =sockaddr_storage= ：
#+BEGIN_SRC c
  /* Structure large enough to hold any socket address (with the historical
     exception of AF_UNIX).  */
  #define __ss_aligntype	unsigned long int
  #define _SS_PADSIZE                                             \
    (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))

  struct sockaddr_storage
  {
    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
    char __ss_padding[_SS_PADSIZE];
    __ss_aligntype __ss_align;	/* Force desired alignment.  */
  };
#+END_SRC
** 专用 socket 地址
上面的通用地址结构体是以字节的方式格式化存储地址，这并不编译代码操作。

所以 Linux 为各个协议族提供了专门的 socket 地址结构体：
#+BEGIN_SRC c
  #define	__SOCKADDR_COMMON(sa_prefix)            \
    sa_family_t sa_prefix##family

  /* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
  struct sockaddr_un
  {
    __SOCKADDR_COMMON (sun_);
    char sun_path[108];		/* Path name.  */
  };

  /* Internet address.  */
  typedef uint32_t in_addr_t;
  struct in_addr
  {
    in_addr_t s_addr;
  };

  /* IPv6 address */
  struct in6_addr
  {
    union
    {
      uint8_t	__u6_addr8[16];
    } __in6_u;
  #define s6_addr			__in6_u.__u6_addr8
  };

  /* Structure describing an Internet socket address.  */
  struct sockaddr_in
  {
    __SOCKADDR_COMMON (sin_);
    in_port_t sin_port;			/* Port number.  */
    struct in_addr sin_addr;		/* Internet address.  */

    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
                           __SOCKADDR_COMMON_SIZE -
                           sizeof (in_port_t) -
                           sizeof (struct in_addr)];
  };

  /* Ditto, for IPv6.  */
  struct sockaddr_in6
  {
    __SOCKADDR_COMMON (sin6_);
    in_port_t sin6_port;	/* Transport layer port # */
    uint32_t sin6_flowinfo;	/* IPv6 flow information */
    struct in6_addr sin6_addr;	/* IPv6 address */
    uint32_t sin6_scope_id;	/* IPv6 scope-id */
  };
#+END_SRC

这样在编程设置地址参数时就可以使用这些结构体，最后在调用对应函数时强制转换为 =sockaddr= 即可。
** IP 地址转换函数
为了提高编程的可读性，Linux 提供了字符串方式地址到二进制地址的相互转换函数：
#+BEGIN_SRC c
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>

  //将以字符串表示的 IPv4 地址转换为网络字节序的整数并存储于 inp 中
  int inet_aton(const char *cp, struct in_addr *inp);
  //将以字符串表示的 IPv4 地址转换为网络字节序的整数
  in_addr_t inet_addr(const char *cp);

  //将网络字节序的整数地址转换为字符串表示的 IPv4 地址
  //此函数返回指向静态内存，所以其不可重入
  char *inet_ntoa(struct in_addr in);

  //将以字符串表示的 IPv4 或 IPv6 地址转换为网络字节序，并存储于对应的地址结构体中
  int inet_pton(int af, const char *src, void *dst);
  //将网络字节序的整数地址转换为字符串表示的 IPv4 或 IPv6 地址，size 指定转换的大小
  //IPv4 大小至少为 INET_ADDRSTRLEN
  //IPv6 大小至少为 INET6_ADDRSTRLEN
  const char *inet_ntop(int af, const void *src,
                        char *dst, socklen_t size);

#+END_SRC
* 创建 socket
Linux 提供了 =socket= 函数来创建一个 socket 对象：
#+BEGIN_SRC c
  #include <sys/types.h>          /* See NOTES */
  #include <sys/socket.h>

  int socket(int domain, int type, int protocol);
#+END_SRC
- =domain= 指定底层协议族
  + =AF_INET= 表示 IPv4， =AF_INET6= 表示 IPv6， =AF_UNIX,AF_LOCAL= 表示 UNIX 本地协议族
- =type= 指定服务类型，对于 =TCP= 协议则设置为 =SOCK_STREAM= (流服务)，对于 =UDP= 协议则设置为 =SOCK_DGRAM= （数据报服务）
  + 以上参数可以与 =SOCK_NONBLOCK= （非阻塞）和 =SOCK_CLOEXEC= （用 fork 调用创建子进程时，子进程关闭该 socket）相与
- =protocol= 表示具体的协议，一般前两个值都已经决定了协议的唯一性，一般设 0 表示使用默认协议。
* 命名 socket
将一个 socket 与 socket 地址绑定称为给 socket 命名。

在服务器程序中，通常要命名 socket，只有命名后客户端才能知道如何连接它。
而在客户端中，通常不需要命名，采用系统自动分配的地址即可。

#+BEGIN_SRC c
  #include <sys/types.h>
  #include <sys/socket.h>

  //将 addr 所指的地址分配给未命名的 sockfd 文件描述符
  int bind(int sockfd, const struct sockaddr *addr,
           socklen_t addrlen);
#+END_SRC
* 监听 socket
将 socket 命名之后，需要创建一个监听队列存放待处理的客户端连接：
#+BEGIN_SRC C
  #include <sys/types.h> 
  #include <sys/socket.h>
  //创建一个以 sockfd 对应的最大长度为 backlog 的监听队列
  int listen(int sockfd, int backlog);
#+END_SRC
=backlog= 表示处于完全连接状态的 socket 的上限，半连接的上限由 =/proc/sys/net/ipv4/tcp_max_syn_backlog= 指定。

*需要注意的是：backlog 代表可连接最大长度减一* ，比如 backlog 设置为 5，代表最多可以连接 6 个客户端

使用 =telnet= 连接下面代码的服务端，并用 =netstat -nt | grep <port>= 的方式查看状态便可验证：
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <arpa/inet.h>
  #include <netdb.h>
  #include <stdio.h>
  #include <unistd.h>
  #include <string.h>
  #include <stdlib.h>
  int main(int argc, char *argv[])
  {
      if(argc != 3)
      {
          printf("usage: %s : <port> <backlog>\n", argv[0]);

          return -1;
      }
      int port = atoi(argv[1]);
      int backlog = atoi(argv[2]);
      //设置地址
      struct sockaddr_in sockaddr;

      sockaddr.sin_family = AF_INET;
      sockaddr.sin_port = htons(port);
      sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
      //新建 socket
      int socket_fd = socket(sockaddr.sin_family, SOCK_STREAM, 0);
      if(socket_fd <= 0)
      {
          perror("create socket failed!\n");
          return -1;
      }
      //socket 命名
      if(bind(socket_fd, (const struct sockaddr *)&sockaddr,sizeof(sockaddr)) < 0)
      {
          perror("can't bind socket and addr.\n");
          return -1;
      }
      //开始监听
      if(listen(socket_fd, backlog) < 0)
      {
          perror("listen failed!\n");
          return -1;
      }

      while(1)
      {
          sleep(1);
      }

      return 0;
  }
#+END_SRC
* 接受连接
所谓的接受连接，是指从监听队列中取出一个 client 连接的节点，然后处理。
- accept 不会判断当前连接处于何种状态（比如客户端异常断开）

#+BEGIN_SRC C
  #include <sys/types.h>          /* See NOTES */
  #include <sys/socket.h>

  //从 sockfd 对应的监听队列中取出一个监听 socket 赋值给 addr
  //返回一个新连接 socket 的标识
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
#+END_SRC
* 发起连接
客户端通过 =connect= 来主动发起连接：
#+BEGIN_SRC C
  #include <sys/types.h>          
  #include <sys/socket.h>

  //将 sockfd 与 addr 指向的地址进行连接
  int connect(int sockfd, const struct sockaddr *addr,
              socklen_t addrlen);
#+END_SRC
* 关闭连接
关闭连接可以使用 =close= 和 =shutdown= :
#+BEGIN_SRC C
  #include <unistd.h>

  //将 fd 引用计数减一，只有当计数为 0 时才真正关闭连接，在父子进程中需要注意
  int close(int fd);

  #include <sys/socket.h>

  //立即以 how 的方式关闭 sockfd
  //how : SHUT_RD -> 关闭读 SHUT_WR -> 关闭写 SHUT_RDWR -> 全关闭
  int shutdown(int sockfd, int how);
#+END_SRC
* 数据读写
** TCP 数据读写
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <sys/socket.h>

  ssize_t send(int sockfd, const void *buf, size_t len, int flags);
  ssize_t recv(int sockfd, void *buf, size_t len, int flags);
#+END_SRC 

需要明白的是：由于 TCP 是流数据通信，很可能 =recv= 所返回的实际读取长度小于需求的长度，所以需要多次调用 =recv= 才能得到完整的数据。

flags 常用的取值如下：
| 选项名      | 含义                                                                            | send | recv |
|-------------+---------------------------------------------------------------------------------+------+------|
| MSG_CONFIRM | 仅用 SOCK_DGRAM,SOCK_RAW 类型，指示数据链路层协议持续监听对方回应，直到得到答复 | Y    | N    |
|             |                                                                                 |      |      |
* 带外标记
* 地址信息
* socket 选项
* 网络信息
