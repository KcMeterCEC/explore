* 程序员的自我休养 --> 链接装载与库
这是 <<程序员的自我休养 --> 链接装载与库>> 的读书笔记.

** 预备知识

*** 北桥芯片与南桥芯片
北桥芯片 (North bridge), 是为了使 CPU,RAM,显卡这种高速设备通信而实现的.而相应的南桥芯片(South bridge)就是为了协调各个低速设备而实现的,最终南桥与北桥通信,实现协调.

*** SMP与多核
对称多处理器 (SMP, Symmetrical Multi-Processing),是说一个计算机主板上具有多个 CPU,可以完全并行的处理任务.比如很多服务器上就具有多个强悍的 CPU.

多核 (MP, Multi-core Processor),是说在一个 CPU 上集成了多个核心, 核心之间共享缓存,比如 zynq 集成了一个双核心的 cortexA9.

*** 接口
一个复杂的软件系统,都是由各个软件层一层层组合起来的.也正是由于分层的特性,使得各个层内部的改变并不会引起其他层的改变.越往上层就越具有移植性.
与硬件息息相关的就是操作系统的,作为操作系统程序员需要考虑驱动的编写和系统底层的移植.

*** 挖掘计算机硬件的潜力
**** 操作系统调度
操作系统接管了所有的硬件资源,并且本身运行在一个受硬件保护的级别.所有的应用程序都以进程 (Process) 的方式运行在比操作系统权限更低的级别,每个进程都有自己独立的地址空间.
使得进程之间的地址空间相互隔离.CPU 由操作系统统一进行分配,每个进程根据优先级的高低都有机会得到 CPU,但是如果运行时间超出了一定的时间,每个进程根据进程优先级的高低都有机会
得到 CPU, 但是如果运行时间超出了一定的时间,操作系统会暂停改进程,将 CPU 资源分配给其他等待运行的进程.这种 CPU 的分配方式即所谓的抢占式 (Preemptive),操作系统可以强制剥夺
CPU 资源并且分配给它认为目前最需要的进程.

**** 设备驱动
操作系统提供了一些统一的接口,设备驱动满足这些接口便可以被系统调用.

**** 内存管理 
通过 MMU(Memory Management Unit) 的 *虚拟内存* *分页* *权限* 等特性,使得用户代码运行空间相对独立并且安全而且效率更高,同时也可以运行更多的进程.

**** 线程
     多个线程通过共享进程空间,以及各个线程的优先级方式使 CPU 的利用率更高.     
** 编译和链接

*** 预处理
在gcc中,内部调用的预处理器叫做 cpp ,将 c 文件预处理为 .i 文件, 将 cpp 文件预处理为.ii文件.
gcc 使用 -E 选项来指明只需要进行预处理. =gcc -E hello.c -o hello.i=,也可以使用 cpp 来完成.
预处理过程主要处理规则如下:
- 将所有的 "#define" 删除,并且展开所有的宏定义,使用的是直接替换原则
- 处理所有的条件预编译指令,比如 "#if" "#elif" "#else" "#endif"等等
- 处理 "#include" 预编译指令,将被包含的文件在此处展开,如果被包含文件也包含了其他文件,那么层层展开
- 删除所有的注释
- 添加行号和文件名标识,比如 =#2 "hello.c" 2= ,以便于编译时产生调试用的行号信息,以及用于编译时产生编译错误或警告时能够显示行号
- 保留所有的 =#pragma= 编译指令,用于后面的编译过程.
通过以上规则,可以知道其中的一个调试方法是查看预编译后的文件,可以避免调一些干扰,也可以看到真实的宏定义结果.

*** 编译
编译的过程就是把预处理完的文件进行一系列的词法分析,语法分析,语义分析以及优化后生成相应的汇编代码文件.
在gcc中,将从预编译到编译使用命令 =gcc -S hello.i -o hello.s=,也可以使用 cc1 来完成预处理和编译.

编译过程一般可以分为6步:扫描,语法分析,语义分析,源代码优化,代码生成,目标代码优化.
**** 扫描器(词法分析)
源代码程序首先被输入到 *扫描器(Scanner)*,扫描器的任务很简单,只是简单的进行词法分析,运用一种类似于 *有限状态机(Finite State Machine)* 可以很轻松的将源代码的 *非空格字符* 序列分割成一系列的 *记号(Token)*.说简单点就是把各个小字符提取成一张表.这一过程和[[https:github.com/KcMeterCEC/tools/tree/master/shell%5D%5D][简易命令行shell]] 的扫描命令内容过程很相似.
词法分析产生的记号一般可以分为如下几类:关键字,标识符,字面量(数字,字符串等)和特殊符号(加号,等号等)在识别记号的同时,扫描器也完成库其他工作,比如将标识符存放到符号表,将数字,字符串常量存放到文字表等.

扫描器的程序工具叫做 *lex*.

**** 语法分析(Grammar Parser)
对扫描器产生的记号进行语法分析,从而 *产生语法树(Syntax Tree)* ,整个分析过程采用了 *上下文无关语法(Context-free Grammar)的分析手段.

语法分析器的工具叫做 yacc(Yet Another Compiler Compiler).

**** 语义分析(Semantic Analyzer)
语法分析仅仅完成了对表达式的语法层面分析,但是它并不了解这个语句是否真正有意义.编译器所能分析的是 *静态语义(Static Semantic)*,是指在编译时可以确定的语义,与之对应的是 *动态语义(Dynaic Semantic)* 就是只有在运行期才能确定的语义.经过语义分析后,语法树的表达式都被标识了类型,如果有些类型需要作隐式转换,语义分析程序会在语法树中插入相应的转换节点.

**** 中间语言生成
*源代码优化器(Source Code Optimizer)* 在源代码级别进行优化,但是由于直接在语法树上做优化比较困难,所以源代码优化器往往将整个语法树转换成 *中间代码(Intermediate Code)*, 它是语法树的顺序表示.中间代码有很多种形式,在不同的编译器中有着不同的形式,比较常见的有: *三地址码(Three-address Code)* 和 *P-代码(P-Code)*.
中间代码使得编译器可以被分为前端和后端,编译器前端负责产生机器无关的中间代码,后端将中间代码转换成目标机器码.这样对于一些跨平台的编译器而言,它们可以针对不同的平台使用同一个前端和不同的后端.

**** 目标代码生成与优化
源代码级优化器产生中间代码标志着下面的过程都属于后端,后端主要包括 *代码生成器(Code Generator)* 和 *目标代码优化器(Target Code Optimizer)*.
代码生成器将中间代码转换为目标机器码,这个过程十分依赖于目标机器.

*** 汇编
将编译后的汇编代码转变为二进制文件,因为汇编都有对应的二进制值,所以汇编器的汇编过程相对于编译器来讲比较简单.
在gcc中,讲汇编文件到二进制文件使用命令 =gcc -c hello.s -o hello.o / gcc -c hello.c -o hello.o=,也可以使用 as  来完成.
经过预编译,编译,汇编之后的 .o 文件被称为 *目标文件*.
*** 链接
    将目标文件与库文件以一定的规则, *确定的地址* 结合,才能形成最后的可执行文件.
** 目标文件解析
*** 目标文件格式
PC 平台流行的 *可执行文件格式(Executable)* 主要是 Windows 下的 PE(Portable Executable) 和 Linux 的 ELF(Executable Linkable Format),
它们都是 COFF(Common file format)格式的变种.目标文件和可执行文件的格式是一样的, *动态链接库(DLL, Dynamic Linking Library)和静态链接库(Static Linking Library)* 
都按照可执行文件格式存储.

| ELF文件类型                      | 说明                                                                                                                                                                                                                          | 实例                        |
|----------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------|
| 可重定位文件(Relocatable File)   | 这类文件包含了代码和数据,可以被用来链接成可执行文件或共享目标文件,静态链接库也可以归为这一类                                                                                                                                  | Linux 的 .o Windows 的 .obj |
| 可执行文件(Executable File)      | 这类文件包含了可以直接执行的程序,它的代表就是ELF可执行文件,一般都没有扩展名                                                                                                                                                   | /bin/bash windows 的 .exe   |
| 共享目标文件(Shared Object File) | 这种文件包含库代码和数据,可以在以下两种情况下使用.一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接,产生新的目标文件.第二种是动态连接器可以将几个这种共享目标文件与可执行文件结合,作为进程影响的一部分来运行 | Linux 的 .so Windows 的 DLL |
| 核心转储文件(Core Dump File)     | 当进程意外中止时,系统可以将进程的地址空间的内容以及终止时的一些其他信息转储到核心转储文件                                                                                                                             | Linux 下的 core dump          |
|                                  |                                                                                                                                                                                                                               |                             |

在linux下可以使用 =file= 命令查看相应的文件格式.

*** 目标文件分段
目标文件将编译得到的信息以 *节(Section)* 的形式存储,有时候也叫 *段(Segment)*.
程序源代码编译后的机器指令经常被放在 *代码段(Code Section)* 里,代码段常见的名字有".code"或".text".
全局变量和局部静态变量数据放在 *数据段(Data Section)*, 数据段的一般名字都叫".data".
未初始化的全局变量和局部静态变量一般放在一个叫 ".bss"段里,程序运行的时候它们是要占内存空间的,并且可执行文件必须记录所有未初始化的全局和局部静态变量的大小总和.所以 .bss段只是为初始化的全局变量和局部静态变量预留位置而已,它并没有内容,所以它在文件中也不占据空间.

**** 分段的好处
1. 数据和指令分别被映射到两个虚存区域,数据区被设置为可读写,指令区被设置为只读,可以防止程序指令被有意或无意的改写.
2. 由于 CPU 的缓存体系,分段有利于提高程序的局部性,提高缓存的命中率.
3. 当系统中运行着多个该程序的副本时,可以共享代码段而区分数据段,节约内存.
